// Code generated from Cypher.g4 by ANTLR 4.10. DO NOT EDIT.

package parser // Cypher

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CypherParser struct {
	*antlr.BaseParser
}

var cypherParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cypherParserInit() {
	staticData := &cypherParserStaticData
	staticData.literalNames = []string{
		"", "';'", "':'", "'-'", "'=>'", "'://'", "'/'", "'.'", "'@'", "'#'",
		"'?'", "'&'", "'='", "'+'", "'{'", "','", "'}'", "'['", "']'", "'*'",
		"'('", "')'", "'+='", "'|'", "'..'", "'%'", "'^'", "'=~'", "'<>'", "'!='",
		"'<'", "'>'", "'<='", "'>='", "'$'", "'\\u27E8'", "'\\u3008'", "'\\uFE64'",
		"'\\uFF1C'", "'\\u27E9'", "'\\u3009'", "'\\uFE65'", "'\\uFF1E'", "'\\u00AD'",
		"'\\u2010'", "'\\u2011'", "'\\u2012'", "'\\u2013'", "'\\u2014'", "'\\u2015'",
		"'\\u2212'", "'\\uFE58'", "'\\uFE63'", "'\\uFF0D'", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "'0'",
	}
	staticData.symbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "CYPHER", "EXPLAIN", "PROFILE", "USING", "PERIODIC", "COMMIT",
		"UNION", "ALL", "CREATE", "DROP", "INDEX", "ON", "CONSTRAINT", "ASSERT",
		"IS", "UNIQUE", "EXISTS", "LOAD", "CSV", "WITH", "HEADERS", "FROM",
		"AS", "FIELDTERMINATOR", "OPTIONAL", "MATCH", "UNWIND", "MERGE", "SET",
		"DETACH", "DELETE", "REMOVE", "FOREACH", "IN", "DISTINCT", "RETURN",
		"ORDER", "BY", "L_SKIP", "LIMIT", "ASCENDING", "ASC", "DESCENDING",
		"DESC", "JOIN", "SCAN", "START", "NODE", "RELATIONSHIP", "REL", "WHERE",
		"SHORTESTPATH", "ALLSHORTESTPATHS", "OR", "XOR", "AND", "NOT", "STARTS",
		"ENDS", "CONTAINS", "NULL", "COUNT", "FILTER", "EXTRACT", "ANY", "NONE",
		"SINGLE", "TRUE", "FALSE", "REDUCE", "CASE", "ELSE", "END", "WHEN",
		"THEN", "CALL", "YIELD", "KEY", "CATALOG", "SHOW", "DEFAULT", "DBMS",
		"DATABASE", "DATABASES", "GRAPH", "GRAPHS", "REPLACE", "IF", "STOP",
		"ROLE", "ROLES", "USER", "USERS", "POPULATED", "PASSWORD", "CHANGE",
		"REQUIRED", "STATUS", "ACTIVE", "SUSPENDED", "ALTER", "CURRENT", "TO",
		"PRIVILEGES", "GRANT", "DENY", "REVOKE", "RELATIONSHIPS", "NODES", "ELEMENT",
		"ELEMENTS", "COPY", "OF", "TRAVERSE", "READ", "WRITE", "ACCESS", "INDEXES",
		"MANAGEMENT", "NEW", "LABEL", "LABELS", "NAME", "NAMES", "TYPE", "TYPES",
		"PROPERTY", "CONSTRAINTS", "ASSIGN", "BTREE", "EXIST", "FOR", "OPTIONS",
		"EXECUTE", "DEFINED", "FUNCTION", "FUNCTIONS", "BOOSTED", "PROCEDURE",
		"PROCEDURES", "ADMIN", "ADMINISTRATOR", "BRIEF", "VERBOSE", "OUTPUT",
		"BUILT", "EACH", "EXECUTABLE", "EXISTENCE", "FULLTEXT", "HOME", "LOOKUP",
		"RENAME", "StringLiteral", "UrlHex", "EscapedChar", "HexInteger", "DecimalInteger",
		"OctalInteger", "HexLetter", "HexDigit", "Digit", "NonZeroDigit", "NonZeroOctDigit",
		"OctDigit", "ZeroDigit", "ExponentDecimalReal", "RegularDecimalReal",
		"UnescapedSymbolicName", "IdentifierStart", "IdentifierPart", "EscapedSymbolicName",
		"SP", "WHITESPACE", "Comment", "ERROR_TOKEN",
	}
	staticData.ruleNames = []string{
		"cypher", "cypherPart", "cypherConsoleCommand", "cypherConsoleCommandName",
		"cypherConsoleCommandParameters", "cypherConsoleCommandParameter", "arrowExpression",
		"url", "uri", "scheme", "host", "hostname", "hostnumber", "port", "path",
		"user", "login", "password", "frag", "urlQuery", "search", "searchparameter",
		"str", "urlDigits", "json", "obj", "pair", "array", "value", "keyValueLiteral",
		"commandPath", "subCommand", "cypherQuery", "queryOptions", "anyCypherOption",
		"cypherOption", "versionNumber", "explain", "profile", "configurationOption",
		"statement", "query", "regularQuery", "bulkImportQuery", "singleQuery",
		"periodicCommitHint", "loadCSVQuery", "union", "clause", "command",
		"systemCommand", "multidatabaseCommand", "userCommand", "privilegeCommand",
		"showRoles", "createRole", "copyRole", "dropRole", "showUsers", "createUser",
		"dropUser", "alterUser", "showPrivileges", "grantPrivilege", "denyPrivilege",
		"revokePrivilege", "revokePart", "databaseScope", "graphScope", "roles",
		"grantableGraphPrivileges", "revokeableGraphPrivileges", "datasbasePrivilege",
		"dbmsPrivilege", "elementScope", "propertiesList", "propertyScope",
		"showDatabase", "createDatabase", "dropDatabase", "startDatabase", "stopDatabase",
		"ifNotExists", "ifExists", "orReplace", "setPassword", "passwordStatus",
		"setStatus", "userStatus", "createUniqueConstraint", "createNodeKeyConstraint",
		"createNodePropertyExistenceConstraint", "createRelationshipPropertyExistenceConstraint",
		"createIndex", "dropUniqueConstraint", "dropNodeKeyConstraint", "dropNodePropertyExistenceConstraint",
		"dropRelationshipPropertyExistenceConstraint", "dropIndex", "index",
		"uniqueConstraint", "nodeKeyConstraint", "nodePropertyExistenceConstraint",
		"relationshipPropertyExistenceConstraint", "relationshipPatternSyntax",
		"loadCSVClause", "matchClause", "unwindClause", "mergeClause", "mergeAction",
		"createClause", "createUniqueClause", "setClause", "setItem", "deleteClause",
		"removeClause", "removeItem", "foreachClause", "withClause", "returnClause",
		"returnBody", "function", "returnItems", "returnItem", "call", "procedureInvocation",
		"procedureInvocationBody", "procedureArguments", "procedureResults",
		"procedureResult", "aliasedProcedureResult", "simpleProcedureResult",
		"procedureOutput", "order", "skip", "limit", "sortItem", "hint", "startClause",
		"startPoint", "lookup", "nodeLookup", "relationshipLookup", "identifiedIndexLookup",
		"indexQuery", "idLookup", "literalIds", "where", "pattern", "patternPart",
		"anonymousPatternPart", "patternElement", "nodePattern", "patternElementChain",
		"relationshipPattern", "relationshipPatternStart", "relationshipPatternEnd",
		"relationshipDetail", "properties", "relType", "relationshipTypes",
		"relationshipType", "relationshipTypeOptionalColon", "nodeLabels", "nodeLabel",
		"rangeLiteral", "labelName", "relTypeName", "expression", "orExpression",
		"xorExpression", "andExpression", "notExpression", "comparisonExpression",
		"addOrSubtractExpression", "multiplyDivideModuloExpression", "powerOfExpression",
		"unaryAddOrSubtractExpression", "stringListNullOperatorExpression",
		"propertyOrLabelsExpression", "filterFunction", "filterFunctionName",
		"existsFunction", "existsFunctionName", "allFunction", "allFunctionName",
		"anyFunction", "anyFunctionName", "noneFunction", "noneFunctionName",
		"singleFunction", "singleFunctionName", "extractFunction", "extractFunctionName",
		"reduceFunction", "reduceFunctionName", "shortestPathPatternFunction",
		"shortestPathFunctionName", "allShortestPathFunctionName", "atom", "literal",
		"stringLiteral", "booleanLiteral", "listLiteral", "partialComparisonExpression",
		"parenthesizedExpression", "relationshipsPattern", "filterExpression",
		"idInColl", "functionInvocation", "functionInvocationBody", "functionName",
		"procedureName", "listComprehension", "patternComprehension", "propertyLookup",
		"caseExpression", "caseAlternatives", "variable", "numberLiteral", "mapLiteral",
		"mapProjection", "mapProjectionVariants", "literalEntry", "propertySelector",
		"variableSelector", "allPropertiesSelector", "parameter", "legacyParameter",
		"dollarParameter", "parameterName", "propertyExpressions", "propertyExpression",
		"propertyKeys", "propertyKeyName", "integerLiteral", "doubleLiteral",
		"namespace", "leftArrowHead", "rightArrowHead", "dash", "symbolicName",
		"keyword",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 229, 3443, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 1, 0, 1, 0,
		1, 0, 5, 0, 490, 8, 0, 10, 0, 12, 0, 493, 9, 0, 1, 0, 3, 0, 496, 8, 0,
		1, 0, 1, 0, 1, 1, 3, 1, 501, 8, 1, 1, 1, 1, 1, 3, 1, 505, 8, 1, 1, 1, 3,
		1, 508, 8, 1, 1, 2, 1, 2, 1, 2, 3, 2, 513, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3,
		5, 3, 519, 8, 3, 10, 3, 12, 3, 522, 9, 3, 1, 4, 1, 4, 1, 4, 5, 4, 527,
		8, 4, 10, 4, 12, 4, 530, 9, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 3, 5, 542, 8, 5, 1, 6, 1, 6, 3, 6, 546, 8, 6, 1, 6, 1,
		6, 3, 6, 550, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 3, 8, 559,
		8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 564, 8, 8, 1, 8, 1, 8, 3, 8, 568, 8, 8, 1,
		8, 3, 8, 571, 8, 8, 1, 8, 3, 8, 574, 8, 8, 1, 9, 1, 9, 1, 10, 3, 10, 579,
		8, 10, 1, 10, 1, 10, 3, 10, 583, 8, 10, 1, 11, 1, 11, 1, 11, 5, 11, 588,
		8, 11, 10, 11, 12, 11, 591, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 5, 14, 606, 8, 14,
		10, 14, 12, 14, 609, 9, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20,
		1, 20, 5, 20, 629, 8, 20, 10, 20, 12, 20, 632, 9, 20, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 3, 21, 639, 8, 21, 3, 21, 641, 8, 21, 1, 22, 1, 22, 3,
		22, 645, 8, 22, 1, 22, 5, 22, 648, 8, 22, 10, 22, 12, 22, 651, 9, 22, 1,
		23, 4, 23, 654, 8, 23, 11, 23, 12, 23, 655, 1, 24, 1, 24, 1, 25, 1, 25,
		3, 25, 662, 8, 25, 1, 25, 1, 25, 3, 25, 666, 8, 25, 1, 25, 1, 25, 3, 25,
		670, 8, 25, 1, 25, 1, 25, 3, 25, 674, 8, 25, 5, 25, 676, 8, 25, 10, 25,
		12, 25, 679, 9, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 685, 8, 25, 1, 25,
		3, 25, 688, 8, 25, 1, 26, 1, 26, 3, 26, 692, 8, 26, 1, 26, 1, 26, 3, 26,
		696, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 3, 27, 702, 8, 27, 1, 27, 1, 27,
		3, 27, 706, 8, 27, 1, 27, 1, 27, 3, 27, 710, 8, 27, 1, 27, 1, 27, 3, 27,
		714, 8, 27, 5, 27, 716, 8, 27, 10, 27, 12, 27, 719, 9, 27, 1, 27, 1, 27,
		1, 27, 1, 27, 3, 27, 725, 8, 27, 1, 27, 3, 27, 728, 8, 27, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 736, 8, 28, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 3, 29, 745, 8, 29, 1, 30, 1, 30, 1, 30, 3, 30,
		750, 8, 30, 4, 30, 752, 8, 30, 11, 30, 12, 30, 753, 1, 30, 3, 30, 757,
		8, 30, 1, 31, 1, 31, 1, 31, 5, 31, 762, 8, 31, 10, 31, 12, 31, 765, 9,
		31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 3, 33, 772, 8, 33, 5, 33, 774, 8,
		33, 10, 33, 12, 33, 777, 9, 33, 1, 34, 1, 34, 1, 34, 3, 34, 782, 8, 34,
		1, 35, 1, 35, 1, 35, 3, 35, 787, 8, 35, 1, 35, 1, 35, 5, 35, 791, 8, 35,
		10, 35, 12, 35, 794, 9, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1,
		39, 1, 39, 3, 39, 804, 8, 39, 1, 39, 1, 39, 3, 39, 808, 8, 39, 1, 39, 1,
		39, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 816, 8, 40, 1, 40, 3, 40, 819, 8,
		40, 1, 41, 1, 41, 3, 41, 823, 8, 41, 1, 42, 1, 42, 3, 42, 827, 8, 42, 1,
		42, 5, 42, 830, 8, 42, 10, 42, 12, 42, 833, 9, 42, 1, 43, 1, 43, 3, 43,
		837, 8, 43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 843, 8, 44, 1, 44, 5, 44,
		846, 8, 44, 10, 44, 12, 44, 849, 9, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 3, 45, 858, 8, 45, 1, 46, 1, 46, 3, 46, 862, 8, 46, 1,
		46, 5, 46, 865, 8, 46, 10, 46, 12, 46, 868, 9, 46, 1, 47, 1, 47, 1, 47,
		1, 47, 3, 47, 874, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 879, 8, 47, 1, 47,
		3, 47, 882, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 898, 8, 48, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 910,
		8, 49, 1, 50, 1, 50, 1, 50, 3, 50, 915, 8, 50, 1, 51, 1, 51, 1, 51, 1,
		51, 1, 51, 3, 51, 922, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 3, 52, 931, 8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 937, 8, 53,
		1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 943, 8, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 3, 54, 950, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 956, 8,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 963, 8, 54, 3, 54, 965, 8,
		54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 974, 8, 55,
		1, 55, 1, 55, 3, 55, 978, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3,
		55, 985, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 992, 8, 55, 3,
		55, 994, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1013,
		8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 3, 59, 1027, 8, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1032,
		8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1039, 8, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1048, 8, 59, 3, 59, 1050,
		8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1059, 8,
		60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1075, 8, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 3, 61, 1081, 8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 3, 61, 1092, 8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 3, 61, 1102, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62,
		1108, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3,
		62, 1118, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		3, 62, 1128, 8, 62, 1, 62, 3, 62, 1131, 8, 62, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3,
		63, 1178, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1225, 8, 64, 1, 65, 1, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 3, 65, 1240, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		1248, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66,
		1268, 8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1277,
		8, 67, 1, 67, 1, 67, 3, 67, 1281, 8, 67, 1, 67, 5, 67, 1284, 8, 67, 10,
		67, 12, 67, 1287, 9, 67, 3, 67, 1289, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 3, 68, 1298, 8, 68, 1, 68, 1, 68, 3, 68, 1302, 8,
		68, 1, 68, 5, 68, 1305, 8, 68, 10, 68, 12, 68, 1308, 9, 68, 3, 68, 1310,
		8, 68, 1, 69, 1, 69, 3, 69, 1314, 8, 69, 1, 69, 1, 69, 3, 69, 1318, 8,
		69, 1, 69, 5, 69, 1321, 8, 69, 10, 69, 12, 69, 1324, 9, 69, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 3, 70, 1331, 8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1336,
		8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1343, 8, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 3, 71, 1349, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		1, 72, 3, 72, 1378, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1,
		72, 3, 72, 1387, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		3, 72, 1396, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1402, 8, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 3, 72, 1408, 8, 72, 1, 72, 3, 72, 1411, 8, 72,
		3, 72, 1413, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		3, 73, 1433, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1440, 8,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1447, 8, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 3, 74, 1454, 8, 74, 3, 74, 1456, 8, 74, 1, 75, 1,
		75, 1, 75, 3, 75, 1461, 8, 75, 1, 75, 1, 75, 3, 75, 1465, 8, 75, 1, 75,
		5, 75, 1468, 8, 75, 10, 75, 12, 75, 1471, 9, 75, 3, 75, 1473, 8, 75, 1,
		76, 1, 76, 3, 76, 1477, 8, 76, 1, 76, 1, 76, 3, 76, 1481, 8, 76, 1, 76,
		1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1489, 8, 77, 1, 77, 1, 77, 1,
		77, 1, 77, 3, 77, 1495, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 3, 78, 1504, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1511,
		8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1516, 8, 78, 1, 79, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 3, 79, 1525, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80,
		1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84,
		1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1559, 8, 85, 1,
		85, 1, 85, 3, 85, 1563, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85,
		1570, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1576, 8, 86, 1, 86, 1,
		86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 89, 1, 89,
		1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1,
		97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99,
		3, 99, 1632, 8, 99, 1, 99, 1, 99, 3, 99, 1636, 8, 99, 1, 99, 1, 99, 3,
		99, 1640, 8, 99, 1, 99, 1, 99, 3, 99, 1644, 8, 99, 1, 99, 1, 99, 1, 100,
		1, 100, 1, 100, 1, 100, 3, 100, 1652, 8, 100, 1, 100, 1, 100, 3, 100, 1656,
		8, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1661, 8, 100, 1, 100, 1, 100, 3,
		100, 1665, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1679, 8, 101, 1, 101, 1,
		101, 3, 101, 1683, 8, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1688, 8, 101,
		1, 101, 1, 101, 3, 101, 1692, 8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 3,
		101, 1698, 8, 101, 1, 101, 1, 101, 3, 101, 1702, 8, 101, 1, 101, 1, 101,
		1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102,
		1, 102, 3, 102, 1716, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3,
		102, 1723, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1729, 8, 102,
		1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103,
		1739, 8, 103, 1, 103, 1, 103, 3, 103, 1743, 8, 103, 1, 103, 1, 103, 1,
		103, 1, 103, 3, 103, 1749, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104,
		1, 104, 3, 104, 1757, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 3, 104, 1768, 8, 104, 1, 104, 1, 104, 1, 104,
		1, 104, 3, 104, 1774, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1786, 8, 104, 1, 104, 1, 104,
		1, 104, 1, 104, 3, 104, 1792, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1804, 8, 104, 1, 104,
		1, 104, 3, 104, 1808, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1,
		105, 1, 105, 1, 105, 3, 105, 1818, 8, 105, 1, 105, 1, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1831, 8,
		105, 1, 106, 1, 106, 3, 106, 1835, 8, 106, 1, 106, 1, 106, 3, 106, 1839,
		8, 106, 1, 106, 1, 106, 5, 106, 1843, 8, 106, 10, 106, 12, 106, 1846, 9,
		106, 1, 106, 3, 106, 1849, 8, 106, 1, 106, 3, 106, 1852, 8, 106, 1, 107,
		1, 107, 3, 107, 1856, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 108, 1, 108, 3, 108, 1866, 8, 108, 1, 108, 1, 108, 1, 108, 5, 108,
		1871, 8, 108, 10, 108, 12, 108, 1874, 9, 108, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1886, 8, 109,
		1, 110, 1, 110, 3, 110, 1890, 8, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1,
		111, 1, 111, 3, 111, 1898, 8, 111, 1, 111, 1, 111, 1, 112, 1, 112, 3, 112,
		1904, 8, 112, 1, 112, 1, 112, 3, 112, 1908, 8, 112, 1, 112, 1, 112, 3,
		112, 1912, 8, 112, 1, 112, 5, 112, 1915, 8, 112, 10, 112, 12, 112, 1918,
		9, 112, 1, 113, 1, 113, 3, 113, 1922, 8, 113, 1, 113, 1, 113, 3, 113, 1926,
		8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1932, 8, 113, 1, 113, 1,
		113, 3, 113, 1936, 8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1942,
		8, 113, 1, 113, 1, 113, 3, 113, 1946, 8, 113, 1, 113, 1, 113, 1, 113, 1,
		113, 3, 113, 1952, 8, 113, 1, 113, 1, 113, 3, 113, 1956, 8, 113, 1, 114,
		1, 114, 3, 114, 1960, 8, 114, 1, 114, 1, 114, 3, 114, 1964, 8, 114, 1,
		114, 1, 114, 3, 114, 1968, 8, 114, 1, 114, 1, 114, 3, 114, 1972, 8, 114,
		1, 114, 5, 114, 1975, 8, 114, 10, 114, 12, 114, 1978, 9, 114, 1, 115, 1,
		115, 1, 115, 1, 115, 3, 115, 1984, 8, 115, 1, 115, 1, 115, 3, 115, 1988,
		8, 115, 1, 115, 5, 115, 1991, 8, 115, 10, 115, 12, 115, 1994, 9, 115, 1,
		116, 1, 116, 1, 116, 1, 116, 3, 116, 2000, 8, 116, 1, 117, 1, 117, 3, 117,
		2004, 8, 117, 1, 117, 1, 117, 3, 117, 2008, 8, 117, 1, 117, 1, 117, 1,
		117, 1, 117, 1, 117, 1, 117, 3, 117, 2016, 8, 117, 1, 117, 1, 117, 1, 117,
		4, 117, 2021, 8, 117, 11, 117, 12, 117, 2022, 1, 117, 3, 117, 2026, 8,
		117, 1, 117, 1, 117, 1, 118, 1, 118, 3, 118, 2032, 8, 118, 1, 118, 3, 118,
		2035, 8, 118, 1, 118, 1, 118, 1, 118, 3, 118, 2040, 8, 118, 1, 118, 3,
		118, 2043, 8, 118, 1, 119, 1, 119, 3, 119, 2047, 8, 119, 1, 119, 3, 119,
		2050, 8, 119, 1, 119, 3, 119, 2053, 8, 119, 1, 119, 1, 119, 1, 120, 1,
		120, 1, 120, 3, 120, 2060, 8, 120, 1, 120, 1, 120, 3, 120, 2064, 8, 120,
		1, 120, 1, 120, 3, 120, 2068, 8, 120, 1, 121, 1, 121, 3, 121, 2072, 8,
		121, 1, 121, 3, 121, 2075, 8, 121, 1, 122, 1, 122, 3, 122, 2079, 8, 122,
		1, 122, 1, 122, 3, 122, 2083, 8, 122, 1, 122, 5, 122, 2086, 8, 122, 10,
		122, 12, 122, 2089, 9, 122, 1, 122, 1, 122, 3, 122, 2093, 8, 122, 1, 122,
		1, 122, 3, 122, 2097, 8, 122, 1, 122, 5, 122, 2100, 8, 122, 10, 122, 12,
		122, 2103, 9, 122, 1, 122, 3, 122, 2106, 8, 122, 1, 123, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 2115, 8, 123, 1, 124, 1, 124, 1,
		124, 1, 124, 3, 124, 2121, 8, 124, 1, 124, 3, 124, 2124, 8, 124, 1, 125,
		1, 125, 3, 125, 2128, 8, 125, 1, 125, 3, 125, 2131, 8, 125, 1, 126, 1,
		126, 1, 126, 1, 127, 1, 127, 3, 127, 2138, 8, 127, 1, 127, 3, 127, 2141,
		8, 127, 1, 127, 3, 127, 2144, 8, 127, 1, 127, 1, 127, 3, 127, 2148, 8,
		127, 1, 127, 5, 127, 2151, 8, 127, 10, 127, 12, 127, 2154, 9, 127, 1, 127,
		3, 127, 2157, 8, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 3,
		128, 2165, 8, 128, 1, 128, 1, 128, 3, 128, 2169, 8, 128, 1, 128, 5, 128,
		2172, 8, 128, 10, 128, 12, 128, 2175, 9, 128, 1, 128, 1, 128, 3, 128, 2179,
		8, 128, 1, 129, 1, 129, 3, 129, 2183, 8, 129, 1, 130, 1, 130, 1, 130, 1,
		130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 132, 1, 132, 1, 133, 1, 133, 1,
		133, 1, 133, 1, 133, 1, 133, 3, 133, 2201, 8, 133, 1, 133, 1, 133, 3, 133,
		2205, 8, 133, 1, 133, 5, 133, 2208, 8, 133, 10, 133, 12, 133, 2211, 9,
		133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1,
		136, 1, 136, 3, 136, 2223, 8, 136, 1, 136, 1, 136, 3, 136, 2227, 8, 136,
		3, 136, 2229, 8, 136, 1, 137, 3, 137, 2232, 8, 137, 1, 137, 1, 137, 1,
		137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 2241, 8, 137, 1, 137, 1, 137,
		3, 137, 2245, 8, 137, 1, 137, 1, 137, 3, 137, 2249, 8, 137, 1, 137, 1,
		137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3,
		137, 2261, 8, 137, 1, 137, 1, 137, 3, 137, 2265, 8, 137, 1, 137, 5, 137,
		2268, 8, 137, 10, 137, 12, 137, 2271, 9, 137, 1, 137, 1, 137, 1, 137, 1,
		137, 1, 137, 1, 137, 1, 137, 3, 137, 2280, 8, 137, 1, 138, 1, 138, 1, 138,
		1, 138, 3, 138, 2286, 8, 138, 1, 138, 1, 138, 3, 138, 2290, 8, 138, 1,
		138, 5, 138, 2293, 8, 138, 10, 138, 12, 138, 2296, 9, 138, 1, 138, 3, 138,
		2299, 8, 138, 1, 139, 1, 139, 3, 139, 2303, 8, 139, 1, 139, 1, 139, 3,
		139, 2307, 8, 139, 1, 139, 1, 139, 1, 140, 1, 140, 3, 140, 2313, 8, 140,
		1, 141, 1, 141, 3, 141, 2317, 8, 141, 1, 141, 1, 141, 1, 141, 3, 141, 2322,
		8, 141, 1, 142, 1, 142, 1, 142, 1, 142, 3, 142, 2328, 8, 142, 1, 143, 1,
		143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 2337, 8, 143, 1, 143,
		1, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 2346, 8, 144, 1,
		144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 2354, 8, 145, 1, 145,
		1, 145, 1, 146, 1, 146, 3, 146, 2360, 8, 146, 1, 146, 1, 146, 3, 146, 2364,
		8, 146, 1, 146, 5, 146, 2367, 8, 146, 10, 146, 12, 146, 2370, 9, 146, 1,
		147, 1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 3, 148, 2378, 8, 148, 1, 148,
		1, 148, 3, 148, 2382, 8, 148, 1, 148, 5, 148, 2385, 8, 148, 10, 148, 12,
		148, 2388, 9, 148, 1, 149, 1, 149, 3, 149, 2392, 8, 149, 1, 149, 1, 149,
		3, 149, 2396, 8, 149, 1, 149, 1, 149, 1, 149, 3, 149, 2401, 8, 149, 1,
		150, 1, 150, 3, 150, 2405, 8, 150, 1, 151, 1, 151, 3, 151, 2409, 8, 151,
		1, 151, 5, 151, 2412, 8, 151, 10, 151, 12, 151, 2415, 9, 151, 1, 151, 1,
		151, 1, 151, 1, 151, 3, 151, 2421, 8, 151, 1, 152, 1, 152, 3, 152, 2425,
		8, 152, 1, 152, 1, 152, 3, 152, 2429, 8, 152, 3, 152, 2431, 8, 152, 1,
		152, 1, 152, 3, 152, 2435, 8, 152, 3, 152, 2437, 8, 152, 1, 152, 1, 152,
		3, 152, 2441, 8, 152, 3, 152, 2443, 8, 152, 1, 152, 1, 152, 1, 153, 1,
		153, 3, 153, 2449, 8, 153, 1, 153, 1, 153, 1, 154, 1, 154, 3, 154, 2455,
		8, 154, 1, 154, 3, 154, 2458, 8, 154, 1, 154, 3, 154, 2461, 8, 154, 1,
		154, 1, 154, 1, 155, 1, 155, 3, 155, 2467, 8, 155, 1, 155, 1, 155, 1, 155,
		3, 155, 2472, 8, 155, 1, 156, 1, 156, 3, 156, 2476, 8, 156, 1, 156, 1,
		156, 1, 156, 3, 156, 2481, 8, 156, 1, 157, 1, 157, 3, 157, 2485, 8, 157,
		1, 157, 1, 157, 3, 157, 2489, 8, 157, 3, 157, 2491, 8, 157, 1, 157, 1,
		157, 3, 157, 2495, 8, 157, 3, 157, 2497, 8, 157, 1, 157, 3, 157, 2500,
		8, 157, 1, 157, 1, 157, 3, 157, 2504, 8, 157, 3, 157, 2506, 8, 157, 1,
		157, 1, 157, 1, 158, 1, 158, 3, 158, 2512, 8, 158, 1, 159, 1, 159, 3, 159,
		2516, 8, 159, 1, 159, 1, 159, 1, 160, 1, 160, 3, 160, 2522, 8, 160, 1,
		160, 1, 160, 5, 160, 2526, 8, 160, 10, 160, 12, 160, 2529, 9, 160, 1, 161,
		1, 161, 1, 161, 1, 162, 3, 162, 2535, 8, 162, 1, 162, 1, 162, 1, 163, 1,
		163, 3, 163, 2541, 8, 163, 1, 163, 5, 163, 2544, 8, 163, 10, 163, 12, 163,
		2547, 9, 163, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 3, 165, 2554, 8,
		165, 1, 165, 1, 165, 3, 165, 2558, 8, 165, 3, 165, 2560, 8, 165, 1, 165,
		1, 165, 3, 165, 2564, 8, 165, 1, 165, 1, 165, 3, 165, 2568, 8, 165, 3,
		165, 2570, 8, 165, 3, 165, 2572, 8, 165, 1, 166, 1, 166, 1, 167, 1, 167,
		1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 2585, 8,
		169, 10, 169, 12, 169, 2588, 9, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1,
		170, 5, 170, 2595, 8, 170, 10, 170, 12, 170, 2598, 9, 170, 1, 171, 1, 171,
		1, 171, 1, 171, 1, 171, 5, 171, 2605, 8, 171, 10, 171, 12, 171, 2608, 9,
		171, 1, 172, 1, 172, 3, 172, 2612, 8, 172, 5, 172, 2614, 8, 172, 10, 172,
		12, 172, 2617, 9, 172, 1, 172, 1, 172, 1, 173, 1, 173, 3, 173, 2623, 8,
		173, 1, 173, 5, 173, 2626, 8, 173, 10, 173, 12, 173, 2629, 9, 173, 1, 174,
		1, 174, 3, 174, 2633, 8, 174, 1, 174, 1, 174, 3, 174, 2637, 8, 174, 1,
		174, 1, 174, 3, 174, 2641, 8, 174, 1, 174, 1, 174, 3, 174, 2645, 8, 174,
		1, 174, 5, 174, 2648, 8, 174, 10, 174, 12, 174, 2651, 9, 174, 1, 175, 1,
		175, 3, 175, 2655, 8, 175, 1, 175, 1, 175, 3, 175, 2659, 8, 175, 1, 175,
		1, 175, 3, 175, 2663, 8, 175, 1, 175, 1, 175, 3, 175, 2667, 8, 175, 1,
		175, 1, 175, 3, 175, 2671, 8, 175, 1, 175, 1, 175, 3, 175, 2675, 8, 175,
		1, 175, 5, 175, 2678, 8, 175, 10, 175, 12, 175, 2681, 9, 175, 1, 176, 1,
		176, 3, 176, 2685, 8, 176, 1, 176, 1, 176, 3, 176, 2689, 8, 176, 1, 176,
		5, 176, 2692, 8, 176, 10, 176, 12, 176, 2695, 9, 176, 1, 177, 1, 177, 3,
		177, 2699, 8, 177, 5, 177, 2701, 8, 177, 10, 177, 12, 177, 2704, 9, 177,
		1, 177, 1, 177, 1, 178, 1, 178, 3, 178, 2710, 8, 178, 1, 178, 1, 178, 1,
		178, 1, 178, 1, 178, 3, 178, 2717, 8, 178, 1, 178, 1, 178, 3, 178, 2721,
		8, 178, 1, 178, 1, 178, 3, 178, 2725, 8, 178, 1, 178, 1, 178, 3, 178, 2729,
		8, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178,
		1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 2744, 8, 178, 1, 178, 3,
		178, 2747, 8, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178,
		1, 178, 1, 178, 1, 178, 1, 178, 5, 178, 2760, 8, 178, 10, 178, 12, 178,
		2763, 9, 178, 1, 179, 1, 179, 3, 179, 2767, 8, 179, 1, 179, 1, 179, 3,
		179, 2771, 8, 179, 5, 179, 2773, 8, 179, 10, 179, 12, 179, 2776, 9, 179,
		1, 180, 1, 180, 3, 180, 2780, 8, 180, 1, 180, 1, 180, 3, 180, 2784, 8,
		180, 1, 180, 1, 180, 3, 180, 2788, 8, 180, 1, 180, 1, 180, 1, 181, 1, 181,
		1, 182, 1, 182, 3, 182, 2796, 8, 182, 1, 182, 1, 182, 3, 182, 2800, 8,
		182, 1, 182, 1, 182, 3, 182, 2804, 8, 182, 1, 182, 1, 182, 1, 183, 1, 183,
		1, 184, 1, 184, 3, 184, 2812, 8, 184, 1, 184, 1, 184, 3, 184, 2816, 8,
		184, 1, 184, 1, 184, 3, 184, 2820, 8, 184, 1, 184, 1, 184, 1, 185, 1, 185,
		1, 186, 1, 186, 3, 186, 2828, 8, 186, 1, 186, 1, 186, 3, 186, 2832, 8,
		186, 1, 186, 1, 186, 3, 186, 2836, 8, 186, 1, 186, 1, 186, 1, 187, 1, 187,
		1, 188, 1, 188, 3, 188, 2844, 8, 188, 1, 188, 1, 188, 3, 188, 2848, 8,
		188, 1, 188, 1, 188, 3, 188, 2852, 8, 188, 1, 188, 1, 188, 1, 189, 1, 189,
		1, 190, 1, 190, 3, 190, 2860, 8, 190, 1, 190, 1, 190, 3, 190, 2864, 8,
		190, 1, 190, 1, 190, 3, 190, 2868, 8, 190, 1, 190, 1, 190, 1, 191, 1, 191,
		1, 192, 1, 192, 3, 192, 2876, 8, 192, 1, 192, 1, 192, 3, 192, 2880, 8,
		192, 1, 192, 1, 192, 3, 192, 2884, 8, 192, 1, 192, 1, 192, 3, 192, 2888,
		8, 192, 1, 192, 3, 192, 2891, 8, 192, 1, 192, 3, 192, 2894, 8, 192, 1,
		192, 1, 192, 1, 193, 1, 193, 1, 194, 1, 194, 3, 194, 2902, 8, 194, 1, 194,
		1, 194, 3, 194, 2906, 8, 194, 1, 194, 1, 194, 3, 194, 2910, 8, 194, 1,
		194, 1, 194, 3, 194, 2914, 8, 194, 1, 194, 1, 194, 3, 194, 2918, 8, 194,
		1, 194, 1, 194, 3, 194, 2922, 8, 194, 1, 194, 1, 194, 3, 194, 2926, 8,
		194, 1, 194, 1, 194, 3, 194, 2930, 8, 194, 1, 194, 1, 194, 3, 194, 2934,
		8, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 196, 1, 196, 3, 196, 2942, 8,
		196, 1, 196, 1, 196, 3, 196, 2946, 8, 196, 1, 196, 1, 196, 3, 196, 2950,
		8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2956, 8, 196, 1, 196, 1,
		196, 3, 196, 2960, 8, 196, 1, 196, 1, 196, 3, 196, 2964, 8, 196, 1, 196,
		1, 196, 3, 196, 2968, 8, 196, 1, 197, 1, 197, 1, 198, 1, 198, 1, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 3, 199, 2979, 8, 199, 1, 199, 1, 199, 3, 199,
		2983, 8, 199, 1, 199, 1, 199, 3, 199, 2987, 8, 199, 1, 199, 1, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3005, 8, 199, 1, 200, 1, 200,
		1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 3014, 8, 200, 1, 201, 1,
		201, 1, 202, 1, 202, 1, 203, 1, 203, 3, 203, 3022, 8, 203, 1, 203, 1, 203,
		3, 203, 3026, 8, 203, 1, 203, 1, 203, 3, 203, 3030, 8, 203, 1, 203, 1,
		203, 3, 203, 3034, 8, 203, 5, 203, 3036, 8, 203, 10, 203, 12, 203, 3039,
		9, 203, 3, 203, 3041, 8, 203, 1, 203, 1, 203, 1, 204, 1, 204, 3, 204, 3047,
		8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3052, 8, 204, 1, 204, 1, 204, 1,
		204, 3, 204, 3057, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3062, 8, 204,
		1, 204, 1, 204, 1, 204, 3, 204, 3067, 8, 204, 1, 204, 1, 204, 1, 204, 3,
		204, 3072, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3077, 8, 204, 1, 204,
		3, 204, 3080, 8, 204, 1, 205, 1, 205, 3, 205, 3084, 8, 205, 1, 205, 1,
		205, 3, 205, 3088, 8, 205, 1, 205, 1, 205, 1, 206, 1, 206, 3, 206, 3094,
		8, 206, 1, 206, 4, 206, 3097, 8, 206, 11, 206, 12, 206, 3098, 1, 207, 1,
		207, 3, 207, 3103, 8, 207, 1, 207, 3, 207, 3106, 8, 207, 1, 208, 1, 208,
		1, 208, 1, 208, 1, 208, 1, 208, 1, 209, 1, 209, 3, 209, 3116, 8, 209, 1,
		209, 1, 209, 3, 209, 3120, 8, 209, 1, 209, 1, 209, 3, 209, 3124, 8, 209,
		3, 209, 3126, 8, 209, 1, 209, 1, 209, 3, 209, 3130, 8, 209, 1, 209, 1,
		209, 3, 209, 3134, 8, 209, 1, 209, 1, 209, 3, 209, 3138, 8, 209, 5, 209,
		3140, 8, 209, 10, 209, 12, 209, 3143, 9, 209, 3, 209, 3145, 8, 209, 1,
		209, 1, 209, 1, 210, 1, 210, 1, 210, 1, 211, 1, 211, 1, 212, 1, 212, 1,
		213, 1, 213, 3, 213, 3158, 8, 213, 1, 213, 1, 213, 3, 213, 3162, 8, 213,
		1, 213, 1, 213, 3, 213, 3166, 8, 213, 1, 213, 3, 213, 3169, 8, 213, 1,
		213, 3, 213, 3172, 8, 213, 1, 213, 1, 213, 1, 214, 1, 214, 3, 214, 3178,
		8, 214, 1, 214, 1, 214, 3, 214, 3182, 8, 214, 1, 214, 1, 214, 3, 214, 3186,
		8, 214, 3, 214, 3188, 8, 214, 1, 214, 1, 214, 3, 214, 3192, 8, 214, 1,
		214, 1, 214, 3, 214, 3196, 8, 214, 1, 214, 1, 214, 3, 214, 3200, 8, 214,
		3, 214, 3202, 8, 214, 1, 214, 1, 214, 3, 214, 3206, 8, 214, 1, 214, 1,
		214, 3, 214, 3210, 8, 214, 1, 214, 1, 214, 1, 215, 1, 215, 3, 215, 3216,
		8, 215, 1, 215, 1, 215, 1, 216, 1, 216, 3, 216, 3222, 8, 216, 1, 216, 4,
		216, 3225, 8, 216, 11, 216, 12, 216, 3226, 1, 216, 1, 216, 3, 216, 3231,
		8, 216, 1, 216, 1, 216, 3, 216, 3235, 8, 216, 1, 216, 4, 216, 3238, 8,
		216, 11, 216, 12, 216, 3239, 3, 216, 3242, 8, 216, 1, 216, 3, 216, 3245,
		8, 216, 1, 216, 1, 216, 3, 216, 3249, 8, 216, 1, 216, 3, 216, 3252, 8,
		216, 1, 216, 3, 216, 3255, 8, 216, 1, 216, 1, 216, 1, 217, 1, 217, 3, 217,
		3261, 8, 217, 1, 217, 1, 217, 3, 217, 3265, 8, 217, 1, 217, 1, 217, 3,
		217, 3269, 8, 217, 1, 217, 1, 217, 1, 218, 1, 218, 1, 219, 1, 219, 3, 219,
		3277, 8, 219, 1, 220, 1, 220, 3, 220, 3281, 8, 220, 1, 220, 1, 220, 3,
		220, 3285, 8, 220, 1, 220, 1, 220, 3, 220, 3289, 8, 220, 1, 220, 1, 220,
		3, 220, 3293, 8, 220, 5, 220, 3295, 8, 220, 10, 220, 12, 220, 3298, 9,
		220, 3, 220, 3300, 8, 220, 1, 220, 1, 220, 1, 221, 1, 221, 3, 221, 3306,
		8, 221, 1, 221, 1, 221, 3, 221, 3310, 8, 221, 1, 221, 3, 221, 3313, 8,
		221, 1, 221, 3, 221, 3316, 8, 221, 1, 221, 1, 221, 3, 221, 3320, 8, 221,
		1, 221, 5, 221, 3323, 8, 221, 10, 221, 12, 221, 3326, 9, 221, 1, 221, 3,
		221, 3329, 8, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1, 222, 3, 222,
		3337, 8, 222, 1, 223, 1, 223, 3, 223, 3341, 8, 223, 1, 223, 1, 223, 3,
		223, 3345, 8, 223, 1, 223, 1, 223, 1, 224, 1, 224, 1, 224, 1, 225, 1, 225,
		1, 226, 1, 226, 1, 226, 1, 227, 1, 227, 3, 227, 3359, 8, 227, 1, 228, 1,
		228, 3, 228, 3363, 8, 228, 1, 228, 1, 228, 3, 228, 3367, 8, 228, 1, 228,
		1, 228, 1, 229, 1, 229, 1, 229, 1, 230, 1, 230, 3, 230, 3376, 8, 230, 1,
		231, 1, 231, 3, 231, 3380, 8, 231, 1, 231, 1, 231, 3, 231, 3384, 8, 231,
		1, 231, 5, 231, 3387, 8, 231, 10, 231, 12, 231, 3390, 9, 231, 1, 232, 1,
		232, 3, 232, 3394, 8, 232, 1, 232, 4, 232, 3397, 8, 232, 11, 232, 12, 232,
		3398, 1, 233, 1, 233, 3, 233, 3403, 8, 233, 1, 233, 1, 233, 3, 233, 3407,
		8, 233, 1, 233, 5, 233, 3410, 8, 233, 10, 233, 12, 233, 3413, 9, 233, 1,
		234, 1, 234, 1, 235, 1, 235, 1, 236, 1, 236, 1, 237, 1, 237, 1, 237, 5,
		237, 3424, 8, 237, 10, 237, 12, 237, 3427, 9, 237, 1, 238, 1, 238, 1, 239,
		1, 239, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 3439, 8,
		241, 1, 242, 1, 242, 1, 242, 1, 649, 0, 243, 0, 2, 4, 6, 8, 10, 12, 14,
		16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
		52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
		88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
		120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
		150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178,
		180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208,
		210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238,
		240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268,
		270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298,
		300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328,
		330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358,
		360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388,
		390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418,
		420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448,
		450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478,
		480, 482, 484, 0, 24, 2, 0, 7, 7, 13, 13, 1, 0, 158, 159, 1, 0, 136, 137,
		1, 0, 138, 139, 2, 0, 64, 64, 171, 171, 2, 0, 66, 66, 181, 181, 1, 0, 174,
		175, 1, 0, 178, 179, 1, 0, 176, 177, 2, 0, 102, 102, 161, 161, 2, 0, 101,
		101, 162, 162, 1, 0, 163, 164, 1, 0, 152, 153, 1, 0, 94, 97, 1, 0, 102,
		103, 2, 0, 3, 3, 13, 13, 1, 0, 121, 122, 3, 0, 115, 115, 222, 222, 225,
		225, 1, 0, 210, 212, 1, 0, 220, 221, 2, 0, 30, 30, 35, 38, 2, 0, 31, 31,
		39, 42, 2, 0, 3, 3, 43, 53, 1, 0, 54, 205, 3816, 0, 486, 1, 0, 0, 0, 2,
		500, 1, 0, 0, 0, 4, 509, 1, 0, 0, 0, 6, 514, 1, 0, 0, 0, 8, 523, 1, 0,
		0, 0, 10, 541, 1, 0, 0, 0, 12, 543, 1, 0, 0, 0, 14, 553, 1, 0, 0, 0, 16,
		555, 1, 0, 0, 0, 18, 575, 1, 0, 0, 0, 20, 578, 1, 0, 0, 0, 22, 584, 1,
		0, 0, 0, 24, 592, 1, 0, 0, 0, 26, 600, 1, 0, 0, 0, 28, 602, 1, 0, 0, 0,
		30, 610, 1, 0, 0, 0, 32, 612, 1, 0, 0, 0, 34, 617, 1, 0, 0, 0, 36, 619,
		1, 0, 0, 0, 38, 622, 1, 0, 0, 0, 40, 625, 1, 0, 0, 0, 42, 633, 1, 0, 0,
		0, 44, 642, 1, 0, 0, 0, 46, 653, 1, 0, 0, 0, 48, 657, 1, 0, 0, 0, 50, 687,
		1, 0, 0, 0, 52, 689, 1, 0, 0, 0, 54, 727, 1, 0, 0, 0, 56, 735, 1, 0, 0,
		0, 58, 737, 1, 0, 0, 0, 60, 751, 1, 0, 0, 0, 62, 758, 1, 0, 0, 0, 64, 766,
		1, 0, 0, 0, 66, 775, 1, 0, 0, 0, 68, 781, 1, 0, 0, 0, 70, 783, 1, 0, 0,
		0, 72, 795, 1, 0, 0, 0, 74, 797, 1, 0, 0, 0, 76, 799, 1, 0, 0, 0, 78, 801,
		1, 0, 0, 0, 80, 818, 1, 0, 0, 0, 82, 822, 1, 0, 0, 0, 84, 824, 1, 0, 0,
		0, 86, 834, 1, 0, 0, 0, 88, 840, 1, 0, 0, 0, 90, 850, 1, 0, 0, 0, 92, 859,
		1, 0, 0, 0, 94, 881, 1, 0, 0, 0, 96, 897, 1, 0, 0, 0, 98, 909, 1, 0, 0,
		0, 100, 914, 1, 0, 0, 0, 102, 921, 1, 0, 0, 0, 104, 930, 1, 0, 0, 0, 106,
		936, 1, 0, 0, 0, 108, 964, 1, 0, 0, 0, 110, 993, 1, 0, 0, 0, 112, 995,
		1, 0, 0, 0, 114, 1003, 1, 0, 0, 0, 116, 1014, 1, 0, 0, 0, 118, 1049, 1,
		0, 0, 0, 120, 1051, 1, 0, 0, 0, 122, 1101, 1, 0, 0, 0, 124, 1130, 1, 0,
		0, 0, 126, 1177, 1, 0, 0, 0, 128, 1224, 1, 0, 0, 0, 130, 1247, 1, 0, 0,
		0, 132, 1267, 1, 0, 0, 0, 134, 1288, 1, 0, 0, 0, 136, 1309, 1, 0, 0, 0,
		138, 1311, 1, 0, 0, 0, 140, 1335, 1, 0, 0, 0, 142, 1348, 1, 0, 0, 0, 144,
		1412, 1, 0, 0, 0, 146, 1432, 1, 0, 0, 0, 148, 1455, 1, 0, 0, 0, 150, 1472,
		1, 0, 0, 0, 152, 1474, 1, 0, 0, 0, 154, 1494, 1, 0, 0, 0, 156, 1515, 1,
		0, 0, 0, 158, 1517, 1, 0, 0, 0, 160, 1526, 1, 0, 0, 0, 162, 1532, 1, 0,
		0, 0, 164, 1538, 1, 0, 0, 0, 166, 1544, 1, 0, 0, 0, 168, 1548, 1, 0, 0,
		0, 170, 1569, 1, 0, 0, 0, 172, 1571, 1, 0, 0, 0, 174, 1579, 1, 0, 0, 0,
		176, 1585, 1, 0, 0, 0, 178, 1587, 1, 0, 0, 0, 180, 1591, 1, 0, 0, 0, 182,
		1595, 1, 0, 0, 0, 184, 1599, 1, 0, 0, 0, 186, 1603, 1, 0, 0, 0, 188, 1607,
		1, 0, 0, 0, 190, 1611, 1, 0, 0, 0, 192, 1615, 1, 0, 0, 0, 194, 1619, 1,
		0, 0, 0, 196, 1623, 1, 0, 0, 0, 198, 1627, 1, 0, 0, 0, 200, 1647, 1, 0,
		0, 0, 202, 1674, 1, 0, 0, 0, 204, 1711, 1, 0, 0, 0, 206, 1734, 1, 0, 0,
		0, 208, 1807, 1, 0, 0, 0, 210, 1809, 1, 0, 0, 0, 212, 1834, 1, 0, 0, 0,
		214, 1853, 1, 0, 0, 0, 216, 1863, 1, 0, 0, 0, 218, 1885, 1, 0, 0, 0, 220,
		1887, 1, 0, 0, 0, 222, 1893, 1, 0, 0, 0, 224, 1901, 1, 0, 0, 0, 226, 1955,
		1, 0, 0, 0, 228, 1959, 1, 0, 0, 0, 230, 1979, 1, 0, 0, 0, 232, 1999, 1,
		0, 0, 0, 234, 2001, 1, 0, 0, 0, 236, 2029, 1, 0, 0, 0, 238, 2044, 1, 0,
		0, 0, 240, 2056, 1, 0, 0, 0, 242, 2069, 1, 0, 0, 0, 244, 2105, 1, 0, 0,
		0, 246, 2114, 1, 0, 0, 0, 248, 2116, 1, 0, 0, 0, 250, 2125, 1, 0, 0, 0,
		252, 2132, 1, 0, 0, 0, 254, 2135, 1, 0, 0, 0, 256, 2160, 1, 0, 0, 0, 258,
		2182, 1, 0, 0, 0, 260, 2184, 1, 0, 0, 0, 262, 2190, 1, 0, 0, 0, 264, 2192,
		1, 0, 0, 0, 266, 2194, 1, 0, 0, 0, 268, 2212, 1, 0, 0, 0, 270, 2216, 1,
		0, 0, 0, 272, 2220, 1, 0, 0, 0, 274, 2231, 1, 0, 0, 0, 276, 2281, 1, 0,
		0, 0, 278, 2300, 1, 0, 0, 0, 280, 2312, 1, 0, 0, 0, 282, 2314, 1, 0, 0,
		0, 284, 2323, 1, 0, 0, 0, 286, 2329, 1, 0, 0, 0, 288, 2340, 1, 0, 0, 0,
		290, 2349, 1, 0, 0, 0, 292, 2357, 1, 0, 0, 0, 294, 2371, 1, 0, 0, 0, 296,
		2375, 1, 0, 0, 0, 298, 2400, 1, 0, 0, 0, 300, 2404, 1, 0, 0, 0, 302, 2420,
		1, 0, 0, 0, 304, 2422, 1, 0, 0, 0, 306, 2446, 1, 0, 0, 0, 308, 2452, 1,
		0, 0, 0, 310, 2471, 1, 0, 0, 0, 312, 2480, 1, 0, 0, 0, 314, 2482, 1, 0,
		0, 0, 316, 2511, 1, 0, 0, 0, 318, 2513, 1, 0, 0, 0, 320, 2519, 1, 0, 0,
		0, 322, 2530, 1, 0, 0, 0, 324, 2534, 1, 0, 0, 0, 326, 2538, 1, 0, 0, 0,
		328, 2548, 1, 0, 0, 0, 330, 2551, 1, 0, 0, 0, 332, 2573, 1, 0, 0, 0, 334,
		2575, 1, 0, 0, 0, 336, 2577, 1, 0, 0, 0, 338, 2579, 1, 0, 0, 0, 340, 2589,
		1, 0, 0, 0, 342, 2599, 1, 0, 0, 0, 344, 2615, 1, 0, 0, 0, 346, 2620, 1,
		0, 0, 0, 348, 2630, 1, 0, 0, 0, 350, 2652, 1, 0, 0, 0, 352, 2682, 1, 0,
		0, 0, 354, 2702, 1, 0, 0, 0, 356, 2707, 1, 0, 0, 0, 358, 2764, 1, 0, 0,
		0, 360, 2777, 1, 0, 0, 0, 362, 2791, 1, 0, 0, 0, 364, 2793, 1, 0, 0, 0,
		366, 2807, 1, 0, 0, 0, 368, 2809, 1, 0, 0, 0, 370, 2823, 1, 0, 0, 0, 372,
		2825, 1, 0, 0, 0, 374, 2839, 1, 0, 0, 0, 376, 2841, 1, 0, 0, 0, 378, 2855,
		1, 0, 0, 0, 380, 2857, 1, 0, 0, 0, 382, 2871, 1, 0, 0, 0, 384, 2873, 1,
		0, 0, 0, 386, 2897, 1, 0, 0, 0, 388, 2899, 1, 0, 0, 0, 390, 2937, 1, 0,
		0, 0, 392, 2967, 1, 0, 0, 0, 394, 2969, 1, 0, 0, 0, 396, 2971, 1, 0, 0,
		0, 398, 3004, 1, 0, 0, 0, 400, 3013, 1, 0, 0, 0, 402, 3015, 1, 0, 0, 0,
		404, 3017, 1, 0, 0, 0, 406, 3019, 1, 0, 0, 0, 408, 3079, 1, 0, 0, 0, 410,
		3081, 1, 0, 0, 0, 412, 3091, 1, 0, 0, 0, 414, 3100, 1, 0, 0, 0, 416, 3107,
		1, 0, 0, 0, 418, 3113, 1, 0, 0, 0, 420, 3148, 1, 0, 0, 0, 422, 3151, 1,
		0, 0, 0, 424, 3153, 1, 0, 0, 0, 426, 3155, 1, 0, 0, 0, 428, 3175, 1, 0,
		0, 0, 430, 3213, 1, 0, 0, 0, 432, 3241, 1, 0, 0, 0, 434, 3258, 1, 0, 0,
		0, 436, 3272, 1, 0, 0, 0, 438, 3276, 1, 0, 0, 0, 440, 3278, 1, 0, 0, 0,
		442, 3303, 1, 0, 0, 0, 444, 3336, 1, 0, 0, 0, 446, 3338, 1, 0, 0, 0, 448,
		3348, 1, 0, 0, 0, 450, 3351, 1, 0, 0, 0, 452, 3353, 1, 0, 0, 0, 454, 3358,
		1, 0, 0, 0, 456, 3360, 1, 0, 0, 0, 458, 3370, 1, 0, 0, 0, 460, 3375, 1,
		0, 0, 0, 462, 3377, 1, 0, 0, 0, 464, 3391, 1, 0, 0, 0, 466, 3400, 1, 0,
		0, 0, 468, 3414, 1, 0, 0, 0, 470, 3416, 1, 0, 0, 0, 472, 3418, 1, 0, 0,
		0, 474, 3425, 1, 0, 0, 0, 476, 3428, 1, 0, 0, 0, 478, 3430, 1, 0, 0, 0,
		480, 3432, 1, 0, 0, 0, 482, 3438, 1, 0, 0, 0, 484, 3440, 1, 0, 0, 0, 486,
		491, 3, 2, 1, 0, 487, 488, 5, 1, 0, 0, 488, 490, 3, 2, 1, 0, 489, 487,
		1, 0, 0, 0, 490, 493, 1, 0, 0, 0, 491, 489, 1, 0, 0, 0, 491, 492, 1, 0,
		0, 0, 492, 495, 1, 0, 0, 0, 493, 491, 1, 0, 0, 0, 494, 496, 5, 1, 0, 0,
		495, 494, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0, 497,
		498, 5, 0, 0, 1, 498, 1, 1, 0, 0, 0, 499, 501, 5, 226, 0, 0, 500, 499,
		1, 0, 0, 0, 500, 501, 1, 0, 0, 0, 501, 504, 1, 0, 0, 0, 502, 505, 3, 64,
		32, 0, 503, 505, 3, 4, 2, 0, 504, 502, 1, 0, 0, 0, 504, 503, 1, 0, 0, 0,
		505, 507, 1, 0, 0, 0, 506, 508, 5, 226, 0, 0, 507, 506, 1, 0, 0, 0, 507,
		508, 1, 0, 0, 0, 508, 3, 1, 0, 0, 0, 509, 512, 3, 6, 3, 0, 510, 511, 5,
		226, 0, 0, 511, 513, 3, 8, 4, 0, 512, 510, 1, 0, 0, 0, 512, 513, 1, 0,
		0, 0, 513, 5, 1, 0, 0, 0, 514, 515, 5, 2, 0, 0, 515, 520, 3, 482, 241,
		0, 516, 517, 5, 3, 0, 0, 517, 519, 3, 482, 241, 0, 518, 516, 1, 0, 0, 0,
		519, 522, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521,
		7, 1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 523, 528, 3, 10, 5, 0, 524, 525, 5,
		226, 0, 0, 525, 527, 3, 10, 5, 0, 526, 524, 1, 0, 0, 0, 527, 530, 1, 0,
		0, 0, 528, 526, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 9, 1, 0, 0, 0, 530,
		528, 1, 0, 0, 0, 531, 542, 3, 14, 7, 0, 532, 542, 3, 48, 24, 0, 533, 542,
		3, 12, 6, 0, 534, 542, 3, 440, 220, 0, 535, 542, 3, 58, 29, 0, 536, 542,
		3, 402, 201, 0, 537, 542, 3, 438, 219, 0, 538, 542, 3, 404, 202, 0, 539,
		542, 3, 62, 31, 0, 540, 542, 3, 60, 30, 0, 541, 531, 1, 0, 0, 0, 541, 532,
		1, 0, 0, 0, 541, 533, 1, 0, 0, 0, 541, 534, 1, 0, 0, 0, 541, 535, 1, 0,
		0, 0, 541, 536, 1, 0, 0, 0, 541, 537, 1, 0, 0, 0, 541, 538, 1, 0, 0, 0,
		541, 539, 1, 0, 0, 0, 541, 540, 1, 0, 0, 0, 542, 11, 1, 0, 0, 0, 543, 545,
		3, 482, 241, 0, 544, 546, 5, 226, 0, 0, 545, 544, 1, 0, 0, 0, 545, 546,
		1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 549, 5, 4, 0, 0, 548, 550, 5, 226,
		0, 0, 549, 548, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0,
		551, 552, 3, 336, 168, 0, 552, 13, 1, 0, 0, 0, 553, 554, 3, 16, 8, 0, 554,
		15, 1, 0, 0, 0, 555, 556, 3, 18, 9, 0, 556, 558, 5, 5, 0, 0, 557, 559,
		3, 32, 16, 0, 558, 557, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 560, 1,
		0, 0, 0, 560, 563, 3, 20, 10, 0, 561, 562, 5, 2, 0, 0, 562, 564, 3, 26,
		13, 0, 563, 561, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 567, 1, 0, 0, 0,
		565, 566, 5, 6, 0, 0, 566, 568, 3, 28, 14, 0, 567, 565, 1, 0, 0, 0, 567,
		568, 1, 0, 0, 0, 568, 570, 1, 0, 0, 0, 569, 571, 3, 38, 19, 0, 570, 569,
		1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 573, 1, 0, 0, 0, 572, 574, 3, 36,
		18, 0, 573, 572, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 17, 1, 0, 0, 0,
		575, 576, 3, 44, 22, 0, 576, 19, 1, 0, 0, 0, 577, 579, 5, 6, 0, 0, 578,
		577, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 582, 1, 0, 0, 0, 580, 583,
		3, 22, 11, 0, 581, 583, 3, 24, 12, 0, 582, 580, 1, 0, 0, 0, 582, 581, 1,
		0, 0, 0, 583, 21, 1, 0, 0, 0, 584, 589, 3, 44, 22, 0, 585, 586, 5, 7, 0,
		0, 586, 588, 3, 44, 22, 0, 587, 585, 1, 0, 0, 0, 588, 591, 1, 0, 0, 0,
		589, 587, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 23, 1, 0, 0, 0, 591, 589,
		1, 0, 0, 0, 592, 593, 3, 46, 23, 0, 593, 594, 5, 7, 0, 0, 594, 595, 3,
		46, 23, 0, 595, 596, 5, 7, 0, 0, 596, 597, 3, 46, 23, 0, 597, 598, 5, 7,
		0, 0, 598, 599, 3, 46, 23, 0, 599, 25, 1, 0, 0, 0, 600, 601, 3, 46, 23,
		0, 601, 27, 1, 0, 0, 0, 602, 607, 3, 44, 22, 0, 603, 604, 5, 6, 0, 0, 604,
		606, 3, 44, 22, 0, 605, 603, 1, 0, 0, 0, 606, 609, 1, 0, 0, 0, 607, 605,
		1, 0, 0, 0, 607, 608, 1, 0, 0, 0, 608, 29, 1, 0, 0, 0, 609, 607, 1, 0,
		0, 0, 610, 611, 3, 44, 22, 0, 611, 31, 1, 0, 0, 0, 612, 613, 3, 30, 15,
		0, 613, 614, 5, 2, 0, 0, 614, 615, 3, 34, 17, 0, 615, 616, 5, 8, 0, 0,
		616, 33, 1, 0, 0, 0, 617, 618, 3, 44, 22, 0, 618, 35, 1, 0, 0, 0, 619,
		620, 5, 9, 0, 0, 620, 621, 3, 44, 22, 0, 621, 37, 1, 0, 0, 0, 622, 623,
		5, 10, 0, 0, 623, 624, 3, 40, 20, 0, 624, 39, 1, 0, 0, 0, 625, 630, 3,
		42, 21, 0, 626, 627, 5, 11, 0, 0, 627, 629, 3, 42, 21, 0, 628, 626, 1,
		0, 0, 0, 629, 632, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 631, 1, 0, 0,
		0, 631, 41, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 633, 640, 3, 44, 22, 0, 634,
		638, 5, 12, 0, 0, 635, 639, 3, 44, 22, 0, 636, 639, 3, 46, 23, 0, 637,
		639, 5, 208, 0, 0, 638, 635, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 638, 637,
		1, 0, 0, 0, 639, 641, 1, 0, 0, 0, 640, 634, 1, 0, 0, 0, 640, 641, 1, 0,
		0, 0, 641, 43, 1, 0, 0, 0, 642, 649, 3, 482, 241, 0, 643, 645, 7, 0, 0,
		0, 644, 643, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646,
		648, 3, 482, 241, 0, 647, 644, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649, 650,
		1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 650, 45, 1, 0, 0, 0, 651, 649, 1, 0,
		0, 0, 652, 654, 3, 470, 235, 0, 653, 652, 1, 0, 0, 0, 654, 655, 1, 0, 0,
		0, 655, 653, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0, 656, 47, 1, 0, 0, 0, 657,
		658, 3, 56, 28, 0, 658, 49, 1, 0, 0, 0, 659, 661, 5, 14, 0, 0, 660, 662,
		5, 226, 0, 0, 661, 660, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 663, 1,
		0, 0, 0, 663, 665, 3, 52, 26, 0, 664, 666, 5, 226, 0, 0, 665, 664, 1, 0,
		0, 0, 665, 666, 1, 0, 0, 0, 666, 677, 1, 0, 0, 0, 667, 669, 5, 15, 0, 0,
		668, 670, 5, 226, 0, 0, 669, 668, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670,
		671, 1, 0, 0, 0, 671, 673, 3, 52, 26, 0, 672, 674, 5, 226, 0, 0, 673, 672,
		1, 0, 0, 0, 673, 674, 1, 0, 0, 0, 674, 676, 1, 0, 0, 0, 675, 667, 1, 0,
		0, 0, 676, 679, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0,
		678, 680, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 680, 681, 5, 16, 0, 0, 681,
		688, 1, 0, 0, 0, 682, 684, 5, 14, 0, 0, 683, 685, 5, 226, 0, 0, 684, 683,
		1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 688, 5, 16,
		0, 0, 687, 659, 1, 0, 0, 0, 687, 682, 1, 0, 0, 0, 688, 51, 1, 0, 0, 0,
		689, 691, 3, 402, 201, 0, 690, 692, 5, 226, 0, 0, 691, 690, 1, 0, 0, 0,
		691, 692, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 695, 5, 2, 0, 0, 694,
		696, 5, 226, 0, 0, 695, 694, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697,
		1, 0, 0, 0, 697, 698, 3, 56, 28, 0, 698, 53, 1, 0, 0, 0, 699, 701, 5, 17,
		0, 0, 700, 702, 5, 226, 0, 0, 701, 700, 1, 0, 0, 0, 701, 702, 1, 0, 0,
		0, 702, 703, 1, 0, 0, 0, 703, 705, 3, 56, 28, 0, 704, 706, 5, 226, 0, 0,
		705, 704, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 717, 1, 0, 0, 0, 707,
		709, 5, 15, 0, 0, 708, 710, 5, 226, 0, 0, 709, 708, 1, 0, 0, 0, 709, 710,
		1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 713, 3, 56, 28, 0, 712, 714, 5,
		226, 0, 0, 713, 712, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 716, 1, 0,
		0, 0, 715, 707, 1, 0, 0, 0, 716, 719, 1, 0, 0, 0, 717, 715, 1, 0, 0, 0,
		717, 718, 1, 0, 0, 0, 718, 720, 1, 0, 0, 0, 719, 717, 1, 0, 0, 0, 720,
		721, 5, 18, 0, 0, 721, 728, 1, 0, 0, 0, 722, 724, 5, 17, 0, 0, 723, 725,
		5, 226, 0, 0, 724, 723, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 1,
		0, 0, 0, 726, 728, 5, 18, 0, 0, 727, 699, 1, 0, 0, 0, 727, 722, 1, 0, 0,
		0, 728, 55, 1, 0, 0, 0, 729, 736, 3, 402, 201, 0, 730, 736, 3, 438, 219,
		0, 731, 736, 3, 50, 25, 0, 732, 736, 3, 54, 27, 0, 733, 736, 3, 404, 202,
		0, 734, 736, 5, 114, 0, 0, 735, 729, 1, 0, 0, 0, 735, 730, 1, 0, 0, 0,
		735, 731, 1, 0, 0, 0, 735, 732, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 735,
		734, 1, 0, 0, 0, 736, 57, 1, 0, 0, 0, 737, 738, 3, 436, 218, 0, 738, 739,
		5, 2, 0, 0, 739, 744, 5, 226, 0, 0, 740, 745, 5, 207, 0, 0, 741, 745, 3,
		438, 219, 0, 742, 745, 3, 404, 202, 0, 743, 745, 3, 482, 241, 0, 744, 740,
		1, 0, 0, 0, 744, 741, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 744, 743, 1, 0,
		0, 0, 745, 59, 1, 0, 0, 0, 746, 749, 5, 6, 0, 0, 747, 750, 3, 482, 241,
		0, 748, 750, 3, 438, 219, 0, 749, 747, 1, 0, 0, 0, 749, 748, 1, 0, 0, 0,
		750, 752, 1, 0, 0, 0, 751, 746, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753,
		751, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 756, 1, 0, 0, 0, 755, 757,
		5, 6, 0, 0, 756, 755, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 61, 1, 0,
		0, 0, 758, 763, 3, 482, 241, 0, 759, 760, 5, 3, 0, 0, 760, 762, 3, 482,
		241, 0, 761, 759, 1, 0, 0, 0, 762, 765, 1, 0, 0, 0, 763, 761, 1, 0, 0,
		0, 763, 764, 1, 0, 0, 0, 764, 63, 1, 0, 0, 0, 765, 763, 1, 0, 0, 0, 766,
		767, 3, 66, 33, 0, 767, 768, 3, 80, 40, 0, 768, 65, 1, 0, 0, 0, 769, 771,
		3, 68, 34, 0, 770, 772, 5, 226, 0, 0, 771, 770, 1, 0, 0, 0, 771, 772, 1,
		0, 0, 0, 772, 774, 1, 0, 0, 0, 773, 769, 1, 0, 0, 0, 774, 777, 1, 0, 0,
		0, 775, 773, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 67, 1, 0, 0, 0, 777,
		775, 1, 0, 0, 0, 778, 782, 3, 70, 35, 0, 779, 782, 3, 74, 37, 0, 780, 782,
		3, 76, 38, 0, 781, 778, 1, 0, 0, 0, 781, 779, 1, 0, 0, 0, 781, 780, 1,
		0, 0, 0, 782, 69, 1, 0, 0, 0, 783, 786, 5, 54, 0, 0, 784, 785, 5, 226,
		0, 0, 785, 787, 3, 72, 36, 0, 786, 784, 1, 0, 0, 0, 786, 787, 1, 0, 0,
		0, 787, 792, 1, 0, 0, 0, 788, 789, 5, 226, 0, 0, 789, 791, 3, 78, 39, 0,
		790, 788, 1, 0, 0, 0, 791, 794, 1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 792,
		793, 1, 0, 0, 0, 793, 71, 1, 0, 0, 0, 794, 792, 1, 0, 0, 0, 795, 796, 5,
		221, 0, 0, 796, 73, 1, 0, 0, 0, 797, 798, 5, 55, 0, 0, 798, 75, 1, 0, 0,
		0, 799, 800, 5, 56, 0, 0, 800, 77, 1, 0, 0, 0, 801, 803, 3, 482, 241, 0,
		802, 804, 5, 226, 0, 0, 803, 802, 1, 0, 0, 0, 803, 804, 1, 0, 0, 0, 804,
		805, 1, 0, 0, 0, 805, 807, 5, 12, 0, 0, 806, 808, 5, 226, 0, 0, 807, 806,
		1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 810, 3, 482,
		241, 0, 810, 79, 1, 0, 0, 0, 811, 819, 3, 98, 49, 0, 812, 819, 3, 82, 41,
		0, 813, 814, 5, 132, 0, 0, 814, 816, 5, 226, 0, 0, 815, 813, 1, 0, 0, 0,
		815, 816, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 819, 3, 100, 50, 0, 818,
		811, 1, 0, 0, 0, 818, 812, 1, 0, 0, 0, 818, 815, 1, 0, 0, 0, 819, 81, 1,
		0, 0, 0, 820, 823, 3, 84, 42, 0, 821, 823, 3, 86, 43, 0, 822, 820, 1, 0,
		0, 0, 822, 821, 1, 0, 0, 0, 823, 83, 1, 0, 0, 0, 824, 831, 3, 88, 44, 0,
		825, 827, 5, 226, 0, 0, 826, 825, 1, 0, 0, 0, 826, 827, 1, 0, 0, 0, 827,
		828, 1, 0, 0, 0, 828, 830, 3, 94, 47, 0, 829, 826, 1, 0, 0, 0, 830, 833,
		1, 0, 0, 0, 831, 829, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 85, 1, 0,
		0, 0, 833, 831, 1, 0, 0, 0, 834, 836, 3, 90, 45, 0, 835, 837, 5, 226, 0,
		0, 836, 835, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 838, 1, 0, 0, 0, 838,
		839, 3, 92, 46, 0, 839, 87, 1, 0, 0, 0, 840, 847, 3, 96, 48, 0, 841, 843,
		5, 226, 0, 0, 842, 841, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 844, 1,
		0, 0, 0, 844, 846, 3, 96, 48, 0, 845, 842, 1, 0, 0, 0, 846, 849, 1, 0,
		0, 0, 847, 845, 1, 0, 0, 0, 847, 848, 1, 0, 0, 0, 848, 89, 1, 0, 0, 0,
		849, 847, 1, 0, 0, 0, 850, 851, 5, 57, 0, 0, 851, 852, 5, 226, 0, 0, 852,
		853, 5, 58, 0, 0, 853, 854, 5, 226, 0, 0, 854, 857, 5, 59, 0, 0, 855, 856,
		5, 226, 0, 0, 856, 858, 3, 470, 235, 0, 857, 855, 1, 0, 0, 0, 857, 858,
		1, 0, 0, 0, 858, 91, 1, 0, 0, 0, 859, 866, 3, 210, 105, 0, 860, 862, 5,
		226, 0, 0, 861, 860, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 863, 1, 0,
		0, 0, 863, 865, 3, 96, 48, 0, 864, 861, 1, 0, 0, 0, 865, 868, 1, 0, 0,
		0, 866, 864, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 93, 1, 0, 0, 0, 868,
		866, 1, 0, 0, 0, 869, 870, 5, 60, 0, 0, 870, 871, 5, 226, 0, 0, 871, 873,
		5, 61, 0, 0, 872, 874, 5, 226, 0, 0, 873, 872, 1, 0, 0, 0, 873, 874, 1,
		0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 882, 3, 88, 44, 0, 876, 878, 5, 60,
		0, 0, 877, 879, 5, 226, 0, 0, 878, 877, 1, 0, 0, 0, 878, 879, 1, 0, 0,
		0, 879, 880, 1, 0, 0, 0, 880, 882, 3, 88, 44, 0, 881, 869, 1, 0, 0, 0,
		881, 876, 1, 0, 0, 0, 882, 95, 1, 0, 0, 0, 883, 898, 3, 210, 105, 0, 884,
		898, 3, 276, 138, 0, 885, 898, 3, 212, 106, 0, 886, 898, 3, 214, 107, 0,
		887, 898, 3, 216, 108, 0, 888, 898, 3, 220, 110, 0, 889, 898, 3, 222, 111,
		0, 890, 898, 3, 224, 112, 0, 891, 898, 3, 228, 114, 0, 892, 898, 3, 230,
		115, 0, 893, 898, 3, 234, 117, 0, 894, 898, 3, 236, 118, 0, 895, 898, 3,
		238, 119, 0, 896, 898, 3, 248, 124, 0, 897, 883, 1, 0, 0, 0, 897, 884,
		1, 0, 0, 0, 897, 885, 1, 0, 0, 0, 897, 886, 1, 0, 0, 0, 897, 887, 1, 0,
		0, 0, 897, 888, 1, 0, 0, 0, 897, 889, 1, 0, 0, 0, 897, 890, 1, 0, 0, 0,
		897, 891, 1, 0, 0, 0, 897, 892, 1, 0, 0, 0, 897, 893, 1, 0, 0, 0, 897,
		894, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 897, 896, 1, 0, 0, 0, 898, 97, 1,
		0, 0, 0, 899, 910, 3, 186, 93, 0, 900, 910, 3, 196, 98, 0, 901, 910, 3,
		178, 89, 0, 902, 910, 3, 188, 94, 0, 903, 910, 3, 180, 90, 0, 904, 910,
		3, 190, 95, 0, 905, 910, 3, 182, 91, 0, 906, 910, 3, 192, 96, 0, 907, 910,
		3, 184, 92, 0, 908, 910, 3, 194, 97, 0, 909, 899, 1, 0, 0, 0, 909, 900,
		1, 0, 0, 0, 909, 901, 1, 0, 0, 0, 909, 902, 1, 0, 0, 0, 909, 903, 1, 0,
		0, 0, 909, 904, 1, 0, 0, 0, 909, 905, 1, 0, 0, 0, 909, 906, 1, 0, 0, 0,
		909, 907, 1, 0, 0, 0, 909, 908, 1, 0, 0, 0, 910, 99, 1, 0, 0, 0, 911, 915,
		3, 102, 51, 0, 912, 915, 3, 104, 52, 0, 913, 915, 3, 106, 53, 0, 914, 911,
		1, 0, 0, 0, 914, 912, 1, 0, 0, 0, 914, 913, 1, 0, 0, 0, 915, 101, 1, 0,
		0, 0, 916, 922, 3, 154, 77, 0, 917, 922, 3, 156, 78, 0, 918, 922, 3, 158,
		79, 0, 919, 922, 3, 160, 80, 0, 920, 922, 3, 162, 81, 0, 921, 916, 1, 0,
		0, 0, 921, 917, 1, 0, 0, 0, 921, 918, 1, 0, 0, 0, 921, 919, 1, 0, 0, 0,
		921, 920, 1, 0, 0, 0, 922, 103, 1, 0, 0, 0, 923, 931, 3, 108, 54, 0, 924,
		931, 3, 110, 55, 0, 925, 931, 3, 114, 57, 0, 926, 931, 3, 116, 58, 0, 927,
		931, 3, 118, 59, 0, 928, 931, 3, 120, 60, 0, 929, 931, 3, 122, 61, 0, 930,
		923, 1, 0, 0, 0, 930, 924, 1, 0, 0, 0, 930, 925, 1, 0, 0, 0, 930, 926,
		1, 0, 0, 0, 930, 927, 1, 0, 0, 0, 930, 928, 1, 0, 0, 0, 930, 929, 1, 0,
		0, 0, 931, 105, 1, 0, 0, 0, 932, 937, 3, 124, 62, 0, 933, 937, 3, 126,
		63, 0, 934, 937, 3, 128, 64, 0, 935, 937, 3, 130, 65, 0, 936, 932, 1, 0,
		0, 0, 936, 933, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 936, 935, 1, 0, 0, 0,
		937, 107, 1, 0, 0, 0, 938, 939, 5, 133, 0, 0, 939, 942, 5, 226, 0, 0, 940,
		941, 5, 61, 0, 0, 941, 943, 5, 226, 0, 0, 942, 940, 1, 0, 0, 0, 942, 943,
		1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 949, 5, 144, 0, 0, 945, 946, 5,
		226, 0, 0, 946, 947, 5, 73, 0, 0, 947, 948, 5, 226, 0, 0, 948, 950, 5,
		146, 0, 0, 949, 945, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 965, 1, 0,
		0, 0, 951, 952, 5, 133, 0, 0, 952, 955, 5, 226, 0, 0, 953, 954, 5, 147,
		0, 0, 954, 956, 5, 226, 0, 0, 955, 953, 1, 0, 0, 0, 955, 956, 1, 0, 0,
		0, 956, 957, 1, 0, 0, 0, 957, 962, 5, 144, 0, 0, 958, 959, 5, 226, 0, 0,
		959, 960, 5, 73, 0, 0, 960, 961, 5, 226, 0, 0, 961, 963, 5, 146, 0, 0,
		962, 958, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965, 1, 0, 0, 0, 964,
		938, 1, 0, 0, 0, 964, 951, 1, 0, 0, 0, 965, 109, 1, 0, 0, 0, 966, 967,
		5, 62, 0, 0, 967, 968, 5, 226, 0, 0, 968, 969, 5, 143, 0, 0, 969, 970,
		5, 226, 0, 0, 970, 973, 3, 482, 241, 0, 971, 972, 5, 226, 0, 0, 972, 974,
		3, 164, 82, 0, 973, 971, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 977, 1,
		0, 0, 0, 975, 976, 5, 226, 0, 0, 976, 978, 3, 112, 56, 0, 977, 975, 1,
		0, 0, 0, 977, 978, 1, 0, 0, 0, 978, 994, 1, 0, 0, 0, 979, 980, 5, 62, 0,
		0, 980, 984, 5, 226, 0, 0, 981, 982, 3, 168, 84, 0, 982, 983, 5, 226, 0,
		0, 983, 985, 1, 0, 0, 0, 984, 981, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985,
		986, 1, 0, 0, 0, 986, 987, 5, 143, 0, 0, 987, 988, 5, 226, 0, 0, 988, 991,
		3, 482, 241, 0, 989, 990, 5, 226, 0, 0, 990, 992, 3, 112, 56, 0, 991, 989,
		1, 0, 0, 0, 991, 992, 1, 0, 0, 0, 992, 994, 1, 0, 0, 0, 993, 966, 1, 0,
		0, 0, 993, 979, 1, 0, 0, 0, 994, 111, 1, 0, 0, 0, 995, 996, 5, 76, 0, 0,
		996, 997, 5, 226, 0, 0, 997, 998, 5, 165, 0, 0, 998, 999, 5, 226, 0, 0,
		999, 1000, 5, 166, 0, 0, 1000, 1001, 5, 226, 0, 0, 1001, 1002, 3, 482,
		241, 0, 1002, 113, 1, 0, 0, 0, 1003, 1004, 5, 63, 0, 0, 1004, 1005, 5,
		226, 0, 0, 1005, 1006, 5, 143, 0, 0, 1006, 1007, 5, 226, 0, 0, 1007, 1012,
		3, 482, 241, 0, 1008, 1009, 5, 226, 0, 0, 1009, 1010, 5, 141, 0, 0, 1010,
		1011, 5, 226, 0, 0, 1011, 1013, 5, 70, 0, 0, 1012, 1008, 1, 0, 0, 0, 1012,
		1013, 1, 0, 0, 0, 1013, 115, 1, 0, 0, 0, 1014, 1015, 5, 133, 0, 0, 1015,
		1016, 5, 226, 0, 0, 1016, 1017, 5, 146, 0, 0, 1017, 117, 1, 0, 0, 0, 1018,
		1019, 5, 62, 0, 0, 1019, 1020, 5, 226, 0, 0, 1020, 1021, 5, 145, 0, 0,
		1021, 1022, 5, 226, 0, 0, 1022, 1023, 3, 30, 15, 0, 1023, 1026, 5, 226,
		0, 0, 1024, 1025, 5, 226, 0, 0, 1025, 1027, 3, 164, 82, 0, 1026, 1024,
		1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1031,
		3, 170, 85, 0, 1029, 1030, 5, 226, 0, 0, 1030, 1032, 3, 174, 87, 0, 1031,
		1029, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032, 1050, 1, 0, 0, 0, 1033,
		1034, 5, 62, 0, 0, 1034, 1038, 5, 226, 0, 0, 1035, 1036, 3, 168, 84, 0,
		1036, 1037, 5, 226, 0, 0, 1037, 1039, 1, 0, 0, 0, 1038, 1035, 1, 0, 0,
		0, 1038, 1039, 1, 0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 1041, 5, 145,
		0, 0, 1041, 1042, 5, 226, 0, 0, 1042, 1043, 3, 30, 15, 0, 1043, 1044, 5,
		226, 0, 0, 1044, 1047, 3, 170, 85, 0, 1045, 1046, 5, 226, 0, 0, 1046, 1048,
		3, 174, 87, 0, 1047, 1045, 1, 0, 0, 0, 1047, 1048, 1, 0, 0, 0, 1048, 1050,
		1, 0, 0, 0, 1049, 1018, 1, 0, 0, 0, 1049, 1033, 1, 0, 0, 0, 1050, 119,
		1, 0, 0, 0, 1051, 1052, 5, 63, 0, 0, 1052, 1053, 5, 226, 0, 0, 1053, 1054,
		5, 145, 0, 0, 1054, 1055, 5, 226, 0, 0, 1055, 1058, 3, 30, 15, 0, 1056,
		1057, 5, 226, 0, 0, 1057, 1059, 3, 166, 83, 0, 1058, 1056, 1, 0, 0, 0,
		1058, 1059, 1, 0, 0, 0, 1059, 121, 1, 0, 0, 0, 1060, 1061, 5, 154, 0, 0,
		1061, 1062, 5, 226, 0, 0, 1062, 1063, 5, 155, 0, 0, 1063, 1064, 5, 226,
		0, 0, 1064, 1065, 5, 145, 0, 0, 1065, 1066, 5, 226, 0, 0, 1066, 1067, 5,
		82, 0, 0, 1067, 1068, 5, 226, 0, 0, 1068, 1069, 5, 148, 0, 0, 1069, 1070,
		5, 226, 0, 0, 1070, 1071, 5, 75, 0, 0, 1071, 1074, 5, 226, 0, 0, 1072,
		1075, 3, 34, 17, 0, 1073, 1075, 3, 454, 227, 0, 1074, 1072, 1, 0, 0, 0,
		1074, 1073, 1, 0, 0, 0, 1075, 1076, 1, 0, 0, 0, 1076, 1077, 5, 156, 0,
		0, 1077, 1080, 5, 226, 0, 0, 1078, 1081, 3, 34, 17, 0, 1079, 1081, 3, 454,
		227, 0, 1080, 1078, 1, 0, 0, 0, 1080, 1079, 1, 0, 0, 0, 1081, 1102, 1,
		0, 0, 0, 1082, 1083, 5, 154, 0, 0, 1083, 1084, 5, 226, 0, 0, 1084, 1085,
		5, 145, 0, 0, 1085, 1086, 5, 226, 0, 0, 1086, 1087, 3, 30, 15, 0, 1087,
		1088, 5, 226, 0, 0, 1088, 1091, 3, 170, 85, 0, 1089, 1090, 5, 226, 0, 0,
		1090, 1092, 3, 174, 87, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1092, 1, 0, 0,
		0, 1092, 1102, 1, 0, 0, 0, 1093, 1094, 5, 154, 0, 0, 1094, 1095, 5, 226,
		0, 0, 1095, 1096, 5, 145, 0, 0, 1096, 1097, 5, 226, 0, 0, 1097, 1098, 3,
		30, 15, 0, 1098, 1099, 5, 226, 0, 0, 1099, 1100, 3, 174, 87, 0, 1100, 1102,
		1, 0, 0, 0, 1101, 1060, 1, 0, 0, 0, 1101, 1082, 1, 0, 0, 0, 1101, 1093,
		1, 0, 0, 0, 1102, 123, 1, 0, 0, 0, 1103, 1104, 5, 133, 0, 0, 1104, 1107,
		5, 226, 0, 0, 1105, 1106, 5, 61, 0, 0, 1106, 1108, 5, 226, 0, 0, 1107,
		1105, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109,
		1131, 5, 157, 0, 0, 1110, 1111, 5, 133, 0, 0, 1111, 1117, 5, 226, 0, 0,
		1112, 1113, 5, 143, 0, 0, 1113, 1114, 5, 226, 0, 0, 1114, 1115, 3, 482,
		241, 0, 1115, 1116, 5, 226, 0, 0, 1116, 1118, 1, 0, 0, 0, 1117, 1112, 1,
		0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1131, 5,
		157, 0, 0, 1120, 1121, 5, 133, 0, 0, 1121, 1127, 5, 226, 0, 0, 1122, 1123,
		5, 145, 0, 0, 1123, 1124, 5, 226, 0, 0, 1124, 1125, 3, 30, 15, 0, 1125,
		1126, 5, 226, 0, 0, 1126, 1128, 1, 0, 0, 0, 1127, 1122, 1, 0, 0, 0, 1127,
		1128, 1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1131, 5, 157, 0, 0, 1130,
		1103, 1, 0, 0, 0, 1130, 1110, 1, 0, 0, 0, 1130, 1120, 1, 0, 0, 0, 1131,
		125, 1, 0, 0, 0, 1132, 1133, 5, 158, 0, 0, 1133, 1134, 5, 226, 0, 0, 1134,
		1135, 5, 143, 0, 0, 1135, 1136, 5, 226, 0, 0, 1136, 1137, 3, 138, 69, 0,
		1137, 1138, 5, 226, 0, 0, 1138, 1139, 5, 156, 0, 0, 1139, 1140, 5, 226,
		0, 0, 1140, 1141, 3, 30, 15, 0, 1141, 1178, 1, 0, 0, 0, 1142, 1143, 5,
		158, 0, 0, 1143, 1144, 5, 226, 0, 0, 1144, 1145, 3, 144, 72, 0, 1145, 1146,
		5, 226, 0, 0, 1146, 1147, 5, 65, 0, 0, 1147, 1148, 5, 226, 0, 0, 1148,
		1149, 3, 134, 67, 0, 1149, 1150, 5, 226, 0, 0, 1150, 1151, 5, 156, 0, 0,
		1151, 1152, 3, 138, 69, 0, 1152, 1178, 1, 0, 0, 0, 1153, 1154, 5, 158,
		0, 0, 1154, 1155, 5, 226, 0, 0, 1155, 1156, 3, 140, 70, 0, 1156, 1157,
		5, 226, 0, 0, 1157, 1158, 5, 65, 0, 0, 1158, 1159, 5, 226, 0, 0, 1159,
		1160, 3, 136, 68, 0, 1160, 1161, 5, 226, 0, 0, 1161, 1162, 3, 148, 74,
		0, 1162, 1163, 5, 226, 0, 0, 1163, 1164, 5, 156, 0, 0, 1164, 1165, 3, 138,
		69, 0, 1165, 1178, 1, 0, 0, 0, 1166, 1167, 5, 158, 0, 0, 1167, 1168, 5,
		226, 0, 0, 1168, 1169, 3, 146, 73, 0, 1169, 1170, 5, 226, 0, 0, 1170, 1171,
		5, 65, 0, 0, 1171, 1172, 5, 226, 0, 0, 1172, 1173, 5, 135, 0, 0, 1173,
		1174, 5, 226, 0, 0, 1174, 1175, 5, 156, 0, 0, 1175, 1176, 3, 138, 69, 0,
		1176, 1178, 1, 0, 0, 0, 1177, 1132, 1, 0, 0, 0, 1177, 1142, 1, 0, 0, 0,
		1177, 1153, 1, 0, 0, 0, 1177, 1166, 1, 0, 0, 0, 1178, 127, 1, 0, 0, 0,
		1179, 1180, 5, 159, 0, 0, 1180, 1181, 5, 226, 0, 0, 1181, 1182, 5, 143,
		0, 0, 1182, 1183, 5, 226, 0, 0, 1183, 1184, 3, 138, 69, 0, 1184, 1185,
		5, 226, 0, 0, 1185, 1186, 5, 156, 0, 0, 1186, 1187, 5, 226, 0, 0, 1187,
		1188, 3, 30, 15, 0, 1188, 1225, 1, 0, 0, 0, 1189, 1190, 5, 159, 0, 0, 1190,
		1191, 5, 226, 0, 0, 1191, 1192, 3, 144, 72, 0, 1192, 1193, 5, 226, 0, 0,
		1193, 1194, 5, 65, 0, 0, 1194, 1195, 5, 226, 0, 0, 1195, 1196, 3, 134,
		67, 0, 1196, 1197, 5, 226, 0, 0, 1197, 1198, 5, 156, 0, 0, 1198, 1199,
		3, 138, 69, 0, 1199, 1225, 1, 0, 0, 0, 1200, 1201, 5, 159, 0, 0, 1201,
		1202, 5, 226, 0, 0, 1202, 1203, 3, 140, 70, 0, 1203, 1204, 5, 226, 0, 0,
		1204, 1205, 5, 65, 0, 0, 1205, 1206, 5, 226, 0, 0, 1206, 1207, 3, 136,
		68, 0, 1207, 1208, 5, 226, 0, 0, 1208, 1209, 3, 148, 74, 0, 1209, 1210,
		5, 226, 0, 0, 1210, 1211, 5, 156, 0, 0, 1211, 1212, 3, 138, 69, 0, 1212,
		1225, 1, 0, 0, 0, 1213, 1214, 5, 159, 0, 0, 1214, 1215, 5, 226, 0, 0, 1215,
		1216, 3, 146, 73, 0, 1216, 1217, 5, 226, 0, 0, 1217, 1218, 5, 65, 0, 0,
		1218, 1219, 5, 226, 0, 0, 1219, 1220, 5, 135, 0, 0, 1220, 1221, 5, 226,
		0, 0, 1221, 1222, 5, 156, 0, 0, 1222, 1223, 3, 138, 69, 0, 1223, 1225,
		1, 0, 0, 0, 1224, 1179, 1, 0, 0, 0, 1224, 1189, 1, 0, 0, 0, 1224, 1200,
		1, 0, 0, 0, 1224, 1213, 1, 0, 0, 0, 1225, 129, 1, 0, 0, 0, 1226, 1227,
		5, 160, 0, 0, 1227, 1228, 5, 226, 0, 0, 1228, 1229, 5, 143, 0, 0, 1229,
		1230, 5, 226, 0, 0, 1230, 1231, 3, 138, 69, 0, 1231, 1232, 5, 226, 0, 0,
		1232, 1233, 5, 75, 0, 0, 1233, 1234, 5, 226, 0, 0, 1234, 1235, 3, 30, 15,
		0, 1235, 1248, 1, 0, 0, 0, 1236, 1239, 5, 160, 0, 0, 1237, 1238, 5, 226,
		0, 0, 1238, 1240, 7, 1, 0, 0, 1239, 1237, 1, 0, 0, 0, 1239, 1240, 1, 0,
		0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 1242, 3, 132, 66, 0, 1242, 1243, 5,
		226, 0, 0, 1243, 1244, 5, 75, 0, 0, 1244, 1245, 5, 226, 0, 0, 1245, 1246,
		3, 138, 69, 0, 1246, 1248, 1, 0, 0, 0, 1247, 1226, 1, 0, 0, 0, 1247, 1236,
		1, 0, 0, 0, 1248, 131, 1, 0, 0, 0, 1249, 1250, 3, 144, 72, 0, 1250, 1251,
		5, 226, 0, 0, 1251, 1252, 5, 65, 0, 0, 1252, 1253, 5, 226, 0, 0, 1253,
		1254, 3, 134, 67, 0, 1254, 1268, 1, 0, 0, 0, 1255, 1256, 3, 142, 71, 0,
		1256, 1257, 5, 226, 0, 0, 1257, 1258, 5, 65, 0, 0, 1258, 1259, 5, 226,
		0, 0, 1259, 1260, 3, 136, 68, 0, 1260, 1268, 1, 0, 0, 0, 1261, 1262, 3,
		146, 73, 0, 1262, 1263, 5, 226, 0, 0, 1263, 1264, 5, 65, 0, 0, 1264, 1265,
		5, 226, 0, 0, 1265, 1266, 5, 135, 0, 0, 1266, 1268, 1, 0, 0, 0, 1267, 1249,
		1, 0, 0, 0, 1267, 1255, 1, 0, 0, 0, 1267, 1261, 1, 0, 0, 0, 1268, 133,
		1, 0, 0, 0, 1269, 1270, 7, 2, 0, 0, 1270, 1271, 5, 226, 0, 0, 1271, 1289,
		5, 19, 0, 0, 1272, 1273, 7, 2, 0, 0, 1273, 1274, 5, 226, 0, 0, 1274, 1285,
		3, 482, 241, 0, 1275, 1277, 5, 226, 0, 0, 1276, 1275, 1, 0, 0, 0, 1276,
		1277, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 1278, 1280, 5, 15, 0, 0, 1279,
		1281, 5, 226, 0, 0, 1280, 1279, 1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281,
		1282, 1, 0, 0, 0, 1282, 1284, 3, 482, 241, 0, 1283, 1276, 1, 0, 0, 0, 1284,
		1287, 1, 0, 0, 0, 1285, 1283, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286,
		1289, 1, 0, 0, 0, 1287, 1285, 1, 0, 0, 0, 1288, 1269, 1, 0, 0, 0, 1288,
		1272, 1, 0, 0, 0, 1289, 135, 1, 0, 0, 0, 1290, 1291, 7, 3, 0, 0, 1291,
		1292, 5, 226, 0, 0, 1292, 1310, 5, 19, 0, 0, 1293, 1294, 7, 3, 0, 0, 1294,
		1295, 5, 226, 0, 0, 1295, 1306, 3, 482, 241, 0, 1296, 1298, 5, 226, 0,
		0, 1297, 1296, 1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298, 1299, 1, 0, 0,
		0, 1299, 1301, 5, 15, 0, 0, 1300, 1302, 5, 226, 0, 0, 1301, 1300, 1, 0,
		0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303, 1305, 3, 482,
		241, 0, 1304, 1297, 1, 0, 0, 0, 1305, 1308, 1, 0, 0, 0, 1306, 1304, 1,
		0, 0, 0, 1306, 1307, 1, 0, 0, 0, 1307, 1310, 1, 0, 0, 0, 1308, 1306, 1,
		0, 0, 0, 1309, 1290, 1, 0, 0, 0, 1309, 1293, 1, 0, 0, 0, 1310, 137, 1,
		0, 0, 0, 1311, 1322, 3, 482, 241, 0, 1312, 1314, 5, 226, 0, 0, 1313, 1312,
		1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315, 1317,
		5, 15, 0, 0, 1316, 1318, 5, 226, 0, 0, 1317, 1316, 1, 0, 0, 0, 1317, 1318,
		1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1321, 3, 482, 241, 0, 1320, 1313,
		1, 0, 0, 0, 1321, 1324, 1, 0, 0, 0, 1322, 1320, 1, 0, 0, 0, 1322, 1323,
		1, 0, 0, 0, 1323, 139, 1, 0, 0, 0, 1324, 1322, 1, 0, 0, 0, 1325, 1336,
		3, 142, 71, 0, 1326, 1327, 5, 79, 0, 0, 1327, 1328, 5, 226, 0, 0, 1328,
		1330, 5, 14, 0, 0, 1329, 1331, 5, 226, 0, 0, 1330, 1329, 1, 0, 0, 0, 1330,
		1331, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1333, 3, 150, 75, 0, 1333,
		1334, 5, 16, 0, 0, 1334, 1336, 1, 0, 0, 0, 1335, 1325, 1, 0, 0, 0, 1335,
		1326, 1, 0, 0, 0, 1336, 141, 1, 0, 0, 0, 1337, 1349, 5, 167, 0, 0, 1338,
		1339, 5, 168, 0, 0, 1339, 1340, 5, 226, 0, 0, 1340, 1342, 5, 14, 0, 0,
		1341, 1343, 5, 226, 0, 0, 1342, 1341, 1, 0, 0, 0, 1342, 1343, 1, 0, 0,
		0, 1343, 1344, 1, 0, 0, 0, 1344, 1345, 3, 150, 75, 0, 1345, 1346, 5, 16,
		0, 0, 1346, 1349, 1, 0, 0, 0, 1347, 1349, 5, 169, 0, 0, 1348, 1337, 1,
		0, 0, 0, 1348, 1338, 1, 0, 0, 0, 1348, 1347, 1, 0, 0, 0, 1349, 143, 1,
		0, 0, 0, 1350, 1413, 5, 170, 0, 0, 1351, 1413, 5, 100, 0, 0, 1352, 1413,
		5, 142, 0, 0, 1353, 1354, 5, 62, 0, 0, 1354, 1355, 5, 226, 0, 0, 1355,
		1413, 7, 4, 0, 0, 1356, 1357, 5, 63, 0, 0, 1357, 1358, 5, 226, 0, 0, 1358,
		1413, 7, 4, 0, 0, 1359, 1360, 7, 4, 0, 0, 1360, 1361, 5, 226, 0, 0, 1361,
		1413, 5, 172, 0, 0, 1362, 1363, 5, 62, 0, 0, 1363, 1364, 5, 226, 0, 0,
		1364, 1413, 7, 5, 0, 0, 1365, 1366, 5, 63, 0, 0, 1366, 1367, 5, 226, 0,
		0, 1367, 1413, 7, 5, 0, 0, 1368, 1369, 7, 5, 0, 0, 1369, 1370, 5, 226,
		0, 0, 1370, 1413, 5, 172, 0, 0, 1371, 1372, 5, 62, 0, 0, 1372, 1373, 5,
		226, 0, 0, 1373, 1374, 5, 173, 0, 0, 1374, 1377, 5, 226, 0, 0, 1375, 1376,
		5, 101, 0, 0, 1376, 1378, 5, 226, 0, 0, 1377, 1375, 1, 0, 0, 0, 1377, 1378,
		1, 0, 0, 0, 1378, 1379, 1, 0, 0, 0, 1379, 1413, 7, 6, 0, 0, 1380, 1381,
		5, 62, 0, 0, 1381, 1382, 5, 226, 0, 0, 1382, 1383, 5, 173, 0, 0, 1383,
		1386, 5, 226, 0, 0, 1384, 1385, 5, 102, 0, 0, 1385, 1387, 5, 226, 0, 0,
		1386, 1384, 1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0,
		1388, 1413, 7, 7, 0, 0, 1389, 1390, 5, 62, 0, 0, 1390, 1391, 5, 226, 0,
		0, 1391, 1392, 5, 173, 0, 0, 1392, 1395, 5, 226, 0, 0, 1393, 1394, 5, 180,
		0, 0, 1394, 1396, 5, 226, 0, 0, 1395, 1393, 1, 0, 0, 0, 1395, 1396, 1,
		0, 0, 0, 1396, 1397, 1, 0, 0, 0, 1397, 1413, 7, 8, 0, 0, 1398, 1401, 5,
		176, 0, 0, 1399, 1400, 5, 226, 0, 0, 1400, 1402, 5, 172, 0, 0, 1401, 1399,
		1, 0, 0, 0, 1401, 1402, 1, 0, 0, 0, 1402, 1413, 1, 0, 0, 0, 1403, 1410,
		5, 61, 0, 0, 1404, 1407, 5, 226, 0, 0, 1405, 1406, 5, 136, 0, 0, 1406,
		1408, 5, 226, 0, 0, 1407, 1405, 1, 0, 0, 0, 1407, 1408, 1, 0, 0, 0, 1408,
		1409, 1, 0, 0, 0, 1409, 1411, 5, 157, 0, 0, 1410, 1404, 1, 0, 0, 0, 1410,
		1411, 1, 0, 0, 0, 1411, 1413, 1, 0, 0, 0, 1412, 1350, 1, 0, 0, 0, 1412,
		1351, 1, 0, 0, 0, 1412, 1352, 1, 0, 0, 0, 1412, 1353, 1, 0, 0, 0, 1412,
		1356, 1, 0, 0, 0, 1412, 1359, 1, 0, 0, 0, 1412, 1362, 1, 0, 0, 0, 1412,
		1365, 1, 0, 0, 0, 1412, 1368, 1, 0, 0, 0, 1412, 1371, 1, 0, 0, 0, 1412,
		1380, 1, 0, 0, 0, 1412, 1389, 1, 0, 0, 0, 1412, 1398, 1, 0, 0, 0, 1412,
		1403, 1, 0, 0, 0, 1413, 145, 1, 0, 0, 0, 1414, 1415, 5, 143, 0, 0, 1415,
		1416, 5, 226, 0, 0, 1416, 1433, 5, 172, 0, 0, 1417, 1418, 5, 62, 0, 0,
		1418, 1419, 5, 226, 0, 0, 1419, 1433, 5, 143, 0, 0, 1420, 1421, 5, 63,
		0, 0, 1421, 1422, 5, 226, 0, 0, 1422, 1433, 5, 143, 0, 0, 1423, 1424, 5,
		182, 0, 0, 1424, 1425, 5, 226, 0, 0, 1425, 1433, 5, 143, 0, 0, 1426, 1427,
		5, 85, 0, 0, 1427, 1428, 5, 226, 0, 0, 1428, 1433, 5, 143, 0, 0, 1429,
		1430, 5, 133, 0, 0, 1430, 1431, 5, 226, 0, 0, 1431, 1433, 5, 143, 0, 0,
		1432, 1414, 1, 0, 0, 0, 1432, 1417, 1, 0, 0, 0, 1432, 1420, 1, 0, 0, 0,
		1432, 1423, 1, 0, 0, 0, 1432, 1426, 1, 0, 0, 0, 1432, 1429, 1, 0, 0, 0,
		1433, 147, 1, 0, 0, 0, 1434, 1435, 7, 9, 0, 0, 1435, 1436, 5, 226, 0, 0,
		1436, 1439, 3, 150, 75, 0, 1437, 1438, 5, 226, 0, 0, 1438, 1440, 3, 152,
		76, 0, 1439, 1437, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1456, 1, 0,
		0, 0, 1441, 1442, 7, 10, 0, 0, 1442, 1443, 5, 226, 0, 0, 1443, 1446, 3,
		150, 75, 0, 1444, 1445, 5, 226, 0, 0, 1445, 1447, 3, 152, 76, 0, 1446,
		1444, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 1456, 1, 0, 0, 0, 1448,
		1449, 7, 11, 0, 0, 1449, 1450, 5, 226, 0, 0, 1450, 1453, 3, 150, 75, 0,
		1451, 1452, 5, 226, 0, 0, 1452, 1454, 3, 152, 76, 0, 1453, 1451, 1, 0,
		0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 1456, 1, 0, 0, 0, 1455, 1434, 1, 0,
		0, 0, 1455, 1441, 1, 0, 0, 0, 1455, 1448, 1, 0, 0, 0, 1456, 149, 1, 0,
		0, 0, 1457, 1473, 5, 19, 0, 0, 1458, 1469, 3, 482, 241, 0, 1459, 1461,
		5, 226, 0, 0, 1460, 1459, 1, 0, 0, 0, 1460, 1461, 1, 0, 0, 0, 1461, 1462,
		1, 0, 0, 0, 1462, 1464, 5, 15, 0, 0, 1463, 1465, 5, 226, 0, 0, 1464, 1463,
		1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465, 1466, 1, 0, 0, 0, 1466, 1468,
		3, 482, 241, 0, 1467, 1460, 1, 0, 0, 0, 1468, 1471, 1, 0, 0, 0, 1469, 1467,
		1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 1473, 1, 0, 0, 0, 1471, 1469,
		1, 0, 0, 0, 1472, 1457, 1, 0, 0, 0, 1472, 1458, 1, 0, 0, 0, 1473, 151,
		1, 0, 0, 0, 1474, 1476, 5, 20, 0, 0, 1475, 1477, 5, 226, 0, 0, 1476, 1475,
		1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1480,
		5, 19, 0, 0, 1479, 1481, 5, 226, 0, 0, 1480, 1479, 1, 0, 0, 0, 1480, 1481,
		1, 0, 0, 0, 1481, 1482, 1, 0, 0, 0, 1482, 1483, 5, 21, 0, 0, 1483, 153,
		1, 0, 0, 0, 1484, 1485, 5, 133, 0, 0, 1485, 1488, 5, 226, 0, 0, 1486, 1487,
		5, 134, 0, 0, 1487, 1489, 5, 226, 0, 0, 1488, 1486, 1, 0, 0, 0, 1488, 1489,
		1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1495, 5, 136, 0, 0, 1491, 1492,
		5, 133, 0, 0, 1492, 1493, 5, 226, 0, 0, 1493, 1495, 5, 137, 0, 0, 1494,
		1484, 1, 0, 0, 0, 1494, 1491, 1, 0, 0, 0, 1495, 155, 1, 0, 0, 0, 1496,
		1497, 5, 62, 0, 0, 1497, 1498, 5, 226, 0, 0, 1498, 1499, 5, 136, 0, 0,
		1499, 1500, 5, 226, 0, 0, 1500, 1503, 3, 482, 241, 0, 1501, 1502, 5, 226,
		0, 0, 1502, 1504, 3, 164, 82, 0, 1503, 1501, 1, 0, 0, 0, 1503, 1504, 1,
		0, 0, 0, 1504, 1516, 1, 0, 0, 0, 1505, 1506, 5, 62, 0, 0, 1506, 1510, 5,
		226, 0, 0, 1507, 1508, 3, 168, 84, 0, 1508, 1509, 5, 226, 0, 0, 1509, 1511,
		1, 0, 0, 0, 1510, 1507, 1, 0, 0, 0, 1510, 1511, 1, 0, 0, 0, 1511, 1512,
		1, 0, 0, 0, 1512, 1513, 5, 136, 0, 0, 1513, 1514, 5, 226, 0, 0, 1514, 1516,
		3, 482, 241, 0, 1515, 1496, 1, 0, 0, 0, 1515, 1505, 1, 0, 0, 0, 1516, 157,
		1, 0, 0, 0, 1517, 1518, 5, 63, 0, 0, 1518, 1519, 5, 226, 0, 0, 1519, 1520,
		5, 136, 0, 0, 1520, 1521, 5, 226, 0, 0, 1521, 1524, 3, 482, 241, 0, 1522,
		1523, 5, 226, 0, 0, 1523, 1525, 3, 166, 83, 0, 1524, 1522, 1, 0, 0, 0,
		1524, 1525, 1, 0, 0, 0, 1525, 159, 1, 0, 0, 0, 1526, 1527, 5, 100, 0, 0,
		1527, 1528, 5, 226, 0, 0, 1528, 1529, 5, 136, 0, 0, 1529, 1530, 5, 226,
		0, 0, 1530, 1531, 3, 482, 241, 0, 1531, 161, 1, 0, 0, 0, 1532, 1533, 5,
		142, 0, 0, 1533, 1534, 5, 226, 0, 0, 1534, 1535, 5, 136, 0, 0, 1535, 1536,
		5, 226, 0, 0, 1536, 1537, 3, 482, 241, 0, 1537, 163, 1, 0, 0, 0, 1538,
		1539, 5, 141, 0, 0, 1539, 1540, 5, 226, 0, 0, 1540, 1541, 5, 110, 0, 0,
		1541, 1542, 5, 226, 0, 0, 1542, 1543, 5, 70, 0, 0, 1543, 165, 1, 0, 0,
		0, 1544, 1545, 5, 141, 0, 0, 1545, 1546, 5, 226, 0, 0, 1546, 1547, 5, 70,
		0, 0, 1547, 167, 1, 0, 0, 0, 1548, 1549, 5, 107, 0, 0, 1549, 1550, 5, 226,
		0, 0, 1550, 1551, 5, 140, 0, 0, 1551, 169, 1, 0, 0, 0, 1552, 1553, 5, 82,
		0, 0, 1553, 1554, 5, 226, 0, 0, 1554, 1555, 5, 148, 0, 0, 1555, 1558, 5,
		226, 0, 0, 1556, 1559, 3, 34, 17, 0, 1557, 1559, 3, 454, 227, 0, 1558,
		1556, 1, 0, 0, 0, 1558, 1557, 1, 0, 0, 0, 1559, 1562, 1, 0, 0, 0, 1560,
		1561, 5, 226, 0, 0, 1561, 1563, 3, 172, 86, 0, 1562, 1560, 1, 0, 0, 0,
		1562, 1563, 1, 0, 0, 0, 1563, 1570, 1, 0, 0, 0, 1564, 1565, 5, 82, 0, 0,
		1565, 1566, 5, 226, 0, 0, 1566, 1567, 5, 148, 0, 0, 1567, 1568, 5, 226,
		0, 0, 1568, 1570, 3, 172, 86, 0, 1569, 1552, 1, 0, 0, 0, 1569, 1564, 1,
		0, 0, 0, 1570, 171, 1, 0, 0, 0, 1571, 1572, 5, 149, 0, 0, 1572, 1575, 5,
		226, 0, 0, 1573, 1574, 5, 110, 0, 0, 1574, 1576, 5, 226, 0, 0, 1575, 1573,
		1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 1577, 1, 0, 0, 0, 1577, 1578,
		5, 150, 0, 0, 1578, 173, 1, 0, 0, 0, 1579, 1580, 5, 82, 0, 0, 1580, 1581,
		5, 226, 0, 0, 1581, 1582, 5, 151, 0, 0, 1582, 1583, 5, 226, 0, 0, 1583,
		1584, 3, 176, 88, 0, 1584, 175, 1, 0, 0, 0, 1585, 1586, 7, 12, 0, 0, 1586,
		177, 1, 0, 0, 0, 1587, 1588, 5, 62, 0, 0, 1588, 1589, 5, 226, 0, 0, 1589,
		1590, 3, 200, 100, 0, 1590, 179, 1, 0, 0, 0, 1591, 1592, 5, 62, 0, 0, 1592,
		1593, 5, 226, 0, 0, 1593, 1594, 3, 202, 101, 0, 1594, 181, 1, 0, 0, 0,
		1595, 1596, 5, 62, 0, 0, 1596, 1597, 5, 226, 0, 0, 1597, 1598, 3, 204,
		102, 0, 1598, 183, 1, 0, 0, 0, 1599, 1600, 5, 62, 0, 0, 1600, 1601, 5,
		226, 0, 0, 1601, 1602, 3, 206, 103, 0, 1602, 185, 1, 0, 0, 0, 1603, 1604,
		5, 62, 0, 0, 1604, 1605, 5, 226, 0, 0, 1605, 1606, 3, 198, 99, 0, 1606,
		187, 1, 0, 0, 0, 1607, 1608, 5, 63, 0, 0, 1608, 1609, 5, 226, 0, 0, 1609,
		1610, 3, 200, 100, 0, 1610, 189, 1, 0, 0, 0, 1611, 1612, 5, 63, 0, 0, 1612,
		1613, 5, 226, 0, 0, 1613, 1614, 3, 202, 101, 0, 1614, 191, 1, 0, 0, 0,
		1615, 1616, 5, 63, 0, 0, 1616, 1617, 5, 226, 0, 0, 1617, 1618, 3, 204,
		102, 0, 1618, 193, 1, 0, 0, 0, 1619, 1620, 5, 63, 0, 0, 1620, 1621, 5,
		226, 0, 0, 1621, 1622, 3, 206, 103, 0, 1622, 195, 1, 0, 0, 0, 1623, 1624,
		5, 63, 0, 0, 1624, 1625, 5, 226, 0, 0, 1625, 1626, 3, 198, 99, 0, 1626,
		197, 1, 0, 0, 0, 1627, 1628, 5, 64, 0, 0, 1628, 1629, 5, 226, 0, 0, 1629,
		1631, 5, 65, 0, 0, 1630, 1632, 5, 226, 0, 0, 1631, 1630, 1, 0, 0, 0, 1631,
		1632, 1, 0, 0, 0, 1632, 1633, 1, 0, 0, 0, 1633, 1635, 3, 328, 164, 0, 1634,
		1636, 5, 226, 0, 0, 1635, 1634, 1, 0, 0, 0, 1635, 1636, 1, 0, 0, 0, 1636,
		1637, 1, 0, 0, 0, 1637, 1639, 5, 20, 0, 0, 1638, 1640, 5, 226, 0, 0, 1639,
		1638, 1, 0, 0, 0, 1639, 1640, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641,
		1643, 3, 466, 233, 0, 1642, 1644, 5, 226, 0, 0, 1643, 1642, 1, 0, 0, 0,
		1643, 1644, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1646, 5, 21, 0, 0,
		1646, 199, 1, 0, 0, 0, 1647, 1648, 5, 66, 0, 0, 1648, 1649, 5, 226, 0,
		0, 1649, 1651, 5, 65, 0, 0, 1650, 1652, 5, 226, 0, 0, 1651, 1650, 1, 0,
		0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1655, 5, 20,
		0, 0, 1654, 1656, 5, 226, 0, 0, 1655, 1654, 1, 0, 0, 0, 1655, 1656, 1,
		0, 0, 0, 1656, 1657, 1, 0, 0, 0, 1657, 1658, 3, 436, 218, 0, 1658, 1660,
		3, 328, 164, 0, 1659, 1661, 5, 226, 0, 0, 1660, 1659, 1, 0, 0, 0, 1660,
		1661, 1, 0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662, 1664, 5, 21, 0, 0, 1663,
		1665, 5, 226, 0, 0, 1664, 1663, 1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665,
		1666, 1, 0, 0, 0, 1666, 1667, 5, 67, 0, 0, 1667, 1668, 5, 226, 0, 0, 1668,
		1669, 3, 464, 232, 0, 1669, 1670, 5, 226, 0, 0, 1670, 1671, 5, 68, 0, 0,
		1671, 1672, 5, 226, 0, 0, 1672, 1673, 5, 69, 0, 0, 1673, 201, 1, 0, 0,
		0, 1674, 1675, 5, 66, 0, 0, 1675, 1676, 5, 226, 0, 0, 1676, 1678, 5, 65,
		0, 0, 1677, 1679, 5, 226, 0, 0, 1678, 1677, 1, 0, 0, 0, 1678, 1679, 1,
		0, 0, 0, 1679, 1680, 1, 0, 0, 0, 1680, 1682, 5, 20, 0, 0, 1681, 1683, 5,
		226, 0, 0, 1682, 1681, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1684,
		1, 0, 0, 0, 1684, 1685, 3, 436, 218, 0, 1685, 1687, 3, 328, 164, 0, 1686,
		1688, 5, 226, 0, 0, 1687, 1686, 1, 0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688,
		1689, 1, 0, 0, 0, 1689, 1691, 5, 21, 0, 0, 1690, 1692, 5, 226, 0, 0, 1691,
		1690, 1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693,
		1694, 5, 67, 0, 0, 1694, 1695, 5, 226, 0, 0, 1695, 1697, 5, 20, 0, 0, 1696,
		1698, 5, 226, 0, 0, 1697, 1696, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698,
		1699, 1, 0, 0, 0, 1699, 1701, 3, 462, 231, 0, 1700, 1702, 5, 226, 0, 0,
		1701, 1700, 1, 0, 0, 0, 1701, 1702, 1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0,
		1703, 1704, 5, 21, 0, 0, 1704, 1705, 5, 226, 0, 0, 1705, 1706, 5, 68, 0,
		0, 1706, 1707, 5, 226, 0, 0, 1707, 1708, 5, 101, 0, 0, 1708, 1709, 5, 226,
		0, 0, 1709, 1710, 5, 131, 0, 0, 1710, 203, 1, 0, 0, 0, 1711, 1712, 5, 66,
		0, 0, 1712, 1713, 5, 226, 0, 0, 1713, 1715, 5, 65, 0, 0, 1714, 1716, 5,
		226, 0, 0, 1715, 1714, 1, 0, 0, 0, 1715, 1716, 1, 0, 0, 0, 1716, 1717,
		1, 0, 0, 0, 1717, 1718, 5, 20, 0, 0, 1718, 1719, 3, 436, 218, 0, 1719,
		1720, 3, 328, 164, 0, 1720, 1722, 5, 21, 0, 0, 1721, 1723, 5, 226, 0, 0,
		1722, 1721, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 1724, 1, 0, 0, 0,
		1724, 1725, 5, 67, 0, 0, 1725, 1726, 5, 226, 0, 0, 1726, 1728, 5, 70, 0,
		0, 1727, 1729, 5, 226, 0, 0, 1728, 1727, 1, 0, 0, 0, 1728, 1729, 1, 0,
		0, 0, 1729, 1730, 1, 0, 0, 0, 1730, 1731, 5, 20, 0, 0, 1731, 1732, 3, 464,
		232, 0, 1732, 1733, 5, 21, 0, 0, 1733, 205, 1, 0, 0, 0, 1734, 1735, 5,
		66, 0, 0, 1735, 1736, 5, 226, 0, 0, 1736, 1738, 5, 65, 0, 0, 1737, 1739,
		5, 226, 0, 0, 1738, 1737, 1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1740,
		1, 0, 0, 0, 1740, 1742, 3, 208, 104, 0, 1741, 1743, 5, 226, 0, 0, 1742,
		1741, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744,
		1745, 5, 67, 0, 0, 1745, 1746, 5, 226, 0, 0, 1746, 1748, 5, 70, 0, 0, 1747,
		1749, 5, 226, 0, 0, 1748, 1747, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749,
		1750, 1, 0, 0, 0, 1750, 1751, 5, 20, 0, 0, 1751, 1752, 3, 464, 232, 0,
		1752, 1753, 5, 21, 0, 0, 1753, 207, 1, 0, 0, 0, 1754, 1756, 5, 20, 0, 0,
		1755, 1757, 5, 226, 0, 0, 1756, 1755, 1, 0, 0, 0, 1756, 1757, 1, 0, 0,
		0, 1757, 1758, 1, 0, 0, 0, 1758, 1759, 5, 21, 0, 0, 1759, 1760, 3, 480,
		240, 0, 1760, 1761, 5, 17, 0, 0, 1761, 1762, 3, 436, 218, 0, 1762, 1763,
		3, 318, 159, 0, 1763, 1764, 5, 18, 0, 0, 1764, 1765, 3, 480, 240, 0, 1765,
		1767, 5, 20, 0, 0, 1766, 1768, 5, 226, 0, 0, 1767, 1766, 1, 0, 0, 0, 1767,
		1768, 1, 0, 0, 0, 1768, 1769, 1, 0, 0, 0, 1769, 1770, 5, 21, 0, 0, 1770,
		1808, 1, 0, 0, 0, 1771, 1773, 5, 20, 0, 0, 1772, 1774, 5, 226, 0, 0, 1773,
		1772, 1, 0, 0, 0, 1773, 1774, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775,
		1776, 5, 21, 0, 0, 1776, 1777, 3, 480, 240, 0, 1777, 1778, 5, 17, 0, 0,
		1778, 1779, 3, 436, 218, 0, 1779, 1780, 3, 318, 159, 0, 1780, 1781, 5,
		18, 0, 0, 1781, 1782, 3, 480, 240, 0, 1782, 1783, 3, 478, 239, 0, 1783,
		1785, 5, 20, 0, 0, 1784, 1786, 5, 226, 0, 0, 1785, 1784, 1, 0, 0, 0, 1785,
		1786, 1, 0, 0, 0, 1786, 1787, 1, 0, 0, 0, 1787, 1788, 5, 21, 0, 0, 1788,
		1808, 1, 0, 0, 0, 1789, 1791, 5, 20, 0, 0, 1790, 1792, 5, 226, 0, 0, 1791,
		1790, 1, 0, 0, 0, 1791, 1792, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793,
		1794, 5, 21, 0, 0, 1794, 1795, 3, 476, 238, 0, 1795, 1796, 3, 480, 240,
		0, 1796, 1797, 5, 17, 0, 0, 1797, 1798, 3, 436, 218, 0, 1798, 1799, 3,
		318, 159, 0, 1799, 1800, 5, 18, 0, 0, 1800, 1801, 3, 480, 240, 0, 1801,
		1803, 5, 20, 0, 0, 1802, 1804, 5, 226, 0, 0, 1803, 1802, 1, 0, 0, 0, 1803,
		1804, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1806, 5, 21, 0, 0, 1806,
		1808, 1, 0, 0, 0, 1807, 1754, 1, 0, 0, 0, 1807, 1771, 1, 0, 0, 0, 1807,
		1789, 1, 0, 0, 0, 1808, 209, 1, 0, 0, 0, 1809, 1810, 5, 71, 0, 0, 1810,
		1811, 5, 226, 0, 0, 1811, 1812, 5, 72, 0, 0, 1812, 1817, 5, 226, 0, 0,
		1813, 1814, 5, 73, 0, 0, 1814, 1815, 5, 226, 0, 0, 1815, 1816, 5, 74, 0,
		0, 1816, 1818, 5, 226, 0, 0, 1817, 1813, 1, 0, 0, 0, 1817, 1818, 1, 0,
		0, 0, 1818, 1819, 1, 0, 0, 0, 1819, 1820, 5, 75, 0, 0, 1820, 1821, 5, 226,
		0, 0, 1821, 1822, 3, 336, 168, 0, 1822, 1823, 5, 226, 0, 0, 1823, 1824,
		5, 76, 0, 0, 1824, 1825, 5, 226, 0, 0, 1825, 1826, 3, 436, 218, 0, 1826,
		1830, 5, 226, 0, 0, 1827, 1828, 5, 77, 0, 0, 1828, 1829, 5, 226, 0, 0,
		1829, 1831, 5, 207, 0, 0, 1830, 1827, 1, 0, 0, 0, 1830, 1831, 1, 0, 0,
		0, 1831, 211, 1, 0, 0, 0, 1832, 1833, 5, 78, 0, 0, 1833, 1835, 5, 226,
		0, 0, 1834, 1832, 1, 0, 0, 0, 1834, 1835, 1, 0, 0, 0, 1835, 1836, 1, 0,
		0, 0, 1836, 1838, 5, 79, 0, 0, 1837, 1839, 5, 226, 0, 0, 1838, 1837, 1,
		0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839, 1840, 1, 0, 0, 0, 1840, 1844, 3,
		296, 148, 0, 1841, 1843, 3, 274, 137, 0, 1842, 1841, 1, 0, 0, 0, 1843,
		1846, 1, 0, 0, 0, 1844, 1842, 1, 0, 0, 0, 1844, 1845, 1, 0, 0, 0, 1845,
		1851, 1, 0, 0, 0, 1846, 1844, 1, 0, 0, 0, 1847, 1849, 5, 226, 0, 0, 1848,
		1847, 1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850,
		1852, 3, 294, 147, 0, 1851, 1848, 1, 0, 0, 0, 1851, 1852, 1, 0, 0, 0, 1852,
		213, 1, 0, 0, 0, 1853, 1855, 5, 80, 0, 0, 1854, 1856, 5, 226, 0, 0, 1855,
		1854, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 1857, 1, 0, 0, 0, 1857,
		1858, 3, 336, 168, 0, 1858, 1859, 5, 226, 0, 0, 1859, 1860, 5, 76, 0, 0,
		1860, 1861, 5, 226, 0, 0, 1861, 1862, 3, 436, 218, 0, 1862, 215, 1, 0,
		0, 0, 1863, 1865, 5, 81, 0, 0, 1864, 1866, 5, 226, 0, 0, 1865, 1864, 1,
		0, 0, 0, 1865, 1866, 1, 0, 0, 0, 1866, 1867, 1, 0, 0, 0, 1867, 1872, 3,
		298, 149, 0, 1868, 1869, 5, 226, 0, 0, 1869, 1871, 3, 218, 109, 0, 1870,
		1868, 1, 0, 0, 0, 1871, 1874, 1, 0, 0, 0, 1872, 1870, 1, 0, 0, 0, 1872,
		1873, 1, 0, 0, 0, 1873, 217, 1, 0, 0, 0, 1874, 1872, 1, 0, 0, 0, 1875,
		1876, 5, 65, 0, 0, 1876, 1877, 5, 226, 0, 0, 1877, 1878, 5, 79, 0, 0, 1878,
		1879, 5, 226, 0, 0, 1879, 1886, 3, 224, 112, 0, 1880, 1881, 5, 65, 0, 0,
		1881, 1882, 5, 226, 0, 0, 1882, 1883, 5, 62, 0, 0, 1883, 1884, 5, 226,
		0, 0, 1884, 1886, 3, 224, 112, 0, 1885, 1875, 1, 0, 0, 0, 1885, 1880, 1,
		0, 0, 0, 1886, 219, 1, 0, 0, 0, 1887, 1889, 5, 62, 0, 0, 1888, 1890, 5,
		226, 0, 0, 1889, 1888, 1, 0, 0, 0, 1889, 1890, 1, 0, 0, 0, 1890, 1891,
		1, 0, 0, 0, 1891, 1892, 3, 296, 148, 0, 1892, 221, 1, 0, 0, 0, 1893, 1894,
		5, 62, 0, 0, 1894, 1895, 5, 226, 0, 0, 1895, 1897, 5, 69, 0, 0, 1896, 1898,
		5, 226, 0, 0, 1897, 1896, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 1899,
		1, 0, 0, 0, 1899, 1900, 3, 296, 148, 0, 1900, 223, 1, 0, 0, 0, 1901, 1903,
		5, 82, 0, 0, 1902, 1904, 5, 226, 0, 0, 1903, 1902, 1, 0, 0, 0, 1903, 1904,
		1, 0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1916, 3, 226, 113, 0, 1906, 1908,
		5, 226, 0, 0, 1907, 1906, 1, 0, 0, 0, 1907, 1908, 1, 0, 0, 0, 1908, 1909,
		1, 0, 0, 0, 1909, 1911, 5, 15, 0, 0, 1910, 1912, 5, 226, 0, 0, 1911, 1910,
		1, 0, 0, 0, 1911, 1912, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1915,
		3, 226, 113, 0, 1914, 1907, 1, 0, 0, 0, 1915, 1918, 1, 0, 0, 0, 1916, 1914,
		1, 0, 0, 0, 1916, 1917, 1, 0, 0, 0, 1917, 225, 1, 0, 0, 0, 1918, 1916,
		1, 0, 0, 0, 1919, 1921, 3, 464, 232, 0, 1920, 1922, 5, 226, 0, 0, 1921,
		1920, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923,
		1925, 5, 12, 0, 0, 1924, 1926, 5, 226, 0, 0, 1925, 1924, 1, 0, 0, 0, 1925,
		1926, 1, 0, 0, 0, 1926, 1927, 1, 0, 0, 0, 1927, 1928, 3, 336, 168, 0, 1928,
		1956, 1, 0, 0, 0, 1929, 1931, 3, 436, 218, 0, 1930, 1932, 5, 226, 0, 0,
		1931, 1930, 1, 0, 0, 0, 1931, 1932, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0,
		1933, 1935, 5, 12, 0, 0, 1934, 1936, 5, 226, 0, 0, 1935, 1934, 1, 0, 0,
		0, 1935, 1936, 1, 0, 0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1938, 3, 336,
		168, 0, 1938, 1956, 1, 0, 0, 0, 1939, 1941, 3, 436, 218, 0, 1940, 1942,
		5, 226, 0, 0, 1941, 1940, 1, 0, 0, 0, 1941, 1942, 1, 0, 0, 0, 1942, 1943,
		1, 0, 0, 0, 1943, 1945, 5, 22, 0, 0, 1944, 1946, 5, 226, 0, 0, 1945, 1944,
		1, 0, 0, 0, 1945, 1946, 1, 0, 0, 0, 1946, 1947, 1, 0, 0, 0, 1947, 1948,
		3, 336, 168, 0, 1948, 1956, 1, 0, 0, 0, 1949, 1951, 3, 436, 218, 0, 1950,
		1952, 5, 226, 0, 0, 1951, 1950, 1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952,
		1953, 1, 0, 0, 0, 1953, 1954, 3, 326, 163, 0, 1954, 1956, 1, 0, 0, 0, 1955,
		1919, 1, 0, 0, 0, 1955, 1929, 1, 0, 0, 0, 1955, 1939, 1, 0, 0, 0, 1955,
		1949, 1, 0, 0, 0, 1956, 227, 1, 0, 0, 0, 1957, 1958, 5, 83, 0, 0, 1958,
		1960, 5, 226, 0, 0, 1959, 1957, 1, 0, 0, 0, 1959, 1960, 1, 0, 0, 0, 1960,
		1961, 1, 0, 0, 0, 1961, 1963, 5, 84, 0, 0, 1962, 1964, 5, 226, 0, 0, 1963,
		1962, 1, 0, 0, 0, 1963, 1964, 1, 0, 0, 0, 1964, 1965, 1, 0, 0, 0, 1965,
		1976, 3, 336, 168, 0, 1966, 1968, 5, 226, 0, 0, 1967, 1966, 1, 0, 0, 0,
		1967, 1968, 1, 0, 0, 0, 1968, 1969, 1, 0, 0, 0, 1969, 1971, 5, 15, 0, 0,
		1970, 1972, 5, 226, 0, 0, 1971, 1970, 1, 0, 0, 0, 1971, 1972, 1, 0, 0,
		0, 1972, 1973, 1, 0, 0, 0, 1973, 1975, 3, 336, 168, 0, 1974, 1967, 1, 0,
		0, 0, 1975, 1978, 1, 0, 0, 0, 1976, 1974, 1, 0, 0, 0, 1976, 1977, 1, 0,
		0, 0, 1977, 229, 1, 0, 0, 0, 1978, 1976, 1, 0, 0, 0, 1979, 1980, 5, 85,
		0, 0, 1980, 1981, 5, 226, 0, 0, 1981, 1992, 3, 232, 116, 0, 1982, 1984,
		5, 226, 0, 0, 1983, 1982, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 1985,
		1, 0, 0, 0, 1985, 1987, 5, 15, 0, 0, 1986, 1988, 5, 226, 0, 0, 1987, 1986,
		1, 0, 0, 0, 1987, 1988, 1, 0, 0, 0, 1988, 1989, 1, 0, 0, 0, 1989, 1991,
		3, 232, 116, 0, 1990, 1983, 1, 0, 0, 0, 1991, 1994, 1, 0, 0, 0, 1992, 1990,
		1, 0, 0, 0, 1992, 1993, 1, 0, 0, 0, 1993, 231, 1, 0, 0, 0, 1994, 1992,
		1, 0, 0, 0, 1995, 1996, 3, 436, 218, 0, 1996, 1997, 3, 326, 163, 0, 1997,
		2000, 1, 0, 0, 0, 1998, 2000, 3, 464, 232, 0, 1999, 1995, 1, 0, 0, 0, 1999,
		1998, 1, 0, 0, 0, 2000, 233, 1, 0, 0, 0, 2001, 2003, 5, 86, 0, 0, 2002,
		2004, 5, 226, 0, 0, 2003, 2002, 1, 0, 0, 0, 2003, 2004, 1, 0, 0, 0, 2004,
		2005, 1, 0, 0, 0, 2005, 2007, 5, 20, 0, 0, 2006, 2008, 5, 226, 0, 0, 2007,
		2006, 1, 0, 0, 0, 2007, 2008, 1, 0, 0, 0, 2008, 2009, 1, 0, 0, 0, 2009,
		2010, 3, 436, 218, 0, 2010, 2011, 5, 226, 0, 0, 2011, 2012, 5, 87, 0, 0,
		2012, 2013, 5, 226, 0, 0, 2013, 2015, 3, 336, 168, 0, 2014, 2016, 5, 226,
		0, 0, 2015, 2014, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2017, 1, 0,
		0, 0, 2017, 2020, 5, 23, 0, 0, 2018, 2019, 5, 226, 0, 0, 2019, 2021, 3,
		96, 48, 0, 2020, 2018, 1, 0, 0, 0, 2021, 2022, 1, 0, 0, 0, 2022, 2020,
		1, 0, 0, 0, 2022, 2023, 1, 0, 0, 0, 2023, 2025, 1, 0, 0, 0, 2024, 2026,
		5, 226, 0, 0, 2025, 2024, 1, 0, 0, 0, 2025, 2026, 1, 0, 0, 0, 2026, 2027,
		1, 0, 0, 0, 2027, 2028, 5, 21, 0, 0, 2028, 235, 1, 0, 0, 0, 2029, 2034,
		5, 73, 0, 0, 2030, 2032, 5, 226, 0, 0, 2031, 2030, 1, 0, 0, 0, 2031, 2032,
		1, 0, 0, 0, 2032, 2033, 1, 0, 0, 0, 2033, 2035, 5, 88, 0, 0, 2034, 2031,
		1, 0, 0, 0, 2034, 2035, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2037,
		5, 226, 0, 0, 2037, 2042, 3, 240, 120, 0, 2038, 2040, 5, 226, 0, 0, 2039,
		2038, 1, 0, 0, 0, 2039, 2040, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041,
		2043, 3, 294, 147, 0, 2042, 2039, 1, 0, 0, 0, 2042, 2043, 1, 0, 0, 0, 2043,
		237, 1, 0, 0, 0, 2044, 2049, 5, 89, 0, 0, 2045, 2047, 5, 226, 0, 0, 2046,
		2045, 1, 0, 0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 2048, 1, 0, 0, 0, 2048,
		2050, 5, 88, 0, 0, 2049, 2046, 1, 0, 0, 0, 2049, 2050, 1, 0, 0, 0, 2050,
		2052, 1, 0, 0, 0, 2051, 2053, 5, 226, 0, 0, 2052, 2051, 1, 0, 0, 0, 2052,
		2053, 1, 0, 0, 0, 2053, 2054, 1, 0, 0, 0, 2054, 2055, 3, 240, 120, 0, 2055,
		239, 1, 0, 0, 0, 2056, 2059, 3, 244, 122, 0, 2057, 2058, 5, 226, 0, 0,
		2058, 2060, 3, 266, 133, 0, 2059, 2057, 1, 0, 0, 0, 2059, 2060, 1, 0, 0,
		0, 2060, 2063, 1, 0, 0, 0, 2061, 2062, 5, 226, 0, 0, 2062, 2064, 3, 268,
		134, 0, 2063, 2061, 1, 0, 0, 0, 2063, 2064, 1, 0, 0, 0, 2064, 2067, 1,
		0, 0, 0, 2065, 2066, 5, 226, 0, 0, 2066, 2068, 3, 270, 135, 0, 2067, 2065,
		1, 0, 0, 0, 2067, 2068, 1, 0, 0, 0, 2068, 241, 1, 0, 0, 0, 2069, 2071,
		3, 250, 125, 0, 2070, 2072, 5, 226, 0, 0, 2071, 2070, 1, 0, 0, 0, 2071,
		2072, 1, 0, 0, 0, 2072, 2074, 1, 0, 0, 0, 2073, 2075, 3, 256, 128, 0, 2074,
		2073, 1, 0, 0, 0, 2074, 2075, 1, 0, 0, 0, 2075, 243, 1, 0, 0, 0, 2076,
		2087, 5, 19, 0, 0, 2077, 2079, 5, 226, 0, 0, 2078, 2077, 1, 0, 0, 0, 2078,
		2079, 1, 0, 0, 0, 2079, 2080, 1, 0, 0, 0, 2080, 2082, 5, 15, 0, 0, 2081,
		2083, 5, 226, 0, 0, 2082, 2081, 1, 0, 0, 0, 2082, 2083, 1, 0, 0, 0, 2083,
		2084, 1, 0, 0, 0, 2084, 2086, 3, 246, 123, 0, 2085, 2078, 1, 0, 0, 0, 2086,
		2089, 1, 0, 0, 0, 2087, 2085, 1, 0, 0, 0, 2087, 2088, 1, 0, 0, 0, 2088,
		2106, 1, 0, 0, 0, 2089, 2087, 1, 0, 0, 0, 2090, 2101, 3, 246, 123, 0, 2091,
		2093, 5, 226, 0, 0, 2092, 2091, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093,
		2094, 1, 0, 0, 0, 2094, 2096, 5, 15, 0, 0, 2095, 2097, 5, 226, 0, 0, 2096,
		2095, 1, 0, 0, 0, 2096, 2097, 1, 0, 0, 0, 2097, 2098, 1, 0, 0, 0, 2098,
		2100, 3, 246, 123, 0, 2099, 2092, 1, 0, 0, 0, 2100, 2103, 1, 0, 0, 0, 2101,
		2099, 1, 0, 0, 0, 2101, 2102, 1, 0, 0, 0, 2102, 2106, 1, 0, 0, 0, 2103,
		2101, 1, 0, 0, 0, 2104, 2106, 3, 242, 121, 0, 2105, 2076, 1, 0, 0, 0, 2105,
		2090, 1, 0, 0, 0, 2105, 2104, 1, 0, 0, 0, 2106, 245, 1, 0, 0, 0, 2107,
		2108, 3, 336, 168, 0, 2108, 2109, 5, 226, 0, 0, 2109, 2110, 5, 76, 0, 0,
		2110, 2111, 5, 226, 0, 0, 2111, 2112, 3, 436, 218, 0, 2112, 2115, 1, 0,
		0, 0, 2113, 2115, 3, 336, 168, 0, 2114, 2107, 1, 0, 0, 0, 2114, 2113, 1,
		0, 0, 0, 2115, 247, 1, 0, 0, 0, 2116, 2117, 5, 129, 0, 0, 2117, 2118, 5,
		226, 0, 0, 2118, 2120, 3, 250, 125, 0, 2119, 2121, 5, 226, 0, 0, 2120,
		2119, 1, 0, 0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2123, 1, 0, 0, 0, 2122,
		2124, 3, 256, 128, 0, 2123, 2122, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124,
		249, 1, 0, 0, 0, 2125, 2127, 3, 252, 126, 0, 2126, 2128, 5, 226, 0, 0,
		2127, 2126, 1, 0, 0, 0, 2127, 2128, 1, 0, 0, 0, 2128, 2130, 1, 0, 0, 0,
		2129, 2131, 3, 254, 127, 0, 2130, 2129, 1, 0, 0, 0, 2130, 2131, 1, 0, 0,
		0, 2131, 251, 1, 0, 0, 0, 2132, 2133, 3, 474, 237, 0, 2133, 2134, 3, 424,
		212, 0, 2134, 253, 1, 0, 0, 0, 2135, 2137, 5, 20, 0, 0, 2136, 2138, 5,
		226, 0, 0, 2137, 2136, 1, 0, 0, 0, 2137, 2138, 1, 0, 0, 0, 2138, 2140,
		1, 0, 0, 0, 2139, 2141, 3, 336, 168, 0, 2140, 2139, 1, 0, 0, 0, 2140, 2141,
		1, 0, 0, 0, 2141, 2152, 1, 0, 0, 0, 2142, 2144, 5, 226, 0, 0, 2143, 2142,
		1, 0, 0, 0, 2143, 2144, 1, 0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 2147,
		5, 15, 0, 0, 2146, 2148, 5, 226, 0, 0, 2147, 2146, 1, 0, 0, 0, 2147, 2148,
		1, 0, 0, 0, 2148, 2149, 1, 0, 0, 0, 2149, 2151, 3, 336, 168, 0, 2150, 2143,
		1, 0, 0, 0, 2151, 2154, 1, 0, 0, 0, 2152, 2150, 1, 0, 0, 0, 2152, 2153,
		1, 0, 0, 0, 2153, 2156, 1, 0, 0, 0, 2154, 2152, 1, 0, 0, 0, 2155, 2157,
		5, 226, 0, 0, 2156, 2155, 1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2158,
		1, 0, 0, 0, 2158, 2159, 5, 21, 0, 0, 2159, 255, 1, 0, 0, 0, 2160, 2161,
		5, 130, 0, 0, 2161, 2162, 5, 226, 0, 0, 2162, 2173, 3, 258, 129, 0, 2163,
		2165, 5, 226, 0, 0, 2164, 2163, 1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165,
		2166, 1, 0, 0, 0, 2166, 2168, 5, 15, 0, 0, 2167, 2169, 5, 226, 0, 0, 2168,
		2167, 1, 0, 0, 0, 2168, 2169, 1, 0, 0, 0, 2169, 2170, 1, 0, 0, 0, 2170,
		2172, 3, 258, 129, 0, 2171, 2164, 1, 0, 0, 0, 2172, 2175, 1, 0, 0, 0, 2173,
		2171, 1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 2174, 2178, 1, 0, 0, 0, 2175,
		2173, 1, 0, 0, 0, 2176, 2177, 5, 226, 0, 0, 2177, 2179, 3, 294, 147, 0,
		2178, 2176, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0, 2179, 257, 1, 0, 0, 0,
		2180, 2183, 3, 260, 130, 0, 2181, 2183, 3, 262, 131, 0, 2182, 2180, 1,
		0, 0, 0, 2182, 2181, 1, 0, 0, 0, 2183, 259, 1, 0, 0, 0, 2184, 2185, 3,
		264, 132, 0, 2185, 2186, 5, 226, 0, 0, 2186, 2187, 5, 76, 0, 0, 2187, 2188,
		5, 226, 0, 0, 2188, 2189, 3, 436, 218, 0, 2189, 261, 1, 0, 0, 0, 2190,
		2191, 3, 264, 132, 0, 2191, 263, 1, 0, 0, 0, 2192, 2193, 3, 482, 241, 0,
		2193, 265, 1, 0, 0, 0, 2194, 2195, 5, 90, 0, 0, 2195, 2196, 5, 226, 0,
		0, 2196, 2197, 5, 91, 0, 0, 2197, 2198, 5, 226, 0, 0, 2198, 2209, 3, 272,
		136, 0, 2199, 2201, 5, 226, 0, 0, 2200, 2199, 1, 0, 0, 0, 2200, 2201, 1,
		0, 0, 0, 2201, 2202, 1, 0, 0, 0, 2202, 2204, 5, 15, 0, 0, 2203, 2205, 5,
		226, 0, 0, 2204, 2203, 1, 0, 0, 0, 2204, 2205, 1, 0, 0, 0, 2205, 2206,
		1, 0, 0, 0, 2206, 2208, 3, 272, 136, 0, 2207, 2200, 1, 0, 0, 0, 2208, 2211,
		1, 0, 0, 0, 2209, 2207, 1, 0, 0, 0, 2209, 2210, 1, 0, 0, 0, 2210, 267,
		1, 0, 0, 0, 2211, 2209, 1, 0, 0, 0, 2212, 2213, 5, 92, 0, 0, 2213, 2214,
		5, 226, 0, 0, 2214, 2215, 3, 336, 168, 0, 2215, 269, 1, 0, 0, 0, 2216,
		2217, 5, 93, 0, 0, 2217, 2218, 5, 226, 0, 0, 2218, 2219, 3, 336, 168, 0,
		2219, 271, 1, 0, 0, 0, 2220, 2228, 3, 336, 168, 0, 2221, 2223, 5, 226,
		0, 0, 2222, 2221, 1, 0, 0, 0, 2222, 2223, 1, 0, 0, 0, 2223, 2224, 1, 0,
		0, 0, 2224, 2226, 7, 13, 0, 0, 2225, 2227, 5, 226, 0, 0, 2226, 2225, 1,
		0, 0, 0, 2226, 2227, 1, 0, 0, 0, 2227, 2229, 1, 0, 0, 0, 2228, 2222, 1,
		0, 0, 0, 2228, 2229, 1, 0, 0, 0, 2229, 273, 1, 0, 0, 0, 2230, 2232, 5,
		226, 0, 0, 2231, 2230, 1, 0, 0, 0, 2231, 2232, 1, 0, 0, 0, 2232, 2279,
		1, 0, 0, 0, 2233, 2234, 5, 57, 0, 0, 2234, 2235, 5, 226, 0, 0, 2235, 2236,
		5, 64, 0, 0, 2236, 2237, 5, 226, 0, 0, 2237, 2238, 3, 436, 218, 0, 2238,
		2240, 3, 328, 164, 0, 2239, 2241, 5, 226, 0, 0, 2240, 2239, 1, 0, 0, 0,
		2240, 2241, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242, 2244, 5, 20, 0, 0,
		2243, 2245, 5, 226, 0, 0, 2244, 2243, 1, 0, 0, 0, 2244, 2245, 1, 0, 0,
		0, 2245, 2246, 1, 0, 0, 0, 2246, 2248, 3, 466, 233, 0, 2247, 2249, 5, 226,
		0, 0, 2248, 2247, 1, 0, 0, 0, 2248, 2249, 1, 0, 0, 0, 2249, 2250, 1, 0,
		0, 0, 2250, 2251, 5, 21, 0, 0, 2251, 2280, 1, 0, 0, 0, 2252, 2253, 5, 57,
		0, 0, 2253, 2254, 5, 226, 0, 0, 2254, 2255, 5, 98, 0, 0, 2255, 2256, 5,
		226, 0, 0, 2256, 2257, 5, 65, 0, 0, 2257, 2258, 5, 226, 0, 0, 2258, 2269,
		3, 436, 218, 0, 2259, 2261, 5, 226, 0, 0, 2260, 2259, 1, 0, 0, 0, 2260,
		2261, 1, 0, 0, 0, 2261, 2262, 1, 0, 0, 0, 2262, 2264, 5, 15, 0, 0, 2263,
		2265, 5, 226, 0, 0, 2264, 2263, 1, 0, 0, 0, 2264, 2265, 1, 0, 0, 0, 2265,
		2266, 1, 0, 0, 0, 2266, 2268, 3, 436, 218, 0, 2267, 2260, 1, 0, 0, 0, 2268,
		2271, 1, 0, 0, 0, 2269, 2267, 1, 0, 0, 0, 2269, 2270, 1, 0, 0, 0, 2270,
		2280, 1, 0, 0, 0, 2271, 2269, 1, 0, 0, 0, 2272, 2273, 5, 57, 0, 0, 2273,
		2274, 5, 226, 0, 0, 2274, 2275, 5, 99, 0, 0, 2275, 2276, 5, 226, 0, 0,
		2276, 2277, 3, 436, 218, 0, 2277, 2278, 3, 328, 164, 0, 2278, 2280, 1,
		0, 0, 0, 2279, 2233, 1, 0, 0, 0, 2279, 2252, 1, 0, 0, 0, 2279, 2272, 1,
		0, 0, 0, 2280, 275, 1, 0, 0, 0, 2281, 2282, 5, 100, 0, 0, 2282, 2283, 5,
		226, 0, 0, 2283, 2294, 3, 278, 139, 0, 2284, 2286, 5, 226, 0, 0, 2285,
		2284, 1, 0, 0, 0, 2285, 2286, 1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287,
		2289, 5, 15, 0, 0, 2288, 2290, 5, 226, 0, 0, 2289, 2288, 1, 0, 0, 0, 2289,
		2290, 1, 0, 0, 0, 2290, 2291, 1, 0, 0, 0, 2291, 2293, 3, 278, 139, 0, 2292,
		2285, 1, 0, 0, 0, 2293, 2296, 1, 0, 0, 0, 2294, 2292, 1, 0, 0, 0, 2294,
		2295, 1, 0, 0, 0, 2295, 2298, 1, 0, 0, 0, 2296, 2294, 1, 0, 0, 0, 2297,
		2299, 3, 294, 147, 0, 2298, 2297, 1, 0, 0, 0, 2298, 2299, 1, 0, 0, 0, 2299,
		277, 1, 0, 0, 0, 2300, 2302, 3, 436, 218, 0, 2301, 2303, 5, 226, 0, 0,
		2302, 2301, 1, 0, 0, 0, 2302, 2303, 1, 0, 0, 0, 2303, 2304, 1, 0, 0, 0,
		2304, 2306, 5, 12, 0, 0, 2305, 2307, 5, 226, 0, 0, 2306, 2305, 1, 0, 0,
		0, 2306, 2307, 1, 0, 0, 0, 2307, 2308, 1, 0, 0, 0, 2308, 2309, 3, 280,
		140, 0, 2309, 279, 1, 0, 0, 0, 2310, 2313, 3, 282, 141, 0, 2311, 2313,
		3, 284, 142, 0, 2312, 2310, 1, 0, 0, 0, 2312, 2311, 1, 0, 0, 0, 2313, 281,
		1, 0, 0, 0, 2314, 2316, 5, 101, 0, 0, 2315, 2317, 5, 226, 0, 0, 2316, 2315,
		1, 0, 0, 0, 2316, 2317, 1, 0, 0, 0, 2317, 2321, 1, 0, 0, 0, 2318, 2322,
		3, 286, 143, 0, 2319, 2322, 3, 288, 144, 0, 2320, 2322, 3, 290, 145, 0,
		2321, 2318, 1, 0, 0, 0, 2321, 2319, 1, 0, 0, 0, 2321, 2320, 1, 0, 0, 0,
		2322, 283, 1, 0, 0, 0, 2323, 2327, 7, 14, 0, 0, 2324, 2328, 3, 286, 143,
		0, 2325, 2328, 3, 288, 144, 0, 2326, 2328, 3, 290, 145, 0, 2327, 2324,
		1, 0, 0, 0, 2327, 2325, 1, 0, 0, 0, 2327, 2326, 1, 0, 0, 0, 2328, 285,
		1, 0, 0, 0, 2329, 2330, 5, 2, 0, 0, 2330, 2331, 3, 482, 241, 0, 2331, 2332,
		5, 20, 0, 0, 2332, 2333, 3, 482, 241, 0, 2333, 2336, 5, 12, 0, 0, 2334,
		2337, 5, 207, 0, 0, 2335, 2337, 3, 454, 227, 0, 2336, 2334, 1, 0, 0, 0,
		2336, 2335, 1, 0, 0, 0, 2337, 2338, 1, 0, 0, 0, 2338, 2339, 5, 21, 0, 0,
		2339, 287, 1, 0, 0, 0, 2340, 2341, 5, 2, 0, 0, 2341, 2342, 3, 482, 241,
		0, 2342, 2345, 5, 20, 0, 0, 2343, 2346, 5, 207, 0, 0, 2344, 2346, 3, 454,
		227, 0, 2345, 2343, 1, 0, 0, 0, 2345, 2344, 1, 0, 0, 0, 2346, 2347, 1,
		0, 0, 0, 2347, 2348, 5, 21, 0, 0, 2348, 289, 1, 0, 0, 0, 2349, 2353, 5,
		20, 0, 0, 2350, 2354, 3, 292, 146, 0, 2351, 2354, 3, 454, 227, 0, 2352,
		2354, 5, 19, 0, 0, 2353, 2350, 1, 0, 0, 0, 2353, 2351, 1, 0, 0, 0, 2353,
		2352, 1, 0, 0, 0, 2354, 2355, 1, 0, 0, 0, 2355, 2356, 5, 21, 0, 0, 2356,
		291, 1, 0, 0, 0, 2357, 2368, 3, 470, 235, 0, 2358, 2360, 5, 226, 0, 0,
		2359, 2358, 1, 0, 0, 0, 2359, 2360, 1, 0, 0, 0, 2360, 2361, 1, 0, 0, 0,
		2361, 2363, 5, 15, 0, 0, 2362, 2364, 5, 226, 0, 0, 2363, 2362, 1, 0, 0,
		0, 2363, 2364, 1, 0, 0, 0, 2364, 2365, 1, 0, 0, 0, 2365, 2367, 3, 470,
		235, 0, 2366, 2359, 1, 0, 0, 0, 2367, 2370, 1, 0, 0, 0, 2368, 2366, 1,
		0, 0, 0, 2368, 2369, 1, 0, 0, 0, 2369, 293, 1, 0, 0, 0, 2370, 2368, 1,
		0, 0, 0, 2371, 2372, 5, 104, 0, 0, 2372, 2373, 5, 226, 0, 0, 2373, 2374,
		3, 336, 168, 0, 2374, 295, 1, 0, 0, 0, 2375, 2386, 3, 298, 149, 0, 2376,
		2378, 5, 226, 0, 0, 2377, 2376, 1, 0, 0, 0, 2377, 2378, 1, 0, 0, 0, 2378,
		2379, 1, 0, 0, 0, 2379, 2381, 5, 15, 0, 0, 2380, 2382, 5, 226, 0, 0, 2381,
		2380, 1, 0, 0, 0, 2381, 2382, 1, 0, 0, 0, 2382, 2383, 1, 0, 0, 0, 2383,
		2385, 3, 298, 149, 0, 2384, 2377, 1, 0, 0, 0, 2385, 2388, 1, 0, 0, 0, 2386,
		2384, 1, 0, 0, 0, 2386, 2387, 1, 0, 0, 0, 2387, 297, 1, 0, 0, 0, 2388,
		2386, 1, 0, 0, 0, 2389, 2391, 3, 436, 218, 0, 2390, 2392, 5, 226, 0, 0,
		2391, 2390, 1, 0, 0, 0, 2391, 2392, 1, 0, 0, 0, 2392, 2393, 1, 0, 0, 0,
		2393, 2395, 5, 12, 0, 0, 2394, 2396, 5, 226, 0, 0, 2395, 2394, 1, 0, 0,
		0, 2395, 2396, 1, 0, 0, 0, 2396, 2397, 1, 0, 0, 0, 2397, 2398, 3, 300,
		150, 0, 2398, 2401, 1, 0, 0, 0, 2399, 2401, 3, 300, 150, 0, 2400, 2389,
		1, 0, 0, 0, 2400, 2399, 1, 0, 0, 0, 2401, 299, 1, 0, 0, 0, 2402, 2405,
		3, 392, 196, 0, 2403, 2405, 3, 302, 151, 0, 2404, 2402, 1, 0, 0, 0, 2404,
		2403, 1, 0, 0, 0, 2405, 301, 1, 0, 0, 0, 2406, 2413, 3, 304, 152, 0, 2407,
		2409, 5, 226, 0, 0, 2408, 2407, 1, 0, 0, 0, 2408, 2409, 1, 0, 0, 0, 2409,
		2410, 1, 0, 0, 0, 2410, 2412, 3, 306, 153, 0, 2411, 2408, 1, 0, 0, 0, 2412,
		2415, 1, 0, 0, 0, 2413, 2411, 1, 0, 0, 0, 2413, 2414, 1, 0, 0, 0, 2414,
		2421, 1, 0, 0, 0, 2415, 2413, 1, 0, 0, 0, 2416, 2417, 5, 20, 0, 0, 2417,
		2418, 3, 302, 151, 0, 2418, 2419, 5, 21, 0, 0, 2419, 2421, 1, 0, 0, 0,
		2420, 2406, 1, 0, 0, 0, 2420, 2416, 1, 0, 0, 0, 2421, 303, 1, 0, 0, 0,
		2422, 2424, 5, 20, 0, 0, 2423, 2425, 5, 226, 0, 0, 2424, 2423, 1, 0, 0,
		0, 2424, 2425, 1, 0, 0, 0, 2425, 2430, 1, 0, 0, 0, 2426, 2428, 3, 436,
		218, 0, 2427, 2429, 5, 226, 0, 0, 2428, 2427, 1, 0, 0, 0, 2428, 2429, 1,
		0, 0, 0, 2429, 2431, 1, 0, 0, 0, 2430, 2426, 1, 0, 0, 0, 2430, 2431, 1,
		0, 0, 0, 2431, 2436, 1, 0, 0, 0, 2432, 2434, 3, 326, 163, 0, 2433, 2435,
		5, 226, 0, 0, 2434, 2433, 1, 0, 0, 0, 2434, 2435, 1, 0, 0, 0, 2435, 2437,
		1, 0, 0, 0, 2436, 2432, 1, 0, 0, 0, 2436, 2437, 1, 0, 0, 0, 2437, 2442,
		1, 0, 0, 0, 2438, 2440, 3, 316, 158, 0, 2439, 2441, 5, 226, 0, 0, 2440,
		2439, 1, 0, 0, 0, 2440, 2441, 1, 0, 0, 0, 2441, 2443, 1, 0, 0, 0, 2442,
		2438, 1, 0, 0, 0, 2442, 2443, 1, 0, 0, 0, 2443, 2444, 1, 0, 0, 0, 2444,
		2445, 5, 21, 0, 0, 2445, 305, 1, 0, 0, 0, 2446, 2448, 3, 308, 154, 0, 2447,
		2449, 5, 226, 0, 0, 2448, 2447, 1, 0, 0, 0, 2448, 2449, 1, 0, 0, 0, 2449,
		2450, 1, 0, 0, 0, 2450, 2451, 3, 304, 152, 0, 2451, 307, 1, 0, 0, 0, 2452,
		2454, 3, 310, 155, 0, 2453, 2455, 5, 226, 0, 0, 2454, 2453, 1, 0, 0, 0,
		2454, 2455, 1, 0, 0, 0, 2455, 2457, 1, 0, 0, 0, 2456, 2458, 3, 314, 157,
		0, 2457, 2456, 1, 0, 0, 0, 2457, 2458, 1, 0, 0, 0, 2458, 2460, 1, 0, 0,
		0, 2459, 2461, 5, 226, 0, 0, 2460, 2459, 1, 0, 0, 0, 2460, 2461, 1, 0,
		0, 0, 2461, 2462, 1, 0, 0, 0, 2462, 2463, 3, 312, 156, 0, 2463, 309, 1,
		0, 0, 0, 2464, 2466, 3, 476, 238, 0, 2465, 2467, 5, 226, 0, 0, 2466, 2465,
		1, 0, 0, 0, 2466, 2467, 1, 0, 0, 0, 2467, 2468, 1, 0, 0, 0, 2468, 2469,
		3, 480, 240, 0, 2469, 2472, 1, 0, 0, 0, 2470, 2472, 3, 480, 240, 0, 2471,
		2464, 1, 0, 0, 0, 2471, 2470, 1, 0, 0, 0, 2472, 311, 1, 0, 0, 0, 2473,
		2475, 3, 480, 240, 0, 2474, 2476, 5, 226, 0, 0, 2475, 2474, 1, 0, 0, 0,
		2475, 2476, 1, 0, 0, 0, 2476, 2477, 1, 0, 0, 0, 2477, 2478, 3, 478, 239,
		0, 2478, 2481, 1, 0, 0, 0, 2479, 2481, 3, 480, 240, 0, 2480, 2473, 1, 0,
		0, 0, 2480, 2479, 1, 0, 0, 0, 2481, 313, 1, 0, 0, 0, 2482, 2484, 5, 17,
		0, 0, 2483, 2485, 5, 226, 0, 0, 2484, 2483, 1, 0, 0, 0, 2484, 2485, 1,
		0, 0, 0, 2485, 2490, 1, 0, 0, 0, 2486, 2488, 3, 436, 218, 0, 2487, 2489,
		5, 226, 0, 0, 2488, 2487, 1, 0, 0, 0, 2488, 2489, 1, 0, 0, 0, 2489, 2491,
		1, 0, 0, 0, 2490, 2486, 1, 0, 0, 0, 2490, 2491, 1, 0, 0, 0, 2491, 2496,
		1, 0, 0, 0, 2492, 2494, 3, 320, 160, 0, 2493, 2495, 5, 226, 0, 0, 2494,
		2493, 1, 0, 0, 0, 2494, 2495, 1, 0, 0, 0, 2495, 2497, 1, 0, 0, 0, 2496,
		2492, 1, 0, 0, 0, 2496, 2497, 1, 0, 0, 0, 2497, 2499, 1, 0, 0, 0, 2498,
		2500, 3, 330, 165, 0, 2499, 2498, 1, 0, 0, 0, 2499, 2500, 1, 0, 0, 0, 2500,
		2505, 1, 0, 0, 0, 2501, 2503, 3, 316, 158, 0, 2502, 2504, 5, 226, 0, 0,
		2503, 2502, 1, 0, 0, 0, 2503, 2504, 1, 0, 0, 0, 2504, 2506, 1, 0, 0, 0,
		2505, 2501, 1, 0, 0, 0, 2505, 2506, 1, 0, 0, 0, 2506, 2507, 1, 0, 0, 0,
		2507, 2508, 5, 18, 0, 0, 2508, 315, 1, 0, 0, 0, 2509, 2512, 3, 440, 220,
		0, 2510, 2512, 3, 454, 227, 0, 2511, 2509, 1, 0, 0, 0, 2511, 2510, 1, 0,
		0, 0, 2512, 317, 1, 0, 0, 0, 2513, 2515, 5, 2, 0, 0, 2514, 2516, 5, 226,
		0, 0, 2515, 2514, 1, 0, 0, 0, 2515, 2516, 1, 0, 0, 0, 2516, 2517, 1, 0,
		0, 0, 2517, 2518, 3, 334, 167, 0, 2518, 319, 1, 0, 0, 0, 2519, 2527, 3,
		322, 161, 0, 2520, 2522, 5, 226, 0, 0, 2521, 2520, 1, 0, 0, 0, 2521, 2522,
		1, 0, 0, 0, 2522, 2523, 1, 0, 0, 0, 2523, 2524, 5, 23, 0, 0, 2524, 2526,
		3, 324, 162, 0, 2525, 2521, 1, 0, 0, 0, 2526, 2529, 1, 0, 0, 0, 2527, 2525,
		1, 0, 0, 0, 2527, 2528, 1, 0, 0, 0, 2528, 321, 1, 0, 0, 0, 2529, 2527,
		1, 0, 0, 0, 2530, 2531, 5, 2, 0, 0, 2531, 2532, 3, 334, 167, 0, 2532, 323,
		1, 0, 0, 0, 2533, 2535, 5, 2, 0, 0, 2534, 2533, 1, 0, 0, 0, 2534, 2535,
		1, 0, 0, 0, 2535, 2536, 1, 0, 0, 0, 2536, 2537, 3, 334, 167, 0, 2537, 325,
		1, 0, 0, 0, 2538, 2545, 3, 328, 164, 0, 2539, 2541, 5, 226, 0, 0, 2540,
		2539, 1, 0, 0, 0, 2540, 2541, 1, 0, 0, 0, 2541, 2542, 1, 0, 0, 0, 2542,
		2544, 3, 328, 164, 0, 2543, 2540, 1, 0, 0, 0, 2544, 2547, 1, 0, 0, 0, 2545,
		2543, 1, 0, 0, 0, 2545, 2546, 1, 0, 0, 0, 2546, 327, 1, 0, 0, 0, 2547,
		2545, 1, 0, 0, 0, 2548, 2549, 5, 2, 0, 0, 2549, 2550, 3, 332, 166, 0, 2550,
		329, 1, 0, 0, 0, 2551, 2553, 5, 19, 0, 0, 2552, 2554, 5, 226, 0, 0, 2553,
		2552, 1, 0, 0, 0, 2553, 2554, 1, 0, 0, 0, 2554, 2559, 1, 0, 0, 0, 2555,
		2557, 3, 470, 235, 0, 2556, 2558, 5, 226, 0, 0, 2557, 2556, 1, 0, 0, 0,
		2557, 2558, 1, 0, 0, 0, 2558, 2560, 1, 0, 0, 0, 2559, 2555, 1, 0, 0, 0,
		2559, 2560, 1, 0, 0, 0, 2560, 2571, 1, 0, 0, 0, 2561, 2563, 5, 24, 0, 0,
		2562, 2564, 5, 226, 0, 0, 2563, 2562, 1, 0, 0, 0, 2563, 2564, 1, 0, 0,
		0, 2564, 2569, 1, 0, 0, 0, 2565, 2567, 3, 470, 235, 0, 2566, 2568, 5, 226,
		0, 0, 2567, 2566, 1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2570, 1, 0,
		0, 0, 2569, 2565, 1, 0, 0, 0, 2569, 2570, 1, 0, 0, 0, 2570, 2572, 1, 0,
		0, 0, 2571, 2561, 1, 0, 0, 0, 2571, 2572, 1, 0, 0, 0, 2572, 331, 1, 0,
		0, 0, 2573, 2574, 3, 482, 241, 0, 2574, 333, 1, 0, 0, 0, 2575, 2576, 3,
		482, 241, 0, 2576, 335, 1, 0, 0, 0, 2577, 2578, 3, 338, 169, 0, 2578, 337,
		1, 0, 0, 0, 2579, 2586, 3, 340, 170, 0, 2580, 2581, 5, 226, 0, 0, 2581,
		2582, 5, 107, 0, 0, 2582, 2583, 5, 226, 0, 0, 2583, 2585, 3, 340, 170,
		0, 2584, 2580, 1, 0, 0, 0, 2585, 2588, 1, 0, 0, 0, 2586, 2584, 1, 0, 0,
		0, 2586, 2587, 1, 0, 0, 0, 2587, 339, 1, 0, 0, 0, 2588, 2586, 1, 0, 0,
		0, 2589, 2596, 3, 342, 171, 0, 2590, 2591, 5, 226, 0, 0, 2591, 2592, 5,
		108, 0, 0, 2592, 2593, 5, 226, 0, 0, 2593, 2595, 3, 342, 171, 0, 2594,
		2590, 1, 0, 0, 0, 2595, 2598, 1, 0, 0, 0, 2596, 2594, 1, 0, 0, 0, 2596,
		2597, 1, 0, 0, 0, 2597, 341, 1, 0, 0, 0, 2598, 2596, 1, 0, 0, 0, 2599,
		2606, 3, 344, 172, 0, 2600, 2601, 5, 226, 0, 0, 2601, 2602, 5, 109, 0,
		0, 2602, 2603, 5, 226, 0, 0, 2603, 2605, 3, 344, 172, 0, 2604, 2600, 1,
		0, 0, 0, 2605, 2608, 1, 0, 0, 0, 2606, 2604, 1, 0, 0, 0, 2606, 2607, 1,
		0, 0, 0, 2607, 343, 1, 0, 0, 0, 2608, 2606, 1, 0, 0, 0, 2609, 2611, 5,
		110, 0, 0, 2610, 2612, 5, 226, 0, 0, 2611, 2610, 1, 0, 0, 0, 2611, 2612,
		1, 0, 0, 0, 2612, 2614, 1, 0, 0, 0, 2613, 2609, 1, 0, 0, 0, 2614, 2617,
		1, 0, 0, 0, 2615, 2613, 1, 0, 0, 0, 2615, 2616, 1, 0, 0, 0, 2616, 2618,
		1, 0, 0, 0, 2617, 2615, 1, 0, 0, 0, 2618, 2619, 3, 346, 173, 0, 2619, 345,
		1, 0, 0, 0, 2620, 2627, 3, 348, 174, 0, 2621, 2623, 5, 226, 0, 0, 2622,
		2621, 1, 0, 0, 0, 2622, 2623, 1, 0, 0, 0, 2623, 2624, 1, 0, 0, 0, 2624,
		2626, 3, 408, 204, 0, 2625, 2622, 1, 0, 0, 0, 2626, 2629, 1, 0, 0, 0, 2627,
		2625, 1, 0, 0, 0, 2627, 2628, 1, 0, 0, 0, 2628, 347, 1, 0, 0, 0, 2629,
		2627, 1, 0, 0, 0, 2630, 2649, 3, 350, 175, 0, 2631, 2633, 5, 226, 0, 0,
		2632, 2631, 1, 0, 0, 0, 2632, 2633, 1, 0, 0, 0, 2633, 2634, 1, 0, 0, 0,
		2634, 2636, 5, 13, 0, 0, 2635, 2637, 5, 226, 0, 0, 2636, 2635, 1, 0, 0,
		0, 2636, 2637, 1, 0, 0, 0, 2637, 2638, 1, 0, 0, 0, 2638, 2648, 3, 350,
		175, 0, 2639, 2641, 5, 226, 0, 0, 2640, 2639, 1, 0, 0, 0, 2640, 2641, 1,
		0, 0, 0, 2641, 2642, 1, 0, 0, 0, 2642, 2644, 5, 3, 0, 0, 2643, 2645, 5,
		226, 0, 0, 2644, 2643, 1, 0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645, 2646,
		1, 0, 0, 0, 2646, 2648, 3, 350, 175, 0, 2647, 2632, 1, 0, 0, 0, 2647, 2640,
		1, 0, 0, 0, 2648, 2651, 1, 0, 0, 0, 2649, 2647, 1, 0, 0, 0, 2649, 2650,
		1, 0, 0, 0, 2650, 349, 1, 0, 0, 0, 2651, 2649, 1, 0, 0, 0, 2652, 2679,
		3, 352, 176, 0, 2653, 2655, 5, 226, 0, 0, 2654, 2653, 1, 0, 0, 0, 2654,
		2655, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656, 2658, 5, 19, 0, 0, 2657,
		2659, 5, 226, 0, 0, 2658, 2657, 1, 0, 0, 0, 2658, 2659, 1, 0, 0, 0, 2659,
		2660, 1, 0, 0, 0, 2660, 2678, 3, 352, 176, 0, 2661, 2663, 5, 226, 0, 0,
		2662, 2661, 1, 0, 0, 0, 2662, 2663, 1, 0, 0, 0, 2663, 2664, 1, 0, 0, 0,
		2664, 2666, 5, 6, 0, 0, 2665, 2667, 5, 226, 0, 0, 2666, 2665, 1, 0, 0,
		0, 2666, 2667, 1, 0, 0, 0, 2667, 2668, 1, 0, 0, 0, 2668, 2678, 3, 352,
		176, 0, 2669, 2671, 5, 226, 0, 0, 2670, 2669, 1, 0, 0, 0, 2670, 2671, 1,
		0, 0, 0, 2671, 2672, 1, 0, 0, 0, 2672, 2674, 5, 25, 0, 0, 2673, 2675, 5,
		226, 0, 0, 2674, 2673, 1, 0, 0, 0, 2674, 2675, 1, 0, 0, 0, 2675, 2676,
		1, 0, 0, 0, 2676, 2678, 3, 352, 176, 0, 2677, 2654, 1, 0, 0, 0, 2677, 2662,
		1, 0, 0, 0, 2677, 2670, 1, 0, 0, 0, 2678, 2681, 1, 0, 0, 0, 2679, 2677,
		1, 0, 0, 0, 2679, 2680, 1, 0, 0, 0, 2680, 351, 1, 0, 0, 0, 2681, 2679,
		1, 0, 0, 0, 2682, 2693, 3, 354, 177, 0, 2683, 2685, 5, 226, 0, 0, 2684,
		2683, 1, 0, 0, 0, 2684, 2685, 1, 0, 0, 0, 2685, 2686, 1, 0, 0, 0, 2686,
		2688, 5, 26, 0, 0, 2687, 2689, 5, 226, 0, 0, 2688, 2687, 1, 0, 0, 0, 2688,
		2689, 1, 0, 0, 0, 2689, 2690, 1, 0, 0, 0, 2690, 2692, 3, 354, 177, 0, 2691,
		2684, 1, 0, 0, 0, 2692, 2695, 1, 0, 0, 0, 2693, 2691, 1, 0, 0, 0, 2693,
		2694, 1, 0, 0, 0, 2694, 353, 1, 0, 0, 0, 2695, 2693, 1, 0, 0, 0, 2696,
		2698, 7, 15, 0, 0, 2697, 2699, 5, 226, 0, 0, 2698, 2697, 1, 0, 0, 0, 2698,
		2699, 1, 0, 0, 0, 2699, 2701, 1, 0, 0, 0, 2700, 2696, 1, 0, 0, 0, 2701,
		2704, 1, 0, 0, 0, 2702, 2700, 1, 0, 0, 0, 2702, 2703, 1, 0, 0, 0, 2703,
		2705, 1, 0, 0, 0, 2704, 2702, 1, 0, 0, 0, 2705, 2706, 3, 356, 178, 0, 2706,
		355, 1, 0, 0, 0, 2707, 2761, 3, 358, 179, 0, 2708, 2710, 5, 226, 0, 0,
		2709, 2708, 1, 0, 0, 0, 2709, 2710, 1, 0, 0, 0, 2710, 2711, 1, 0, 0, 0,
		2711, 2712, 5, 17, 0, 0, 2712, 2713, 3, 336, 168, 0, 2713, 2714, 5, 18,
		0, 0, 2714, 2760, 1, 0, 0, 0, 2715, 2717, 5, 226, 0, 0, 2716, 2715, 1,
		0, 0, 0, 2716, 2717, 1, 0, 0, 0, 2717, 2718, 1, 0, 0, 0, 2718, 2720, 5,
		17, 0, 0, 2719, 2721, 3, 336, 168, 0, 2720, 2719, 1, 0, 0, 0, 2720, 2721,
		1, 0, 0, 0, 2721, 2722, 1, 0, 0, 0, 2722, 2724, 5, 24, 0, 0, 2723, 2725,
		3, 336, 168, 0, 2724, 2723, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725, 2726,
		1, 0, 0, 0, 2726, 2760, 5, 18, 0, 0, 2727, 2729, 5, 226, 0, 0, 2728, 2727,
		1, 0, 0, 0, 2728, 2729, 1, 0, 0, 0, 2729, 2730, 1, 0, 0, 0, 2730, 2744,
		5, 27, 0, 0, 2731, 2732, 5, 226, 0, 0, 2732, 2744, 5, 87, 0, 0, 2733, 2734,
		5, 226, 0, 0, 2734, 2735, 5, 111, 0, 0, 2735, 2736, 5, 226, 0, 0, 2736,
		2744, 5, 73, 0, 0, 2737, 2738, 5, 226, 0, 0, 2738, 2739, 5, 112, 0, 0,
		2739, 2740, 5, 226, 0, 0, 2740, 2744, 5, 73, 0, 0, 2741, 2742, 5, 226,
		0, 0, 2742, 2744, 5, 113, 0, 0, 2743, 2728, 1, 0, 0, 0, 2743, 2731, 1,
		0, 0, 0, 2743, 2733, 1, 0, 0, 0, 2743, 2737, 1, 0, 0, 0, 2743, 2741, 1,
		0, 0, 0, 2744, 2746, 1, 0, 0, 0, 2745, 2747, 5, 226, 0, 0, 2746, 2745,
		1, 0, 0, 0, 2746, 2747, 1, 0, 0, 0, 2747, 2748, 1, 0, 0, 0, 2748, 2760,
		3, 358, 179, 0, 2749, 2750, 5, 226, 0, 0, 2750, 2751, 5, 68, 0, 0, 2751,
		2752, 5, 226, 0, 0, 2752, 2760, 5, 114, 0, 0, 2753, 2754, 5, 226, 0, 0,
		2754, 2755, 5, 68, 0, 0, 2755, 2756, 5, 226, 0, 0, 2756, 2757, 5, 110,
		0, 0, 2757, 2758, 5, 226, 0, 0, 2758, 2760, 5, 114, 0, 0, 2759, 2709, 1,
		0, 0, 0, 2759, 2716, 1, 0, 0, 0, 2759, 2743, 1, 0, 0, 0, 2759, 2749, 1,
		0, 0, 0, 2759, 2753, 1, 0, 0, 0, 2760, 2763, 1, 0, 0, 0, 2761, 2759, 1,
		0, 0, 0, 2761, 2762, 1, 0, 0, 0, 2762, 357, 1, 0, 0, 0, 2763, 2761, 1,
		0, 0, 0, 2764, 2774, 3, 398, 199, 0, 2765, 2767, 5, 226, 0, 0, 2766, 2765,
		1, 0, 0, 0, 2766, 2767, 1, 0, 0, 0, 2767, 2770, 1, 0, 0, 0, 2768, 2771,
		3, 430, 215, 0, 2769, 2771, 3, 326, 163, 0, 2770, 2768, 1, 0, 0, 0, 2770,
		2769, 1, 0, 0, 0, 2771, 2773, 1, 0, 0, 0, 2772, 2766, 1, 0, 0, 0, 2773,
		2776, 1, 0, 0, 0, 2774, 2772, 1, 0, 0, 0, 2774, 2775, 1, 0, 0, 0, 2775,
		359, 1, 0, 0, 0, 2776, 2774, 1, 0, 0, 0, 2777, 2779, 3, 362, 181, 0, 2778,
		2780, 5, 226, 0, 0, 2779, 2778, 1, 0, 0, 0, 2779, 2780, 1, 0, 0, 0, 2780,
		2781, 1, 0, 0, 0, 2781, 2783, 5, 20, 0, 0, 2782, 2784, 5, 226, 0, 0, 2783,
		2782, 1, 0, 0, 0, 2783, 2784, 1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785,
		2787, 3, 414, 207, 0, 2786, 2788, 5, 226, 0, 0, 2787, 2786, 1, 0, 0, 0,
		2787, 2788, 1, 0, 0, 0, 2788, 2789, 1, 0, 0, 0, 2789, 2790, 5, 21, 0, 0,
		2790, 361, 1, 0, 0, 0, 2791, 2792, 5, 116, 0, 0, 2792, 363, 1, 0, 0, 0,
		2793, 2795, 3, 366, 183, 0, 2794, 2796, 5, 226, 0, 0, 2795, 2794, 1, 0,
		0, 0, 2795, 2796, 1, 0, 0, 0, 2796, 2797, 1, 0, 0, 0, 2797, 2799, 5, 20,
		0, 0, 2798, 2800, 5, 226, 0, 0, 2799, 2798, 1, 0, 0, 0, 2799, 2800, 1,
		0, 0, 0, 2800, 2801, 1, 0, 0, 0, 2801, 2803, 3, 336, 168, 0, 2802, 2804,
		5, 226, 0, 0, 2803, 2802, 1, 0, 0, 0, 2803, 2804, 1, 0, 0, 0, 2804, 2805,
		1, 0, 0, 0, 2805, 2806, 5, 21, 0, 0, 2806, 365, 1, 0, 0, 0, 2807, 2808,
		5, 70, 0, 0, 2808, 367, 1, 0, 0, 0, 2809, 2811, 3, 370, 185, 0, 2810, 2812,
		5, 226, 0, 0, 2811, 2810, 1, 0, 0, 0, 2811, 2812, 1, 0, 0, 0, 2812, 2813,
		1, 0, 0, 0, 2813, 2815, 5, 20, 0, 0, 2814, 2816, 5, 226, 0, 0, 2815, 2814,
		1, 0, 0, 0, 2815, 2816, 1, 0, 0, 0, 2816, 2817, 1, 0, 0, 0, 2817, 2819,
		3, 414, 207, 0, 2818, 2820, 5, 226, 0, 0, 2819, 2818, 1, 0, 0, 0, 2819,
		2820, 1, 0, 0, 0, 2820, 2821, 1, 0, 0, 0, 2821, 2822, 5, 21, 0, 0, 2822,
		369, 1, 0, 0, 0, 2823, 2824, 5, 61, 0, 0, 2824, 371, 1, 0, 0, 0, 2825,
		2827, 3, 374, 187, 0, 2826, 2828, 5, 226, 0, 0, 2827, 2826, 1, 0, 0, 0,
		2827, 2828, 1, 0, 0, 0, 2828, 2829, 1, 0, 0, 0, 2829, 2831, 5, 20, 0, 0,
		2830, 2832, 5, 226, 0, 0, 2831, 2830, 1, 0, 0, 0, 2831, 2832, 1, 0, 0,
		0, 2832, 2833, 1, 0, 0, 0, 2833, 2835, 3, 414, 207, 0, 2834, 2836, 5, 226,
		0, 0, 2835, 2834, 1, 0, 0, 0, 2835, 2836, 1, 0, 0, 0, 2836, 2837, 1, 0,
		0, 0, 2837, 2838, 5, 21, 0, 0, 2838, 373, 1, 0, 0, 0, 2839, 2840, 5, 118,
		0, 0, 2840, 375, 1, 0, 0, 0, 2841, 2843, 3, 378, 189, 0, 2842, 2844, 5,
		226, 0, 0, 2843, 2842, 1, 0, 0, 0, 2843, 2844, 1, 0, 0, 0, 2844, 2845,
		1, 0, 0, 0, 2845, 2847, 5, 20, 0, 0, 2846, 2848, 5, 226, 0, 0, 2847, 2846,
		1, 0, 0, 0, 2847, 2848, 1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 2851,
		3, 414, 207, 0, 2850, 2852, 5, 226, 0, 0, 2851, 2850, 1, 0, 0, 0, 2851,
		2852, 1, 0, 0, 0, 2852, 2853, 1, 0, 0, 0, 2853, 2854, 5, 21, 0, 0, 2854,
		377, 1, 0, 0, 0, 2855, 2856, 5, 119, 0, 0, 2856, 379, 1, 0, 0, 0, 2857,
		2859, 3, 382, 191, 0, 2858, 2860, 5, 226, 0, 0, 2859, 2858, 1, 0, 0, 0,
		2859, 2860, 1, 0, 0, 0, 2860, 2861, 1, 0, 0, 0, 2861, 2863, 5, 20, 0, 0,
		2862, 2864, 5, 226, 0, 0, 2863, 2862, 1, 0, 0, 0, 2863, 2864, 1, 0, 0,
		0, 2864, 2865, 1, 0, 0, 0, 2865, 2867, 3, 414, 207, 0, 2866, 2868, 5, 226,
		0, 0, 2867, 2866, 1, 0, 0, 0, 2867, 2868, 1, 0, 0, 0, 2868, 2869, 1, 0,
		0, 0, 2869, 2870, 5, 21, 0, 0, 2870, 381, 1, 0, 0, 0, 2871, 2872, 5, 120,
		0, 0, 2872, 383, 1, 0, 0, 0, 2873, 2875, 3, 386, 193, 0, 2874, 2876, 5,
		226, 0, 0, 2875, 2874, 1, 0, 0, 0, 2875, 2876, 1, 0, 0, 0, 2876, 2877,
		1, 0, 0, 0, 2877, 2879, 5, 20, 0, 0, 2878, 2880, 5, 226, 0, 0, 2879, 2878,
		1, 0, 0, 0, 2879, 2880, 1, 0, 0, 0, 2880, 2881, 1, 0, 0, 0, 2881, 2890,
		3, 414, 207, 0, 2882, 2884, 5, 226, 0, 0, 2883, 2882, 1, 0, 0, 0, 2883,
		2884, 1, 0, 0, 0, 2884, 2885, 1, 0, 0, 0, 2885, 2887, 5, 23, 0, 0, 2886,
		2888, 5, 226, 0, 0, 2887, 2886, 1, 0, 0, 0, 2887, 2888, 1, 0, 0, 0, 2888,
		2889, 1, 0, 0, 0, 2889, 2891, 3, 336, 168, 0, 2890, 2883, 1, 0, 0, 0, 2890,
		2891, 1, 0, 0, 0, 2891, 2893, 1, 0, 0, 0, 2892, 2894, 5, 226, 0, 0, 2893,
		2892, 1, 0, 0, 0, 2893, 2894, 1, 0, 0, 0, 2894, 2895, 1, 0, 0, 0, 2895,
		2896, 5, 21, 0, 0, 2896, 385, 1, 0, 0, 0, 2897, 2898, 5, 117, 0, 0, 2898,
		387, 1, 0, 0, 0, 2899, 2901, 3, 390, 195, 0, 2900, 2902, 5, 226, 0, 0,
		2901, 2900, 1, 0, 0, 0, 2901, 2902, 1, 0, 0, 0, 2902, 2903, 1, 0, 0, 0,
		2903, 2905, 5, 20, 0, 0, 2904, 2906, 5, 226, 0, 0, 2905, 2904, 1, 0, 0,
		0, 2905, 2906, 1, 0, 0, 0, 2906, 2907, 1, 0, 0, 0, 2907, 2909, 3, 436,
		218, 0, 2908, 2910, 5, 226, 0, 0, 2909, 2908, 1, 0, 0, 0, 2909, 2910, 1,
		0, 0, 0, 2910, 2911, 1, 0, 0, 0, 2911, 2913, 5, 12, 0, 0, 2912, 2914, 5,
		226, 0, 0, 2913, 2912, 1, 0, 0, 0, 2913, 2914, 1, 0, 0, 0, 2914, 2915,
		1, 0, 0, 0, 2915, 2917, 3, 336, 168, 0, 2916, 2918, 5, 226, 0, 0, 2917,
		2916, 1, 0, 0, 0, 2917, 2918, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919,
		2921, 5, 15, 0, 0, 2920, 2922, 5, 226, 0, 0, 2921, 2920, 1, 0, 0, 0, 2921,
		2922, 1, 0, 0, 0, 2922, 2923, 1, 0, 0, 0, 2923, 2925, 3, 416, 208, 0, 2924,
		2926, 5, 226, 0, 0, 2925, 2924, 1, 0, 0, 0, 2925, 2926, 1, 0, 0, 0, 2926,
		2927, 1, 0, 0, 0, 2927, 2929, 5, 23, 0, 0, 2928, 2930, 5, 226, 0, 0, 2929,
		2928, 1, 0, 0, 0, 2929, 2930, 1, 0, 0, 0, 2930, 2931, 1, 0, 0, 0, 2931,
		2933, 3, 336, 168, 0, 2932, 2934, 5, 226, 0, 0, 2933, 2932, 1, 0, 0, 0,
		2933, 2934, 1, 0, 0, 0, 2934, 2935, 1, 0, 0, 0, 2935, 2936, 5, 21, 0, 0,
		2936, 389, 1, 0, 0, 0, 2937, 2938, 5, 123, 0, 0, 2938, 391, 1, 0, 0, 0,
		2939, 2941, 3, 394, 197, 0, 2940, 2942, 5, 226, 0, 0, 2941, 2940, 1, 0,
		0, 0, 2941, 2942, 1, 0, 0, 0, 2942, 2943, 1, 0, 0, 0, 2943, 2945, 5, 20,
		0, 0, 2944, 2946, 5, 226, 0, 0, 2945, 2944, 1, 0, 0, 0, 2945, 2946, 1,
		0, 0, 0, 2946, 2947, 1, 0, 0, 0, 2947, 2949, 3, 302, 151, 0, 2948, 2950,
		5, 226, 0, 0, 2949, 2948, 1, 0, 0, 0, 2949, 2950, 1, 0, 0, 0, 2950, 2951,
		1, 0, 0, 0, 2951, 2952, 5, 21, 0, 0, 2952, 2968, 1, 0, 0, 0, 2953, 2955,
		3, 396, 198, 0, 2954, 2956, 5, 226, 0, 0, 2955, 2954, 1, 0, 0, 0, 2955,
		2956, 1, 0, 0, 0, 2956, 2957, 1, 0, 0, 0, 2957, 2959, 5, 20, 0, 0, 2958,
		2960, 5, 226, 0, 0, 2959, 2958, 1, 0, 0, 0, 2959, 2960, 1, 0, 0, 0, 2960,
		2961, 1, 0, 0, 0, 2961, 2963, 3, 302, 151, 0, 2962, 2964, 5, 226, 0, 0,
		2963, 2962, 1, 0, 0, 0, 2963, 2964, 1, 0, 0, 0, 2964, 2965, 1, 0, 0, 0,
		2965, 2966, 5, 21, 0, 0, 2966, 2968, 1, 0, 0, 0, 2967, 2939, 1, 0, 0, 0,
		2967, 2953, 1, 0, 0, 0, 2968, 393, 1, 0, 0, 0, 2969, 2970, 5, 105, 0, 0,
		2970, 395, 1, 0, 0, 0, 2971, 2972, 5, 106, 0, 0, 2972, 397, 1, 0, 0, 0,
		2973, 3005, 3, 400, 200, 0, 2974, 3005, 3, 454, 227, 0, 2975, 3005, 3,
		432, 216, 0, 2976, 2978, 5, 115, 0, 0, 2977, 2979, 5, 226, 0, 0, 2978,
		2977, 1, 0, 0, 0, 2978, 2979, 1, 0, 0, 0, 2979, 2980, 1, 0, 0, 0, 2980,
		2982, 5, 20, 0, 0, 2981, 2983, 5, 226, 0, 0, 2982, 2981, 1, 0, 0, 0, 2982,
		2983, 1, 0, 0, 0, 2983, 2984, 1, 0, 0, 0, 2984, 2986, 5, 19, 0, 0, 2985,
		2987, 5, 226, 0, 0, 2986, 2985, 1, 0, 0, 0, 2986, 2987, 1, 0, 0, 0, 2987,
		2988, 1, 0, 0, 0, 2988, 3005, 5, 21, 0, 0, 2989, 3005, 3, 426, 213, 0,
		2990, 3005, 3, 428, 214, 0, 2991, 3005, 3, 360, 180, 0, 2992, 3005, 3,
		384, 192, 0, 2993, 3005, 3, 388, 194, 0, 2994, 3005, 3, 368, 184, 0, 2995,
		3005, 3, 372, 186, 0, 2996, 3005, 3, 376, 188, 0, 2997, 3005, 3, 380, 190,
		0, 2998, 3005, 3, 364, 182, 0, 2999, 3005, 3, 392, 196, 0, 3000, 3005,
		3, 412, 206, 0, 3001, 3005, 3, 410, 205, 0, 3002, 3005, 3, 418, 209, 0,
		3003, 3005, 3, 436, 218, 0, 3004, 2973, 1, 0, 0, 0, 3004, 2974, 1, 0, 0,
		0, 3004, 2975, 1, 0, 0, 0, 3004, 2976, 1, 0, 0, 0, 3004, 2989, 1, 0, 0,
		0, 3004, 2990, 1, 0, 0, 0, 3004, 2991, 1, 0, 0, 0, 3004, 2992, 1, 0, 0,
		0, 3004, 2993, 1, 0, 0, 0, 3004, 2994, 1, 0, 0, 0, 3004, 2995, 1, 0, 0,
		0, 3004, 2996, 1, 0, 0, 0, 3004, 2997, 1, 0, 0, 0, 3004, 2998, 1, 0, 0,
		0, 3004, 2999, 1, 0, 0, 0, 3004, 3000, 1, 0, 0, 0, 3004, 3001, 1, 0, 0,
		0, 3004, 3002, 1, 0, 0, 0, 3004, 3003, 1, 0, 0, 0, 3005, 399, 1, 0, 0,
		0, 3006, 3014, 3, 438, 219, 0, 3007, 3014, 3, 402, 201, 0, 3008, 3014,
		3, 404, 202, 0, 3009, 3014, 5, 114, 0, 0, 3010, 3014, 3, 440, 220, 0, 3011,
		3014, 3, 406, 203, 0, 3012, 3014, 3, 442, 221, 0, 3013, 3006, 1, 0, 0,
		0, 3013, 3007, 1, 0, 0, 0, 3013, 3008, 1, 0, 0, 0, 3013, 3009, 1, 0, 0,
		0, 3013, 3010, 1, 0, 0, 0, 3013, 3011, 1, 0, 0, 0, 3013, 3012, 1, 0, 0,
		0, 3014, 401, 1, 0, 0, 0, 3015, 3016, 5, 207, 0, 0, 3016, 403, 1, 0, 0,
		0, 3017, 3018, 7, 16, 0, 0, 3018, 405, 1, 0, 0, 0, 3019, 3021, 5, 17, 0,
		0, 3020, 3022, 5, 226, 0, 0, 3021, 3020, 1, 0, 0, 0, 3021, 3022, 1, 0,
		0, 0, 3022, 3040, 1, 0, 0, 0, 3023, 3025, 3, 336, 168, 0, 3024, 3026, 5,
		226, 0, 0, 3025, 3024, 1, 0, 0, 0, 3025, 3026, 1, 0, 0, 0, 3026, 3037,
		1, 0, 0, 0, 3027, 3029, 5, 15, 0, 0, 3028, 3030, 5, 226, 0, 0, 3029, 3028,
		1, 0, 0, 0, 3029, 3030, 1, 0, 0, 0, 3030, 3031, 1, 0, 0, 0, 3031, 3033,
		3, 336, 168, 0, 3032, 3034, 5, 226, 0, 0, 3033, 3032, 1, 0, 0, 0, 3033,
		3034, 1, 0, 0, 0, 3034, 3036, 1, 0, 0, 0, 3035, 3027, 1, 0, 0, 0, 3036,
		3039, 1, 0, 0, 0, 3037, 3035, 1, 0, 0, 0, 3037, 3038, 1, 0, 0, 0, 3038,
		3041, 1, 0, 0, 0, 3039, 3037, 1, 0, 0, 0, 3040, 3023, 1, 0, 0, 0, 3040,
		3041, 1, 0, 0, 0, 3041, 3042, 1, 0, 0, 0, 3042, 3043, 5, 18, 0, 0, 3043,
		407, 1, 0, 0, 0, 3044, 3046, 5, 12, 0, 0, 3045, 3047, 5, 226, 0, 0, 3046,
		3045, 1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 3048, 1, 0, 0, 0, 3048,
		3080, 3, 348, 174, 0, 3049, 3051, 5, 28, 0, 0, 3050, 3052, 5, 226, 0, 0,
		3051, 3050, 1, 0, 0, 0, 3051, 3052, 1, 0, 0, 0, 3052, 3053, 1, 0, 0, 0,
		3053, 3080, 3, 348, 174, 0, 3054, 3056, 5, 29, 0, 0, 3055, 3057, 5, 226,
		0, 0, 3056, 3055, 1, 0, 0, 0, 3056, 3057, 1, 0, 0, 0, 3057, 3058, 1, 0,
		0, 0, 3058, 3080, 3, 348, 174, 0, 3059, 3061, 5, 30, 0, 0, 3060, 3062,
		5, 226, 0, 0, 3061, 3060, 1, 0, 0, 0, 3061, 3062, 1, 0, 0, 0, 3062, 3063,
		1, 0, 0, 0, 3063, 3080, 3, 348, 174, 0, 3064, 3066, 5, 31, 0, 0, 3065,
		3067, 5, 226, 0, 0, 3066, 3065, 1, 0, 0, 0, 3066, 3067, 1, 0, 0, 0, 3067,
		3068, 1, 0, 0, 0, 3068, 3080, 3, 348, 174, 0, 3069, 3071, 5, 32, 0, 0,
		3070, 3072, 5, 226, 0, 0, 3071, 3070, 1, 0, 0, 0, 3071, 3072, 1, 0, 0,
		0, 3072, 3073, 1, 0, 0, 0, 3073, 3080, 3, 348, 174, 0, 3074, 3076, 5, 33,
		0, 0, 3075, 3077, 5, 226, 0, 0, 3076, 3075, 1, 0, 0, 0, 3076, 3077, 1,
		0, 0, 0, 3077, 3078, 1, 0, 0, 0, 3078, 3080, 3, 348, 174, 0, 3079, 3044,
		1, 0, 0, 0, 3079, 3049, 1, 0, 0, 0, 3079, 3054, 1, 0, 0, 0, 3079, 3059,
		1, 0, 0, 0, 3079, 3064, 1, 0, 0, 0, 3079, 3069, 1, 0, 0, 0, 3079, 3074,
		1, 0, 0, 0, 3080, 409, 1, 0, 0, 0, 3081, 3083, 5, 20, 0, 0, 3082, 3084,
		5, 226, 0, 0, 3083, 3082, 1, 0, 0, 0, 3083, 3084, 1, 0, 0, 0, 3084, 3085,
		1, 0, 0, 0, 3085, 3087, 3, 336, 168, 0, 3086, 3088, 5, 226, 0, 0, 3087,
		3086, 1, 0, 0, 0, 3087, 3088, 1, 0, 0, 0, 3088, 3089, 1, 0, 0, 0, 3089,
		3090, 5, 21, 0, 0, 3090, 411, 1, 0, 0, 0, 3091, 3096, 3, 304, 152, 0, 3092,
		3094, 5, 226, 0, 0, 3093, 3092, 1, 0, 0, 0, 3093, 3094, 1, 0, 0, 0, 3094,
		3095, 1, 0, 0, 0, 3095, 3097, 3, 306, 153, 0, 3096, 3093, 1, 0, 0, 0, 3097,
		3098, 1, 0, 0, 0, 3098, 3096, 1, 0, 0, 0, 3098, 3099, 1, 0, 0, 0, 3099,
		413, 1, 0, 0, 0, 3100, 3105, 3, 416, 208, 0, 3101, 3103, 5, 226, 0, 0,
		3102, 3101, 1, 0, 0, 0, 3102, 3103, 1, 0, 0, 0, 3103, 3104, 1, 0, 0, 0,
		3104, 3106, 3, 294, 147, 0, 3105, 3102, 1, 0, 0, 0, 3105, 3106, 1, 0, 0,
		0, 3106, 415, 1, 0, 0, 0, 3107, 3108, 3, 436, 218, 0, 3108, 3109, 5, 226,
		0, 0, 3109, 3110, 5, 87, 0, 0, 3110, 3111, 5, 226, 0, 0, 3111, 3112, 3,
		336, 168, 0, 3112, 417, 1, 0, 0, 0, 3113, 3115, 3, 420, 210, 0, 3114, 3116,
		5, 226, 0, 0, 3115, 3114, 1, 0, 0, 0, 3115, 3116, 1, 0, 0, 0, 3116, 3117,
		1, 0, 0, 0, 3117, 3119, 5, 20, 0, 0, 3118, 3120, 5, 226, 0, 0, 3119, 3118,
		1, 0, 0, 0, 3119, 3120, 1, 0, 0, 0, 3120, 3125, 1, 0, 0, 0, 3121, 3123,
		5, 88, 0, 0, 3122, 3124, 5, 226, 0, 0, 3123, 3122, 1, 0, 0, 0, 3123, 3124,
		1, 0, 0, 0, 3124, 3126, 1, 0, 0, 0, 3125, 3121, 1, 0, 0, 0, 3125, 3126,
		1, 0, 0, 0, 3126, 3144, 1, 0, 0, 0, 3127, 3129, 3, 336, 168, 0, 3128, 3130,
		5, 226, 0, 0, 3129, 3128, 1, 0, 0, 0, 3129, 3130, 1, 0, 0, 0, 3130, 3141,
		1, 0, 0, 0, 3131, 3133, 5, 15, 0, 0, 3132, 3134, 5, 226, 0, 0, 3133, 3132,
		1, 0, 0, 0, 3133, 3134, 1, 0, 0, 0, 3134, 3135, 1, 0, 0, 0, 3135, 3137,
		3, 336, 168, 0, 3136, 3138, 5, 226, 0, 0, 3137, 3136, 1, 0, 0, 0, 3137,
		3138, 1, 0, 0, 0, 3138, 3140, 1, 0, 0, 0, 3139, 3131, 1, 0, 0, 0, 3140,
		3143, 1, 0, 0, 0, 3141, 3139, 1, 0, 0, 0, 3141, 3142, 1, 0, 0, 0, 3142,
		3145, 1, 0, 0, 0, 3143, 3141, 1, 0, 0, 0, 3144, 3127, 1, 0, 0, 0, 3144,
		3145, 1, 0, 0, 0, 3145, 3146, 1, 0, 0, 0, 3146, 3147, 5, 21, 0, 0, 3147,
		419, 1, 0, 0, 0, 3148, 3149, 3, 474, 237, 0, 3149, 3150, 3, 422, 211, 0,
		3150, 421, 1, 0, 0, 0, 3151, 3152, 7, 17, 0, 0, 3152, 423, 1, 0, 0, 0,
		3153, 3154, 3, 482, 241, 0, 3154, 425, 1, 0, 0, 0, 3155, 3157, 5, 17, 0,
		0, 3156, 3158, 5, 226, 0, 0, 3157, 3156, 1, 0, 0, 0, 3157, 3158, 1, 0,
		0, 0, 3158, 3159, 1, 0, 0, 0, 3159, 3168, 3, 414, 207, 0, 3160, 3162, 5,
		226, 0, 0, 3161, 3160, 1, 0, 0, 0, 3161, 3162, 1, 0, 0, 0, 3162, 3163,
		1, 0, 0, 0, 3163, 3165, 5, 23, 0, 0, 3164, 3166, 5, 226, 0, 0, 3165, 3164,
		1, 0, 0, 0, 3165, 3166, 1, 0, 0, 0, 3166, 3167, 1, 0, 0, 0, 3167, 3169,
		3, 336, 168, 0, 3168, 3161, 1, 0, 0, 0, 3168, 3169, 1, 0, 0, 0, 3169, 3171,
		1, 0, 0, 0, 3170, 3172, 5, 226, 0, 0, 3171, 3170, 1, 0, 0, 0, 3171, 3172,
		1, 0, 0, 0, 3172, 3173, 1, 0, 0, 0, 3173, 3174, 5, 18, 0, 0, 3174, 427,
		1, 0, 0, 0, 3175, 3177, 5, 17, 0, 0, 3176, 3178, 5, 226, 0, 0, 3177, 3176,
		1, 0, 0, 0, 3177, 3178, 1, 0, 0, 0, 3178, 3187, 1, 0, 0, 0, 3179, 3181,
		3, 436, 218, 0, 3180, 3182, 5, 226, 0, 0, 3181, 3180, 1, 0, 0, 0, 3181,
		3182, 1, 0, 0, 0, 3182, 3183, 1, 0, 0, 0, 3183, 3185, 5, 12, 0, 0, 3184,
		3186, 5, 226, 0, 0, 3185, 3184, 1, 0, 0, 0, 3185, 3186, 1, 0, 0, 0, 3186,
		3188, 1, 0, 0, 0, 3187, 3179, 1, 0, 0, 0, 3187, 3188, 1, 0, 0, 0, 3188,
		3189, 1, 0, 0, 0, 3189, 3191, 3, 412, 206, 0, 3190, 3192, 5, 226, 0, 0,
		3191, 3190, 1, 0, 0, 0, 3191, 3192, 1, 0, 0, 0, 3192, 3201, 1, 0, 0, 0,
		3193, 3195, 5, 104, 0, 0, 3194, 3196, 5, 226, 0, 0, 3195, 3194, 1, 0, 0,
		0, 3195, 3196, 1, 0, 0, 0, 3196, 3197, 1, 0, 0, 0, 3197, 3199, 3, 336,
		168, 0, 3198, 3200, 5, 226, 0, 0, 3199, 3198, 1, 0, 0, 0, 3199, 3200, 1,
		0, 0, 0, 3200, 3202, 1, 0, 0, 0, 3201, 3193, 1, 0, 0, 0, 3201, 3202, 1,
		0, 0, 0, 3202, 3203, 1, 0, 0, 0, 3203, 3205, 5, 23, 0, 0, 3204, 3206, 5,
		226, 0, 0, 3205, 3204, 1, 0, 0, 0, 3205, 3206, 1, 0, 0, 0, 3206, 3207,
		1, 0, 0, 0, 3207, 3209, 3, 336, 168, 0, 3208, 3210, 5, 226, 0, 0, 3209,
		3208, 1, 0, 0, 0, 3209, 3210, 1, 0, 0, 0, 3210, 3211, 1, 0, 0, 0, 3211,
		3212, 5, 18, 0, 0, 3212, 429, 1, 0, 0, 0, 3213, 3215, 5, 7, 0, 0, 3214,
		3216, 5, 226, 0, 0, 3215, 3214, 1, 0, 0, 0, 3215, 3216, 1, 0, 0, 0, 3216,
		3217, 1, 0, 0, 0, 3217, 3218, 3, 468, 234, 0, 3218, 431, 1, 0, 0, 0, 3219,
		3224, 5, 124, 0, 0, 3220, 3222, 5, 226, 0, 0, 3221, 3220, 1, 0, 0, 0, 3221,
		3222, 1, 0, 0, 0, 3222, 3223, 1, 0, 0, 0, 3223, 3225, 3, 434, 217, 0, 3224,
		3221, 1, 0, 0, 0, 3225, 3226, 1, 0, 0, 0, 3226, 3224, 1, 0, 0, 0, 3226,
		3227, 1, 0, 0, 0, 3227, 3242, 1, 0, 0, 0, 3228, 3230, 5, 124, 0, 0, 3229,
		3231, 5, 226, 0, 0, 3230, 3229, 1, 0, 0, 0, 3230, 3231, 1, 0, 0, 0, 3231,
		3232, 1, 0, 0, 0, 3232, 3237, 3, 336, 168, 0, 3233, 3235, 5, 226, 0, 0,
		3234, 3233, 1, 0, 0, 0, 3234, 3235, 1, 0, 0, 0, 3235, 3236, 1, 0, 0, 0,
		3236, 3238, 3, 434, 217, 0, 3237, 3234, 1, 0, 0, 0, 3238, 3239, 1, 0, 0,
		0, 3239, 3237, 1, 0, 0, 0, 3239, 3240, 1, 0, 0, 0, 3240, 3242, 1, 0, 0,
		0, 3241, 3219, 1, 0, 0, 0, 3241, 3228, 1, 0, 0, 0, 3242, 3251, 1, 0, 0,
		0, 3243, 3245, 5, 226, 0, 0, 3244, 3243, 1, 0, 0, 0, 3244, 3245, 1, 0,
		0, 0, 3245, 3246, 1, 0, 0, 0, 3246, 3248, 5, 125, 0, 0, 3247, 3249, 5,
		226, 0, 0, 3248, 3247, 1, 0, 0, 0, 3248, 3249, 1, 0, 0, 0, 3249, 3250,
		1, 0, 0, 0, 3250, 3252, 3, 336, 168, 0, 3251, 3244, 1, 0, 0, 0, 3251, 3252,
		1, 0, 0, 0, 3252, 3254, 1, 0, 0, 0, 3253, 3255, 5, 226, 0, 0, 3254, 3253,
		1, 0, 0, 0, 3254, 3255, 1, 0, 0, 0, 3255, 3256, 1, 0, 0, 0, 3256, 3257,
		5, 126, 0, 0, 3257, 433, 1, 0, 0, 0, 3258, 3260, 5, 127, 0, 0, 3259, 3261,
		5, 226, 0, 0, 3260, 3259, 1, 0, 0, 0, 3260, 3261, 1, 0, 0, 0, 3261, 3262,
		1, 0, 0, 0, 3262, 3264, 3, 336, 168, 0, 3263, 3265, 5, 226, 0, 0, 3264,
		3263, 1, 0, 0, 0, 3264, 3265, 1, 0, 0, 0, 3265, 3266, 1, 0, 0, 0, 3266,
		3268, 5, 128, 0, 0, 3267, 3269, 5, 226, 0, 0, 3268, 3267, 1, 0, 0, 0, 3268,
		3269, 1, 0, 0, 0, 3269, 3270, 1, 0, 0, 0, 3270, 3271, 3, 336, 168, 0, 3271,
		435, 1, 0, 0, 0, 3272, 3273, 3, 482, 241, 0, 3273, 437, 1, 0, 0, 0, 3274,
		3277, 3, 472, 236, 0, 3275, 3277, 3, 470, 235, 0, 3276, 3274, 1, 0, 0,
		0, 3276, 3275, 1, 0, 0, 0, 3277, 439, 1, 0, 0, 0, 3278, 3280, 5, 14, 0,
		0, 3279, 3281, 5, 226, 0, 0, 3280, 3279, 1, 0, 0, 0, 3280, 3281, 1, 0,
		0, 0, 3281, 3299, 1, 0, 0, 0, 3282, 3284, 3, 446, 223, 0, 3283, 3285, 5,
		226, 0, 0, 3284, 3283, 1, 0, 0, 0, 3284, 3285, 1, 0, 0, 0, 3285, 3296,
		1, 0, 0, 0, 3286, 3288, 5, 15, 0, 0, 3287, 3289, 5, 226, 0, 0, 3288, 3287,
		1, 0, 0, 0, 3288, 3289, 1, 0, 0, 0, 3289, 3290, 1, 0, 0, 0, 3290, 3292,
		3, 446, 223, 0, 3291, 3293, 5, 226, 0, 0, 3292, 3291, 1, 0, 0, 0, 3292,
		3293, 1, 0, 0, 0, 3293, 3295, 1, 0, 0, 0, 3294, 3286, 1, 0, 0, 0, 3295,
		3298, 1, 0, 0, 0, 3296, 3294, 1, 0, 0, 0, 3296, 3297, 1, 0, 0, 0, 3297,
		3300, 1, 0, 0, 0, 3298, 3296, 1, 0, 0, 0, 3299, 3282, 1, 0, 0, 0, 3299,
		3300, 1, 0, 0, 0, 3300, 3301, 1, 0, 0, 0, 3301, 3302, 5, 16, 0, 0, 3302,
		441, 1, 0, 0, 0, 3303, 3305, 3, 436, 218, 0, 3304, 3306, 5, 226, 0, 0,
		3305, 3304, 1, 0, 0, 0, 3305, 3306, 1, 0, 0, 0, 3306, 3307, 1, 0, 0, 0,
		3307, 3309, 5, 14, 0, 0, 3308, 3310, 5, 226, 0, 0, 3309, 3308, 1, 0, 0,
		0, 3309, 3310, 1, 0, 0, 0, 3310, 3312, 1, 0, 0, 0, 3311, 3313, 3, 444,
		222, 0, 3312, 3311, 1, 0, 0, 0, 3312, 3313, 1, 0, 0, 0, 3313, 3324, 1,
		0, 0, 0, 3314, 3316, 5, 226, 0, 0, 3315, 3314, 1, 0, 0, 0, 3315, 3316,
		1, 0, 0, 0, 3316, 3317, 1, 0, 0, 0, 3317, 3319, 5, 15, 0, 0, 3318, 3320,
		5, 226, 0, 0, 3319, 3318, 1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320, 3321,
		1, 0, 0, 0, 3321, 3323, 3, 444, 222, 0, 3322, 3315, 1, 0, 0, 0, 3323, 3326,
		1, 0, 0, 0, 3324, 3322, 1, 0, 0, 0, 3324, 3325, 1, 0, 0, 0, 3325, 3328,
		1, 0, 0, 0, 3326, 3324, 1, 0, 0, 0, 3327, 3329, 5, 226, 0, 0, 3328, 3327,
		1, 0, 0, 0, 3328, 3329, 1, 0, 0, 0, 3329, 3330, 1, 0, 0, 0, 3330, 3331,
		5, 16, 0, 0, 3331, 443, 1, 0, 0, 0, 3332, 3337, 3, 446, 223, 0, 3333, 3337,
		3, 448, 224, 0, 3334, 3337, 3, 450, 225, 0, 3335, 3337, 3, 452, 226, 0,
		3336, 3332, 1, 0, 0, 0, 3336, 3333, 1, 0, 0, 0, 3336, 3334, 1, 0, 0, 0,
		3336, 3335, 1, 0, 0, 0, 3337, 445, 1, 0, 0, 0, 3338, 3340, 3, 468, 234,
		0, 3339, 3341, 5, 226, 0, 0, 3340, 3339, 1, 0, 0, 0, 3340, 3341, 1, 0,
		0, 0, 3341, 3342, 1, 0, 0, 0, 3342, 3344, 5, 2, 0, 0, 3343, 3345, 5, 226,
		0, 0, 3344, 3343, 1, 0, 0, 0, 3344, 3345, 1, 0, 0, 0, 3345, 3346, 1, 0,
		0, 0, 3346, 3347, 3, 336, 168, 0, 3347, 447, 1, 0, 0, 0, 3348, 3349, 5,
		7, 0, 0, 3349, 3350, 3, 436, 218, 0, 3350, 449, 1, 0, 0, 0, 3351, 3352,
		3, 436, 218, 0, 3352, 451, 1, 0, 0, 0, 3353, 3354, 5, 7, 0, 0, 3354, 3355,
		5, 19, 0, 0, 3355, 453, 1, 0, 0, 0, 3356, 3359, 3, 456, 228, 0, 3357, 3359,
		3, 458, 229, 0, 3358, 3356, 1, 0, 0, 0, 3358, 3357, 1, 0, 0, 0, 3359, 455,
		1, 0, 0, 0, 3360, 3362, 5, 14, 0, 0, 3361, 3363, 5, 226, 0, 0, 3362, 3361,
		1, 0, 0, 0, 3362, 3363, 1, 0, 0, 0, 3363, 3364, 1, 0, 0, 0, 3364, 3366,
		3, 460, 230, 0, 3365, 3367, 5, 226, 0, 0, 3366, 3365, 1, 0, 0, 0, 3366,
		3367, 1, 0, 0, 0, 3367, 3368, 1, 0, 0, 0, 3368, 3369, 5, 16, 0, 0, 3369,
		457, 1, 0, 0, 0, 3370, 3371, 5, 34, 0, 0, 3371, 3372, 3, 460, 230, 0, 3372,
		459, 1, 0, 0, 0, 3373, 3376, 3, 482, 241, 0, 3374, 3376, 5, 211, 0, 0,
		3375, 3373, 1, 0, 0, 0, 3375, 3374, 1, 0, 0, 0, 3376, 461, 1, 0, 0, 0,
		3377, 3388, 3, 464, 232, 0, 3378, 3380, 5, 226, 0, 0, 3379, 3378, 1, 0,
		0, 0, 3379, 3380, 1, 0, 0, 0, 3380, 3381, 1, 0, 0, 0, 3381, 3383, 5, 15,
		0, 0, 3382, 3384, 5, 226, 0, 0, 3383, 3382, 1, 0, 0, 0, 3383, 3384, 1,
		0, 0, 0, 3384, 3385, 1, 0, 0, 0, 3385, 3387, 3, 464, 232, 0, 3386, 3379,
		1, 0, 0, 0, 3387, 3390, 1, 0, 0, 0, 3388, 3386, 1, 0, 0, 0, 3388, 3389,
		1, 0, 0, 0, 3389, 463, 1, 0, 0, 0, 3390, 3388, 1, 0, 0, 0, 3391, 3396,
		3, 398, 199, 0, 3392, 3394, 5, 226, 0, 0, 3393, 3392, 1, 0, 0, 0, 3393,
		3394, 1, 0, 0, 0, 3394, 3395, 1, 0, 0, 0, 3395, 3397, 3, 430, 215, 0, 3396,
		3393, 1, 0, 0, 0, 3397, 3398, 1, 0, 0, 0, 3398, 3396, 1, 0, 0, 0, 3398,
		3399, 1, 0, 0, 0, 3399, 465, 1, 0, 0, 0, 3400, 3411, 3, 468, 234, 0, 3401,
		3403, 5, 226, 0, 0, 3402, 3401, 1, 0, 0, 0, 3402, 3403, 1, 0, 0, 0, 3403,
		3404, 1, 0, 0, 0, 3404, 3406, 5, 15, 0, 0, 3405, 3407, 5, 226, 0, 0, 3406,
		3405, 1, 0, 0, 0, 3406, 3407, 1, 0, 0, 0, 3407, 3408, 1, 0, 0, 0, 3408,
		3410, 3, 468, 234, 0, 3409, 3402, 1, 0, 0, 0, 3410, 3413, 1, 0, 0, 0, 3411,
		3409, 1, 0, 0, 0, 3411, 3412, 1, 0, 0, 0, 3412, 467, 1, 0, 0, 0, 3413,
		3411, 1, 0, 0, 0, 3414, 3415, 3, 482, 241, 0, 3415, 469, 1, 0, 0, 0, 3416,
		3417, 7, 18, 0, 0, 3417, 471, 1, 0, 0, 0, 3418, 3419, 7, 19, 0, 0, 3419,
		473, 1, 0, 0, 0, 3420, 3421, 3, 482, 241, 0, 3421, 3422, 5, 7, 0, 0, 3422,
		3424, 1, 0, 0, 0, 3423, 3420, 1, 0, 0, 0, 3424, 3427, 1, 0, 0, 0, 3425,
		3423, 1, 0, 0, 0, 3425, 3426, 1, 0, 0, 0, 3426, 475, 1, 0, 0, 0, 3427,
		3425, 1, 0, 0, 0, 3428, 3429, 7, 20, 0, 0, 3429, 477, 1, 0, 0, 0, 3430,
		3431, 7, 21, 0, 0, 3431, 479, 1, 0, 0, 0, 3432, 3433, 7, 22, 0, 0, 3433,
		481, 1, 0, 0, 0, 3434, 3439, 3, 484, 242, 0, 3435, 3439, 5, 222, 0, 0,
		3436, 3439, 5, 225, 0, 0, 3437, 3439, 5, 213, 0, 0, 3438, 3434, 1, 0, 0,
		0, 3438, 3435, 1, 0, 0, 0, 3438, 3436, 1, 0, 0, 0, 3438, 3437, 1, 0, 0,
		0, 3439, 483, 1, 0, 0, 0, 3440, 3441, 7, 23, 0, 0, 3441, 485, 1, 0, 0,
		0, 498, 491, 495, 500, 504, 507, 512, 520, 528, 541, 545, 549, 558, 563,
		567, 570, 573, 578, 582, 589, 607, 630, 638, 640, 644, 649, 655, 661, 665,
		669, 673, 677, 684, 687, 691, 695, 701, 705, 709, 713, 717, 724, 727, 735,
		744, 749, 753, 756, 763, 771, 775, 781, 786, 792, 803, 807, 815, 818, 822,
		826, 831, 836, 842, 847, 857, 861, 866, 873, 878, 881, 897, 909, 914, 921,
		930, 936, 942, 949, 955, 962, 964, 973, 977, 984, 991, 993, 1012, 1026,
		1031, 1038, 1047, 1049, 1058, 1074, 1080, 1091, 1101, 1107, 1117, 1127,
		1130, 1177, 1224, 1239, 1247, 1267, 1276, 1280, 1285, 1288, 1297, 1301,
		1306, 1309, 1313, 1317, 1322, 1330, 1335, 1342, 1348, 1377, 1386, 1395,
		1401, 1407, 1410, 1412, 1432, 1439, 1446, 1453, 1455, 1460, 1464, 1469,
		1472, 1476, 1480, 1488, 1494, 1503, 1510, 1515, 1524, 1558, 1562, 1569,
		1575, 1631, 1635, 1639, 1643, 1651, 1655, 1660, 1664, 1678, 1682, 1687,
		1691, 1697, 1701, 1715, 1722, 1728, 1738, 1742, 1748, 1756, 1767, 1773,
		1785, 1791, 1803, 1807, 1817, 1830, 1834, 1838, 1844, 1848, 1851, 1855,
		1865, 1872, 1885, 1889, 1897, 1903, 1907, 1911, 1916, 1921, 1925, 1931,
		1935, 1941, 1945, 1951, 1955, 1959, 1963, 1967, 1971, 1976, 1983, 1987,
		1992, 1999, 2003, 2007, 2015, 2022, 2025, 2031, 2034, 2039, 2042, 2046,
		2049, 2052, 2059, 2063, 2067, 2071, 2074, 2078, 2082, 2087, 2092, 2096,
		2101, 2105, 2114, 2120, 2123, 2127, 2130, 2137, 2140, 2143, 2147, 2152,
		2156, 2164, 2168, 2173, 2178, 2182, 2200, 2204, 2209, 2222, 2226, 2228,
		2231, 2240, 2244, 2248, 2260, 2264, 2269, 2279, 2285, 2289, 2294, 2298,
		2302, 2306, 2312, 2316, 2321, 2327, 2336, 2345, 2353, 2359, 2363, 2368,
		2377, 2381, 2386, 2391, 2395, 2400, 2404, 2408, 2413, 2420, 2424, 2428,
		2430, 2434, 2436, 2440, 2442, 2448, 2454, 2457, 2460, 2466, 2471, 2475,
		2480, 2484, 2488, 2490, 2494, 2496, 2499, 2503, 2505, 2511, 2515, 2521,
		2527, 2534, 2540, 2545, 2553, 2557, 2559, 2563, 2567, 2569, 2571, 2586,
		2596, 2606, 2611, 2615, 2622, 2627, 2632, 2636, 2640, 2644, 2647, 2649,
		2654, 2658, 2662, 2666, 2670, 2674, 2677, 2679, 2684, 2688, 2693, 2698,
		2702, 2709, 2716, 2720, 2724, 2728, 2743, 2746, 2759, 2761, 2766, 2770,
		2774, 2779, 2783, 2787, 2795, 2799, 2803, 2811, 2815, 2819, 2827, 2831,
		2835, 2843, 2847, 2851, 2859, 2863, 2867, 2875, 2879, 2883, 2887, 2890,
		2893, 2901, 2905, 2909, 2913, 2917, 2921, 2925, 2929, 2933, 2941, 2945,
		2949, 2955, 2959, 2963, 2967, 2978, 2982, 2986, 3004, 3013, 3021, 3025,
		3029, 3033, 3037, 3040, 3046, 3051, 3056, 3061, 3066, 3071, 3076, 3079,
		3083, 3087, 3093, 3098, 3102, 3105, 3115, 3119, 3123, 3125, 3129, 3133,
		3137, 3141, 3144, 3157, 3161, 3165, 3168, 3171, 3177, 3181, 3185, 3187,
		3191, 3195, 3199, 3201, 3205, 3209, 3215, 3221, 3226, 3230, 3234, 3239,
		3241, 3244, 3248, 3251, 3254, 3260, 3264, 3268, 3276, 3280, 3284, 3288,
		3292, 3296, 3299, 3305, 3309, 3312, 3315, 3319, 3324, 3328, 3336, 3340,
		3344, 3358, 3362, 3366, 3375, 3379, 3383, 3388, 3393, 3398, 3402, 3406,
		3411, 3425, 3438,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CypherParserInit initializes any static state used to implement CypherParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCypherParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CypherParserInit() {
	staticData := &cypherParserStaticData
	staticData.once.Do(cypherParserInit)
}

// NewCypherParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCypherParser(input antlr.TokenStream) *CypherParser {
	CypherParserInit()
	this := new(CypherParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &cypherParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "Cypher.g4"

	return this
}

// CypherParser tokens.
const (
	CypherParserEOF                   = antlr.TokenEOF
	CypherParserT__0                  = 1
	CypherParserT__1                  = 2
	CypherParserT__2                  = 3
	CypherParserT__3                  = 4
	CypherParserT__4                  = 5
	CypherParserT__5                  = 6
	CypherParserT__6                  = 7
	CypherParserT__7                  = 8
	CypherParserT__8                  = 9
	CypherParserT__9                  = 10
	CypherParserT__10                 = 11
	CypherParserT__11                 = 12
	CypherParserT__12                 = 13
	CypherParserT__13                 = 14
	CypherParserT__14                 = 15
	CypherParserT__15                 = 16
	CypherParserT__16                 = 17
	CypherParserT__17                 = 18
	CypherParserT__18                 = 19
	CypherParserT__19                 = 20
	CypherParserT__20                 = 21
	CypherParserT__21                 = 22
	CypherParserT__22                 = 23
	CypherParserT__23                 = 24
	CypherParserT__24                 = 25
	CypherParserT__25                 = 26
	CypherParserT__26                 = 27
	CypherParserT__27                 = 28
	CypherParserT__28                 = 29
	CypherParserT__29                 = 30
	CypherParserT__30                 = 31
	CypherParserT__31                 = 32
	CypherParserT__32                 = 33
	CypherParserT__33                 = 34
	CypherParserT__34                 = 35
	CypherParserT__35                 = 36
	CypherParserT__36                 = 37
	CypherParserT__37                 = 38
	CypherParserT__38                 = 39
	CypherParserT__39                 = 40
	CypherParserT__40                 = 41
	CypherParserT__41                 = 42
	CypherParserT__42                 = 43
	CypherParserT__43                 = 44
	CypherParserT__44                 = 45
	CypherParserT__45                 = 46
	CypherParserT__46                 = 47
	CypherParserT__47                 = 48
	CypherParserT__48                 = 49
	CypherParserT__49                 = 50
	CypherParserT__50                 = 51
	CypherParserT__51                 = 52
	CypherParserT__52                 = 53
	CypherParserCYPHER                = 54
	CypherParserEXPLAIN               = 55
	CypherParserPROFILE               = 56
	CypherParserUSING                 = 57
	CypherParserPERIODIC              = 58
	CypherParserCOMMIT                = 59
	CypherParserUNION                 = 60
	CypherParserALL                   = 61
	CypherParserCREATE                = 62
	CypherParserDROP                  = 63
	CypherParserINDEX                 = 64
	CypherParserON                    = 65
	CypherParserCONSTRAINT            = 66
	CypherParserASSERT                = 67
	CypherParserIS                    = 68
	CypherParserUNIQUE                = 69
	CypherParserEXISTS                = 70
	CypherParserLOAD                  = 71
	CypherParserCSV                   = 72
	CypherParserWITH                  = 73
	CypherParserHEADERS               = 74
	CypherParserFROM                  = 75
	CypherParserAS                    = 76
	CypherParserFIELDTERMINATOR       = 77
	CypherParserOPTIONAL              = 78
	CypherParserMATCH                 = 79
	CypherParserUNWIND                = 80
	CypherParserMERGE                 = 81
	CypherParserSET                   = 82
	CypherParserDETACH                = 83
	CypherParserDELETE                = 84
	CypherParserREMOVE                = 85
	CypherParserFOREACH               = 86
	CypherParserIN                    = 87
	CypherParserDISTINCT              = 88
	CypherParserRETURN                = 89
	CypherParserORDER                 = 90
	CypherParserBY                    = 91
	CypherParserL_SKIP                = 92
	CypherParserLIMIT                 = 93
	CypherParserASCENDING             = 94
	CypherParserASC                   = 95
	CypherParserDESCENDING            = 96
	CypherParserDESC                  = 97
	CypherParserJOIN                  = 98
	CypherParserSCAN                  = 99
	CypherParserSTART                 = 100
	CypherParserNODE                  = 101
	CypherParserRELATIONSHIP          = 102
	CypherParserREL                   = 103
	CypherParserWHERE                 = 104
	CypherParserSHORTESTPATH          = 105
	CypherParserALLSHORTESTPATHS      = 106
	CypherParserOR                    = 107
	CypherParserXOR                   = 108
	CypherParserAND                   = 109
	CypherParserNOT                   = 110
	CypherParserSTARTS                = 111
	CypherParserENDS                  = 112
	CypherParserCONTAINS              = 113
	CypherParserNULL                  = 114
	CypherParserCOUNT                 = 115
	CypherParserFILTER                = 116
	CypherParserEXTRACT               = 117
	CypherParserANY                   = 118
	CypherParserNONE                  = 119
	CypherParserSINGLE                = 120
	CypherParserTRUE                  = 121
	CypherParserFALSE                 = 122
	CypherParserREDUCE                = 123
	CypherParserCASE                  = 124
	CypherParserELSE                  = 125
	CypherParserEND                   = 126
	CypherParserWHEN                  = 127
	CypherParserTHEN                  = 128
	CypherParserCALL                  = 129
	CypherParserYIELD                 = 130
	CypherParserKEY                   = 131
	CypherParserCATALOG               = 132
	CypherParserSHOW                  = 133
	CypherParserDEFAULT               = 134
	CypherParserDBMS                  = 135
	CypherParserDATABASE              = 136
	CypherParserDATABASES             = 137
	CypherParserGRAPH                 = 138
	CypherParserGRAPHS                = 139
	CypherParserREPLACE               = 140
	CypherParserIF                    = 141
	CypherParserSTOP                  = 142
	CypherParserROLE                  = 143
	CypherParserROLES                 = 144
	CypherParserUSER                  = 145
	CypherParserUSERS                 = 146
	CypherParserPOPULATED             = 147
	CypherParserPASSWORD              = 148
	CypherParserCHANGE                = 149
	CypherParserREQUIRED              = 150
	CypherParserSTATUS                = 151
	CypherParserACTIVE                = 152
	CypherParserSUSPENDED             = 153
	CypherParserALTER                 = 154
	CypherParserCURRENT               = 155
	CypherParserTO                    = 156
	CypherParserPRIVILEGES            = 157
	CypherParserGRANT                 = 158
	CypherParserDENY                  = 159
	CypherParserREVOKE                = 160
	CypherParserRELATIONSHIPS         = 161
	CypherParserNODES                 = 162
	CypherParserELEMENT               = 163
	CypherParserELEMENTS              = 164
	CypherParserCOPY                  = 165
	CypherParserOF                    = 166
	CypherParserTRAVERSE              = 167
	CypherParserREAD                  = 168
	CypherParserWRITE                 = 169
	CypherParserACCESS                = 170
	CypherParserINDEXES               = 171
	CypherParserMANAGEMENT            = 172
	CypherParserNEW                   = 173
	CypherParserLABEL                 = 174
	CypherParserLABELS                = 175
	CypherParserNAME                  = 176
	CypherParserNAMES                 = 177
	CypherParserTYPE                  = 178
	CypherParserTYPES                 = 179
	CypherParserPROPERTY              = 180
	CypherParserCONSTRAINTS           = 181
	CypherParserASSIGN                = 182
	CypherParserBTREE                 = 183
	CypherParserEXIST                 = 184
	CypherParserFOR                   = 185
	CypherParserOPTIONS               = 186
	CypherParserEXECUTE               = 187
	CypherParserDEFINED               = 188
	CypherParserFUNCTION              = 189
	CypherParserFUNCTIONS             = 190
	CypherParserBOOSTED               = 191
	CypherParserPROCEDURE             = 192
	CypherParserPROCEDURES            = 193
	CypherParserADMIN                 = 194
	CypherParserADMINISTRATOR         = 195
	CypherParserBRIEF                 = 196
	CypherParserVERBOSE               = 197
	CypherParserOUTPUT                = 198
	CypherParserBUILT                 = 199
	CypherParserEACH                  = 200
	CypherParserEXECUTABLE            = 201
	CypherParserEXISTENCE             = 202
	CypherParserFULLTEXT              = 203
	CypherParserHOME                  = 204
	CypherParserLOOKUP                = 205
	CypherParserRENAME                = 206
	CypherParserStringLiteral         = 207
	CypherParserUrlHex                = 208
	CypherParserEscapedChar           = 209
	CypherParserHexInteger            = 210
	CypherParserDecimalInteger        = 211
	CypherParserOctalInteger          = 212
	CypherParserHexLetter             = 213
	CypherParserHexDigit              = 214
	CypherParserDigit                 = 215
	CypherParserNonZeroDigit          = 216
	CypherParserNonZeroOctDigit       = 217
	CypherParserOctDigit              = 218
	CypherParserZeroDigit             = 219
	CypherParserExponentDecimalReal   = 220
	CypherParserRegularDecimalReal    = 221
	CypherParserUnescapedSymbolicName = 222
	CypherParserIdentifierStart       = 223
	CypherParserIdentifierPart        = 224
	CypherParserEscapedSymbolicName   = 225
	CypherParserSP                    = 226
	CypherParserWHITESPACE            = 227
	CypherParserComment               = 228
	CypherParserERROR_TOKEN           = 229
)

// CypherParser rules.
const (
	CypherParserRULE_cypher                                        = 0
	CypherParserRULE_cypherPart                                    = 1
	CypherParserRULE_cypherConsoleCommand                          = 2
	CypherParserRULE_cypherConsoleCommandName                      = 3
	CypherParserRULE_cypherConsoleCommandParameters                = 4
	CypherParserRULE_cypherConsoleCommandParameter                 = 5
	CypherParserRULE_arrowExpression                               = 6
	CypherParserRULE_url                                           = 7
	CypherParserRULE_uri                                           = 8
	CypherParserRULE_scheme                                        = 9
	CypherParserRULE_host                                          = 10
	CypherParserRULE_hostname                                      = 11
	CypherParserRULE_hostnumber                                    = 12
	CypherParserRULE_port                                          = 13
	CypherParserRULE_path                                          = 14
	CypherParserRULE_user                                          = 15
	CypherParserRULE_login                                         = 16
	CypherParserRULE_password                                      = 17
	CypherParserRULE_frag                                          = 18
	CypherParserRULE_urlQuery                                      = 19
	CypherParserRULE_search                                        = 20
	CypherParserRULE_searchparameter                               = 21
	CypherParserRULE_str                                           = 22
	CypherParserRULE_urlDigits                                     = 23
	CypherParserRULE_json                                          = 24
	CypherParserRULE_obj                                           = 25
	CypherParserRULE_pair                                          = 26
	CypherParserRULE_array                                         = 27
	CypherParserRULE_value                                         = 28
	CypherParserRULE_keyValueLiteral                               = 29
	CypherParserRULE_commandPath                                   = 30
	CypherParserRULE_subCommand                                    = 31
	CypherParserRULE_cypherQuery                                   = 32
	CypherParserRULE_queryOptions                                  = 33
	CypherParserRULE_anyCypherOption                               = 34
	CypherParserRULE_cypherOption                                  = 35
	CypherParserRULE_versionNumber                                 = 36
	CypherParserRULE_explain                                       = 37
	CypherParserRULE_profile                                       = 38
	CypherParserRULE_configurationOption                           = 39
	CypherParserRULE_statement                                     = 40
	CypherParserRULE_query                                         = 41
	CypherParserRULE_regularQuery                                  = 42
	CypherParserRULE_bulkImportQuery                               = 43
	CypherParserRULE_singleQuery                                   = 44
	CypherParserRULE_periodicCommitHint                            = 45
	CypherParserRULE_loadCSVQuery                                  = 46
	CypherParserRULE_union                                         = 47
	CypherParserRULE_clause                                        = 48
	CypherParserRULE_command                                       = 49
	CypherParserRULE_systemCommand                                 = 50
	CypherParserRULE_multidatabaseCommand                          = 51
	CypherParserRULE_userCommand                                   = 52
	CypherParserRULE_privilegeCommand                              = 53
	CypherParserRULE_showRoles                                     = 54
	CypherParserRULE_createRole                                    = 55
	CypherParserRULE_copyRole                                      = 56
	CypherParserRULE_dropRole                                      = 57
	CypherParserRULE_showUsers                                     = 58
	CypherParserRULE_createUser                                    = 59
	CypherParserRULE_dropUser                                      = 60
	CypherParserRULE_alterUser                                     = 61
	CypherParserRULE_showPrivileges                                = 62
	CypherParserRULE_grantPrivilege                                = 63
	CypherParserRULE_denyPrivilege                                 = 64
	CypherParserRULE_revokePrivilege                               = 65
	CypherParserRULE_revokePart                                    = 66
	CypherParserRULE_databaseScope                                 = 67
	CypherParserRULE_graphScope                                    = 68
	CypherParserRULE_roles                                         = 69
	CypherParserRULE_grantableGraphPrivileges                      = 70
	CypherParserRULE_revokeableGraphPrivileges                     = 71
	CypherParserRULE_datasbasePrivilege                            = 72
	CypherParserRULE_dbmsPrivilege                                 = 73
	CypherParserRULE_elementScope                                  = 74
	CypherParserRULE_propertiesList                                = 75
	CypherParserRULE_propertyScope                                 = 76
	CypherParserRULE_showDatabase                                  = 77
	CypherParserRULE_createDatabase                                = 78
	CypherParserRULE_dropDatabase                                  = 79
	CypherParserRULE_startDatabase                                 = 80
	CypherParserRULE_stopDatabase                                  = 81
	CypherParserRULE_ifNotExists                                   = 82
	CypherParserRULE_ifExists                                      = 83
	CypherParserRULE_orReplace                                     = 84
	CypherParserRULE_setPassword                                   = 85
	CypherParserRULE_passwordStatus                                = 86
	CypherParserRULE_setStatus                                     = 87
	CypherParserRULE_userStatus                                    = 88
	CypherParserRULE_createUniqueConstraint                        = 89
	CypherParserRULE_createNodeKeyConstraint                       = 90
	CypherParserRULE_createNodePropertyExistenceConstraint         = 91
	CypherParserRULE_createRelationshipPropertyExistenceConstraint = 92
	CypherParserRULE_createIndex                                   = 93
	CypherParserRULE_dropUniqueConstraint                          = 94
	CypherParserRULE_dropNodeKeyConstraint                         = 95
	CypherParserRULE_dropNodePropertyExistenceConstraint           = 96
	CypherParserRULE_dropRelationshipPropertyExistenceConstraint   = 97
	CypherParserRULE_dropIndex                                     = 98
	CypherParserRULE_index                                         = 99
	CypherParserRULE_uniqueConstraint                              = 100
	CypherParserRULE_nodeKeyConstraint                             = 101
	CypherParserRULE_nodePropertyExistenceConstraint               = 102
	CypherParserRULE_relationshipPropertyExistenceConstraint       = 103
	CypherParserRULE_relationshipPatternSyntax                     = 104
	CypherParserRULE_loadCSVClause                                 = 105
	CypherParserRULE_matchClause                                   = 106
	CypherParserRULE_unwindClause                                  = 107
	CypherParserRULE_mergeClause                                   = 108
	CypherParserRULE_mergeAction                                   = 109
	CypherParserRULE_createClause                                  = 110
	CypherParserRULE_createUniqueClause                            = 111
	CypherParserRULE_setClause                                     = 112
	CypherParserRULE_setItem                                       = 113
	CypherParserRULE_deleteClause                                  = 114
	CypherParserRULE_removeClause                                  = 115
	CypherParserRULE_removeItem                                    = 116
	CypherParserRULE_foreachClause                                 = 117
	CypherParserRULE_withClause                                    = 118
	CypherParserRULE_returnClause                                  = 119
	CypherParserRULE_returnBody                                    = 120
	CypherParserRULE_function                                      = 121
	CypherParserRULE_returnItems                                   = 122
	CypherParserRULE_returnItem                                    = 123
	CypherParserRULE_call                                          = 124
	CypherParserRULE_procedureInvocation                           = 125
	CypherParserRULE_procedureInvocationBody                       = 126
	CypherParserRULE_procedureArguments                            = 127
	CypherParserRULE_procedureResults                              = 128
	CypherParserRULE_procedureResult                               = 129
	CypherParserRULE_aliasedProcedureResult                        = 130
	CypherParserRULE_simpleProcedureResult                         = 131
	CypherParserRULE_procedureOutput                               = 132
	CypherParserRULE_order                                         = 133
	CypherParserRULE_skip                                          = 134
	CypherParserRULE_limit                                         = 135
	CypherParserRULE_sortItem                                      = 136
	CypherParserRULE_hint                                          = 137
	CypherParserRULE_startClause                                   = 138
	CypherParserRULE_startPoint                                    = 139
	CypherParserRULE_lookup                                        = 140
	CypherParserRULE_nodeLookup                                    = 141
	CypherParserRULE_relationshipLookup                            = 142
	CypherParserRULE_identifiedIndexLookup                         = 143
	CypherParserRULE_indexQuery                                    = 144
	CypherParserRULE_idLookup                                      = 145
	CypherParserRULE_literalIds                                    = 146
	CypherParserRULE_where                                         = 147
	CypherParserRULE_pattern                                       = 148
	CypherParserRULE_patternPart                                   = 149
	CypherParserRULE_anonymousPatternPart                          = 150
	CypherParserRULE_patternElement                                = 151
	CypherParserRULE_nodePattern                                   = 152
	CypherParserRULE_patternElementChain                           = 153
	CypherParserRULE_relationshipPattern                           = 154
	CypherParserRULE_relationshipPatternStart                      = 155
	CypherParserRULE_relationshipPatternEnd                        = 156
	CypherParserRULE_relationshipDetail                            = 157
	CypherParserRULE_properties                                    = 158
	CypherParserRULE_relType                                       = 159
	CypherParserRULE_relationshipTypes                             = 160
	CypherParserRULE_relationshipType                              = 161
	CypherParserRULE_relationshipTypeOptionalColon                 = 162
	CypherParserRULE_nodeLabels                                    = 163
	CypherParserRULE_nodeLabel                                     = 164
	CypherParserRULE_rangeLiteral                                  = 165
	CypherParserRULE_labelName                                     = 166
	CypherParserRULE_relTypeName                                   = 167
	CypherParserRULE_expression                                    = 168
	CypherParserRULE_orExpression                                  = 169
	CypherParserRULE_xorExpression                                 = 170
	CypherParserRULE_andExpression                                 = 171
	CypherParserRULE_notExpression                                 = 172
	CypherParserRULE_comparisonExpression                          = 173
	CypherParserRULE_addOrSubtractExpression                       = 174
	CypherParserRULE_multiplyDivideModuloExpression                = 175
	CypherParserRULE_powerOfExpression                             = 176
	CypherParserRULE_unaryAddOrSubtractExpression                  = 177
	CypherParserRULE_stringListNullOperatorExpression              = 178
	CypherParserRULE_propertyOrLabelsExpression                    = 179
	CypherParserRULE_filterFunction                                = 180
	CypherParserRULE_filterFunctionName                            = 181
	CypherParserRULE_existsFunction                                = 182
	CypherParserRULE_existsFunctionName                            = 183
	CypherParserRULE_allFunction                                   = 184
	CypherParserRULE_allFunctionName                               = 185
	CypherParserRULE_anyFunction                                   = 186
	CypherParserRULE_anyFunctionName                               = 187
	CypherParserRULE_noneFunction                                  = 188
	CypherParserRULE_noneFunctionName                              = 189
	CypherParserRULE_singleFunction                                = 190
	CypherParserRULE_singleFunctionName                            = 191
	CypherParserRULE_extractFunction                               = 192
	CypherParserRULE_extractFunctionName                           = 193
	CypherParserRULE_reduceFunction                                = 194
	CypherParserRULE_reduceFunctionName                            = 195
	CypherParserRULE_shortestPathPatternFunction                   = 196
	CypherParserRULE_shortestPathFunctionName                      = 197
	CypherParserRULE_allShortestPathFunctionName                   = 198
	CypherParserRULE_atom                                          = 199
	CypherParserRULE_literal                                       = 200
	CypherParserRULE_stringLiteral                                 = 201
	CypherParserRULE_booleanLiteral                                = 202
	CypherParserRULE_listLiteral                                   = 203
	CypherParserRULE_partialComparisonExpression                   = 204
	CypherParserRULE_parenthesizedExpression                       = 205
	CypherParserRULE_relationshipsPattern                          = 206
	CypherParserRULE_filterExpression                              = 207
	CypherParserRULE_idInColl                                      = 208
	CypherParserRULE_functionInvocation                            = 209
	CypherParserRULE_functionInvocationBody                        = 210
	CypherParserRULE_functionName                                  = 211
	CypherParserRULE_procedureName                                 = 212
	CypherParserRULE_listComprehension                             = 213
	CypherParserRULE_patternComprehension                          = 214
	CypherParserRULE_propertyLookup                                = 215
	CypherParserRULE_caseExpression                                = 216
	CypherParserRULE_caseAlternatives                              = 217
	CypherParserRULE_variable                                      = 218
	CypherParserRULE_numberLiteral                                 = 219
	CypherParserRULE_mapLiteral                                    = 220
	CypherParserRULE_mapProjection                                 = 221
	CypherParserRULE_mapProjectionVariants                         = 222
	CypherParserRULE_literalEntry                                  = 223
	CypherParserRULE_propertySelector                              = 224
	CypherParserRULE_variableSelector                              = 225
	CypherParserRULE_allPropertiesSelector                         = 226
	CypherParserRULE_parameter                                     = 227
	CypherParserRULE_legacyParameter                               = 228
	CypherParserRULE_dollarParameter                               = 229
	CypherParserRULE_parameterName                                 = 230
	CypherParserRULE_propertyExpressions                           = 231
	CypherParserRULE_propertyExpression                            = 232
	CypherParserRULE_propertyKeys                                  = 233
	CypherParserRULE_propertyKeyName                               = 234
	CypherParserRULE_integerLiteral                                = 235
	CypherParserRULE_doubleLiteral                                 = 236
	CypherParserRULE_namespace                                     = 237
	CypherParserRULE_leftArrowHead                                 = 238
	CypherParserRULE_rightArrowHead                                = 239
	CypherParserRULE_dash                                          = 240
	CypherParserRULE_symbolicName                                  = 241
	CypherParserRULE_keyword                                       = 242
)

// ICypherContext is an interface to support dynamic dispatch.
type ICypherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherContext differentiates from other interfaces.
	IsCypherContext()
}

type CypherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherContext() *CypherContext {
	var p = new(CypherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypher
	return p
}

func (*CypherContext) IsCypherContext() {}

func NewCypherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherContext {
	var p = new(CypherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypher

	return p
}

func (s *CypherContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherContext) AllCypherPart() []ICypherPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICypherPartContext); ok {
			len++
		}
	}

	tst := make([]ICypherPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICypherPartContext); ok {
			tst[i] = t.(ICypherPartContext)
			i++
		}
	}

	return tst
}

func (s *CypherContext) CypherPart(i int) ICypherPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICypherPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICypherPartContext)
}

func (s *CypherContext) EOF() antlr.TerminalNode {
	return s.GetToken(CypherParserEOF, 0)
}

func (s *CypherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypher(s)
	}
}

func (s *CypherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypher(s)
	}
}

func (p *CypherParser) Cypher() (localctx ICypherContext) {
	this := p
	_ = this

	localctx = NewCypherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CypherParserRULE_cypher)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(486)
		p.CypherPart()
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(487)
				p.Match(CypherParserT__0)
			}
			{
				p.SetState(488)
				p.CypherPart()
			}

		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__0 {
		{
			p.SetState(494)
			p.Match(CypherParserT__0)
		}

	}
	{
		p.SetState(497)
		p.Match(CypherParserEOF)
	}

	return localctx
}

// ICypherPartContext is an interface to support dynamic dispatch.
type ICypherPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherPartContext differentiates from other interfaces.
	IsCypherPartContext()
}

type CypherPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherPartContext() *CypherPartContext {
	var p = new(CypherPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypherPart
	return p
}

func (*CypherPartContext) IsCypherPartContext() {}

func NewCypherPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherPartContext {
	var p = new(CypherPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypherPart

	return p
}

func (s *CypherPartContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherPartContext) CypherQuery() ICypherQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICypherQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICypherQueryContext)
}

func (s *CypherPartContext) CypherConsoleCommand() ICypherConsoleCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICypherConsoleCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICypherConsoleCommandContext)
}

func (s *CypherPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CypherPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CypherPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypherPart(s)
	}
}

func (s *CypherPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypherPart(s)
	}
}

func (p *CypherParser) CypherPart() (localctx ICypherPartContext) {
	this := p
	_ = this

	localctx = NewCypherPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CypherParserRULE_cypherPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(499)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserCREATE, CypherParserDROP, CypherParserLOAD, CypherParserWITH, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserRETURN, CypherParserSTART, CypherParserCALL, CypherParserCATALOG, CypherParserSHOW, CypherParserSTOP, CypherParserALTER, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE:
		{
			p.SetState(502)
			p.CypherQuery()
		}

	case CypherParserT__1:
		{
			p.SetState(503)
			p.CypherConsoleCommand()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(506)
			p.Match(CypherParserSP)
		}

	}

	return localctx
}

// ICypherConsoleCommandContext is an interface to support dynamic dispatch.
type ICypherConsoleCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherConsoleCommandContext differentiates from other interfaces.
	IsCypherConsoleCommandContext()
}

type CypherConsoleCommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherConsoleCommandContext() *CypherConsoleCommandContext {
	var p = new(CypherConsoleCommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypherConsoleCommand
	return p
}

func (*CypherConsoleCommandContext) IsCypherConsoleCommandContext() {}

func NewCypherConsoleCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherConsoleCommandContext {
	var p = new(CypherConsoleCommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypherConsoleCommand

	return p
}

func (s *CypherConsoleCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherConsoleCommandContext) CypherConsoleCommandName() ICypherConsoleCommandNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICypherConsoleCommandNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICypherConsoleCommandNameContext)
}

func (s *CypherConsoleCommandContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CypherConsoleCommandContext) CypherConsoleCommandParameters() ICypherConsoleCommandParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICypherConsoleCommandParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICypherConsoleCommandParametersContext)
}

func (s *CypherConsoleCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherConsoleCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherConsoleCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypherConsoleCommand(s)
	}
}

func (s *CypherConsoleCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypherConsoleCommand(s)
	}
}

func (p *CypherParser) CypherConsoleCommand() (localctx ICypherConsoleCommandContext) {
	this := p
	_ = this

	localctx = NewCypherConsoleCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CypherParserRULE_cypherConsoleCommand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.CypherConsoleCommandName()
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(510)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(511)
			p.CypherConsoleCommandParameters()
		}

	}

	return localctx
}

// ICypherConsoleCommandNameContext is an interface to support dynamic dispatch.
type ICypherConsoleCommandNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherConsoleCommandNameContext differentiates from other interfaces.
	IsCypherConsoleCommandNameContext()
}

type CypherConsoleCommandNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherConsoleCommandNameContext() *CypherConsoleCommandNameContext {
	var p = new(CypherConsoleCommandNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypherConsoleCommandName
	return p
}

func (*CypherConsoleCommandNameContext) IsCypherConsoleCommandNameContext() {}

func NewCypherConsoleCommandNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherConsoleCommandNameContext {
	var p = new(CypherConsoleCommandNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypherConsoleCommandName

	return p
}

func (s *CypherConsoleCommandNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherConsoleCommandNameContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *CypherConsoleCommandNameContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *CypherConsoleCommandNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherConsoleCommandNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherConsoleCommandNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypherConsoleCommandName(s)
	}
}

func (s *CypherConsoleCommandNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypherConsoleCommandName(s)
	}
}

func (p *CypherParser) CypherConsoleCommandName() (localctx ICypherConsoleCommandNameContext) {
	this := p
	_ = this

	localctx = NewCypherConsoleCommandNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CypherParserRULE_cypherConsoleCommandName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(514)
		p.Match(CypherParserT__1)
	}
	{
		p.SetState(515)
		p.SymbolicName()
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__2 {
		{
			p.SetState(516)
			p.Match(CypherParserT__2)
		}
		{
			p.SetState(517)
			p.SymbolicName()
		}

		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICypherConsoleCommandParametersContext is an interface to support dynamic dispatch.
type ICypherConsoleCommandParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherConsoleCommandParametersContext differentiates from other interfaces.
	IsCypherConsoleCommandParametersContext()
}

type CypherConsoleCommandParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherConsoleCommandParametersContext() *CypherConsoleCommandParametersContext {
	var p = new(CypherConsoleCommandParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypherConsoleCommandParameters
	return p
}

func (*CypherConsoleCommandParametersContext) IsCypherConsoleCommandParametersContext() {}

func NewCypherConsoleCommandParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherConsoleCommandParametersContext {
	var p = new(CypherConsoleCommandParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypherConsoleCommandParameters

	return p
}

func (s *CypherConsoleCommandParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherConsoleCommandParametersContext) AllCypherConsoleCommandParameter() []ICypherConsoleCommandParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICypherConsoleCommandParameterContext); ok {
			len++
		}
	}

	tst := make([]ICypherConsoleCommandParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICypherConsoleCommandParameterContext); ok {
			tst[i] = t.(ICypherConsoleCommandParameterContext)
			i++
		}
	}

	return tst
}

func (s *CypherConsoleCommandParametersContext) CypherConsoleCommandParameter(i int) ICypherConsoleCommandParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICypherConsoleCommandParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICypherConsoleCommandParameterContext)
}

func (s *CypherConsoleCommandParametersContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CypherConsoleCommandParametersContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CypherConsoleCommandParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherConsoleCommandParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherConsoleCommandParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypherConsoleCommandParameters(s)
	}
}

func (s *CypherConsoleCommandParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypherConsoleCommandParameters(s)
	}
}

func (p *CypherParser) CypherConsoleCommandParameters() (localctx ICypherConsoleCommandParametersContext) {
	this := p
	_ = this

	localctx = NewCypherConsoleCommandParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CypherParserRULE_cypherConsoleCommandParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.CypherConsoleCommandParameter()
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(524)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(525)
				p.CypherConsoleCommandParameter()
			}

		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
	}

	return localctx
}

// ICypherConsoleCommandParameterContext is an interface to support dynamic dispatch.
type ICypherConsoleCommandParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherConsoleCommandParameterContext differentiates from other interfaces.
	IsCypherConsoleCommandParameterContext()
}

type CypherConsoleCommandParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherConsoleCommandParameterContext() *CypherConsoleCommandParameterContext {
	var p = new(CypherConsoleCommandParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypherConsoleCommandParameter
	return p
}

func (*CypherConsoleCommandParameterContext) IsCypherConsoleCommandParameterContext() {}

func NewCypherConsoleCommandParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherConsoleCommandParameterContext {
	var p = new(CypherConsoleCommandParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypherConsoleCommandParameter

	return p
}

func (s *CypherConsoleCommandParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherConsoleCommandParameterContext) Url() IUrlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUrlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUrlContext)
}

func (s *CypherConsoleCommandParameterContext) Json() IJsonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonContext)
}

func (s *CypherConsoleCommandParameterContext) ArrowExpression() IArrowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowExpressionContext)
}

func (s *CypherConsoleCommandParameterContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *CypherConsoleCommandParameterContext) KeyValueLiteral() IKeyValueLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyValueLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyValueLiteralContext)
}

func (s *CypherConsoleCommandParameterContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CypherConsoleCommandParameterContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *CypherConsoleCommandParameterContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *CypherConsoleCommandParameterContext) SubCommand() ISubCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubCommandContext)
}

func (s *CypherConsoleCommandParameterContext) CommandPath() ICommandPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandPathContext)
}

func (s *CypherConsoleCommandParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherConsoleCommandParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherConsoleCommandParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypherConsoleCommandParameter(s)
	}
}

func (s *CypherConsoleCommandParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypherConsoleCommandParameter(s)
	}
}

func (p *CypherParser) CypherConsoleCommandParameter() (localctx ICypherConsoleCommandParameterContext) {
	this := p
	_ = this

	localctx = NewCypherConsoleCommandParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CypherParserRULE_cypherConsoleCommandParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(531)
			p.Url()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(532)
			p.Json()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(533)
			p.ArrowExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(534)
			p.MapLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(535)
			p.KeyValueLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(536)
			p.StringLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(537)
			p.NumberLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(538)
			p.BooleanLiteral()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(539)
			p.SubCommand()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(540)
			p.CommandPath()
		}

	}

	return localctx
}

// IArrowExpressionContext is an interface to support dynamic dispatch.
type IArrowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowExpressionContext differentiates from other interfaces.
	IsArrowExpressionContext()
}

type ArrowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowExpressionContext() *ArrowExpressionContext {
	var p = new(ArrowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_arrowExpression
	return p
}

func (*ArrowExpressionContext) IsArrowExpressionContext() {}

func NewArrowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowExpressionContext {
	var p = new(ArrowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_arrowExpression

	return p
}

func (s *ArrowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowExpressionContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ArrowExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrowExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ArrowExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ArrowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitArrowExpression(s)
	}
}

func (p *CypherParser) ArrowExpression() (localctx IArrowExpressionContext) {
	this := p
	_ = this

	localctx = NewArrowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CypherParserRULE_arrowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.SymbolicName()
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(544)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(547)
		p.Match(CypherParserT__3)
	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(548)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(551)
		p.Expression()
	}

	return localctx
}

// IUrlContext is an interface to support dynamic dispatch.
type IUrlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUrlContext differentiates from other interfaces.
	IsUrlContext()
}

type UrlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUrlContext() *UrlContext {
	var p = new(UrlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_url
	return p
}

func (*UrlContext) IsUrlContext() {}

func NewUrlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UrlContext {
	var p = new(UrlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_url

	return p
}

func (s *UrlContext) GetParser() antlr.Parser { return s.parser }

func (s *UrlContext) Uri() IUriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUriContext)
}

func (s *UrlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UrlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UrlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUrl(s)
	}
}

func (s *UrlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUrl(s)
	}
}

func (p *CypherParser) Url() (localctx IUrlContext) {
	this := p
	_ = this

	localctx = NewUrlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CypherParserRULE_url)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Uri()
	}

	return localctx
}

// IUriContext is an interface to support dynamic dispatch.
type IUriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUriContext differentiates from other interfaces.
	IsUriContext()
}

type UriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUriContext() *UriContext {
	var p = new(UriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_uri
	return p
}

func (*UriContext) IsUriContext() {}

func NewUriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UriContext {
	var p = new(UriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_uri

	return p
}

func (s *UriContext) GetParser() antlr.Parser { return s.parser }

func (s *UriContext) Scheme() ISchemeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemeContext)
}

func (s *UriContext) Host() IHostContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostContext)
}

func (s *UriContext) Login() ILoginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoginContext)
}

func (s *UriContext) Port() IPortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *UriContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *UriContext) UrlQuery() IUrlQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUrlQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUrlQueryContext)
}

func (s *UriContext) Frag() IFragContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFragContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFragContext)
}

func (s *UriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUri(s)
	}
}

func (s *UriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUri(s)
	}
}

func (p *CypherParser) Uri() (localctx IUriContext) {
	this := p
	_ = this

	localctx = NewUriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CypherParserRULE_uri)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(555)
		p.Scheme()
	}
	{
		p.SetState(556)
		p.Match(CypherParserT__4)
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(557)
			p.Login()
		}

	}
	{
		p.SetState(560)
		p.Host()
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__1 {
		{
			p.SetState(561)
			p.Match(CypherParserT__1)
		}
		{
			p.SetState(562)
			p.Port()
		}

	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__5 {
		{
			p.SetState(565)
			p.Match(CypherParserT__5)
		}
		{
			p.SetState(566)
			p.Path()
		}

	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__9 {
		{
			p.SetState(569)
			p.UrlQuery()
		}

	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__8 {
		{
			p.SetState(572)
			p.Frag()
		}

	}

	return localctx
}

// ISchemeContext is an interface to support dynamic dispatch.
type ISchemeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemeContext differentiates from other interfaces.
	IsSchemeContext()
}

type SchemeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemeContext() *SchemeContext {
	var p = new(SchemeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_scheme
	return p
}

func (*SchemeContext) IsSchemeContext() {}

func NewSchemeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemeContext {
	var p = new(SchemeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_scheme

	return p
}

func (s *SchemeContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemeContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *SchemeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterScheme(s)
	}
}

func (s *SchemeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitScheme(s)
	}
}

func (p *CypherParser) Scheme() (localctx ISchemeContext) {
	this := p
	_ = this

	localctx = NewSchemeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CypherParserRULE_scheme)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(575)
		p.Str()
	}

	return localctx
}

// IHostContext is an interface to support dynamic dispatch.
type IHostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHostContext differentiates from other interfaces.
	IsHostContext()
}

type HostContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostContext() *HostContext {
	var p = new(HostContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_host
	return p
}

func (*HostContext) IsHostContext() {}

func NewHostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostContext {
	var p = new(HostContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_host

	return p
}

func (s *HostContext) GetParser() antlr.Parser { return s.parser }

func (s *HostContext) Hostname() IHostnameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostnameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostnameContext)
}

func (s *HostContext) Hostnumber() IHostnumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostnumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostnumberContext)
}

func (s *HostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterHost(s)
	}
}

func (s *HostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitHost(s)
	}
}

func (p *CypherParser) Host() (localctx IHostContext) {
	this := p
	_ = this

	localctx = NewHostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CypherParserRULE_host)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__5 {
		{
			p.SetState(577)
			p.Match(CypherParserT__5)
		}

	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		{
			p.SetState(580)
			p.Hostname()
		}

	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger:
		{
			p.SetState(581)
			p.Hostnumber()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHostnameContext is an interface to support dynamic dispatch.
type IHostnameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHostnameContext differentiates from other interfaces.
	IsHostnameContext()
}

type HostnameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostnameContext() *HostnameContext {
	var p = new(HostnameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_hostname
	return p
}

func (*HostnameContext) IsHostnameContext() {}

func NewHostnameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostnameContext {
	var p = new(HostnameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_hostname

	return p
}

func (s *HostnameContext) GetParser() antlr.Parser { return s.parser }

func (s *HostnameContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *HostnameContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *HostnameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostnameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HostnameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterHostname(s)
	}
}

func (s *HostnameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitHostname(s)
	}
}

func (p *CypherParser) Hostname() (localctx IHostnameContext) {
	this := p
	_ = this

	localctx = NewHostnameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CypherParserRULE_hostname)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Str()
	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__6 {
		{
			p.SetState(585)
			p.Match(CypherParserT__6)
		}
		{
			p.SetState(586)
			p.Str()
		}

		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHostnumberContext is an interface to support dynamic dispatch.
type IHostnumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHostnumberContext differentiates from other interfaces.
	IsHostnumberContext()
}

type HostnumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostnumberContext() *HostnumberContext {
	var p = new(HostnumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_hostnumber
	return p
}

func (*HostnumberContext) IsHostnumberContext() {}

func NewHostnumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostnumberContext {
	var p = new(HostnumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_hostnumber

	return p
}

func (s *HostnumberContext) GetParser() antlr.Parser { return s.parser }

func (s *HostnumberContext) AllUrlDigits() []IUrlDigitsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUrlDigitsContext); ok {
			len++
		}
	}

	tst := make([]IUrlDigitsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUrlDigitsContext); ok {
			tst[i] = t.(IUrlDigitsContext)
			i++
		}
	}

	return tst
}

func (s *HostnumberContext) UrlDigits(i int) IUrlDigitsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUrlDigitsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUrlDigitsContext)
}

func (s *HostnumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostnumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HostnumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterHostnumber(s)
	}
}

func (s *HostnumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitHostnumber(s)
	}
}

func (p *CypherParser) Hostnumber() (localctx IHostnumberContext) {
	this := p
	_ = this

	localctx = NewHostnumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CypherParserRULE_hostnumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.UrlDigits()
	}
	{
		p.SetState(593)
		p.Match(CypherParserT__6)
	}
	{
		p.SetState(594)
		p.UrlDigits()
	}
	{
		p.SetState(595)
		p.Match(CypherParserT__6)
	}
	{
		p.SetState(596)
		p.UrlDigits()
	}
	{
		p.SetState(597)
		p.Match(CypherParserT__6)
	}
	{
		p.SetState(598)
		p.UrlDigits()
	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) UrlDigits() IUrlDigitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUrlDigitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUrlDigitsContext)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *CypherParser) Port() (localctx IPortContext) {
	this := p
	_ = this

	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CypherParserRULE_port)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.UrlDigits()
	}

	return localctx
}

// IPathContext is an interface to support dynamic dispatch.
type IPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPathContext differentiates from other interfaces.
	IsPathContext()
}

type PathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathContext() *PathContext {
	var p = new(PathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_path
	return p
}

func (*PathContext) IsPathContext() {}

func NewPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathContext {
	var p = new(PathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_path

	return p
}

func (s *PathContext) GetParser() antlr.Parser { return s.parser }

func (s *PathContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *PathContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *PathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPath(s)
	}
}

func (s *PathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPath(s)
	}
}

func (p *CypherParser) Path() (localctx IPathContext) {
	this := p
	_ = this

	localctx = NewPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CypherParserRULE_path)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Str()
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__5 {
		{
			p.SetState(603)
			p.Match(CypherParserT__5)
		}
		{
			p.SetState(604)
			p.Str()
		}

		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_user
	return p
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUser(s)
	}
}

func (s *UserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUser(s)
	}
}

func (p *CypherParser) User() (localctx IUserContext) {
	this := p
	_ = this

	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CypherParserRULE_user)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Str()
	}

	return localctx
}

// ILoginContext is an interface to support dynamic dispatch.
type ILoginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoginContext differentiates from other interfaces.
	IsLoginContext()
}

type LoginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoginContext() *LoginContext {
	var p = new(LoginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_login
	return p
}

func (*LoginContext) IsLoginContext() {}

func NewLoginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoginContext {
	var p = new(LoginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_login

	return p
}

func (s *LoginContext) GetParser() antlr.Parser { return s.parser }

func (s *LoginContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *LoginContext) Password() IPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordContext)
}

func (s *LoginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLogin(s)
	}
}

func (s *LoginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLogin(s)
	}
}

func (p *CypherParser) Login() (localctx ILoginContext) {
	this := p
	_ = this

	localctx = NewLoginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CypherParserRULE_login)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.User()
	}
	{
		p.SetState(613)
		p.Match(CypherParserT__1)
	}
	{
		p.SetState(614)
		p.Password()
	}
	{
		p.SetState(615)
		p.Match(CypherParserT__7)
	}

	return localctx
}

// IPasswordContext is an interface to support dynamic dispatch.
type IPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPasswordContext differentiates from other interfaces.
	IsPasswordContext()
}

type PasswordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordContext() *PasswordContext {
	var p = new(PasswordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_password
	return p
}

func (*PasswordContext) IsPasswordContext() {}

func NewPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordContext {
	var p = new(PasswordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_password

	return p
}

func (s *PasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *PasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPassword(s)
	}
}

func (s *PasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPassword(s)
	}
}

func (p *CypherParser) Password() (localctx IPasswordContext) {
	this := p
	_ = this

	localctx = NewPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CypherParserRULE_password)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Str()
	}

	return localctx
}

// IFragContext is an interface to support dynamic dispatch.
type IFragContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFragContext differentiates from other interfaces.
	IsFragContext()
}

type FragContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFragContext() *FragContext {
	var p = new(FragContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_frag
	return p
}

func (*FragContext) IsFragContext() {}

func NewFragContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FragContext {
	var p = new(FragContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_frag

	return p
}

func (s *FragContext) GetParser() antlr.Parser { return s.parser }

func (s *FragContext) Str() IStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *FragContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FragContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FragContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFrag(s)
	}
}

func (s *FragContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFrag(s)
	}
}

func (p *CypherParser) Frag() (localctx IFragContext) {
	this := p
	_ = this

	localctx = NewFragContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CypherParserRULE_frag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.Match(CypherParserT__8)
	}
	{
		p.SetState(620)
		p.Str()
	}

	return localctx
}

// IUrlQueryContext is an interface to support dynamic dispatch.
type IUrlQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUrlQueryContext differentiates from other interfaces.
	IsUrlQueryContext()
}

type UrlQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUrlQueryContext() *UrlQueryContext {
	var p = new(UrlQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_urlQuery
	return p
}

func (*UrlQueryContext) IsUrlQueryContext() {}

func NewUrlQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UrlQueryContext {
	var p = new(UrlQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_urlQuery

	return p
}

func (s *UrlQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *UrlQueryContext) Search() ISearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchContext)
}

func (s *UrlQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UrlQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UrlQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUrlQuery(s)
	}
}

func (s *UrlQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUrlQuery(s)
	}
}

func (p *CypherParser) UrlQuery() (localctx IUrlQueryContext) {
	this := p
	_ = this

	localctx = NewUrlQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CypherParserRULE_urlQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Match(CypherParserT__9)
	}
	{
		p.SetState(623)
		p.Search()
	}

	return localctx
}

// ISearchContext is an interface to support dynamic dispatch.
type ISearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchContext differentiates from other interfaces.
	IsSearchContext()
}

type SearchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchContext() *SearchContext {
	var p = new(SearchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_search
	return p
}

func (*SearchContext) IsSearchContext() {}

func NewSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchContext {
	var p = new(SearchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_search

	return p
}

func (s *SearchContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchContext) AllSearchparameter() []ISearchparameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISearchparameterContext); ok {
			len++
		}
	}

	tst := make([]ISearchparameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISearchparameterContext); ok {
			tst[i] = t.(ISearchparameterContext)
			i++
		}
	}

	return tst
}

func (s *SearchContext) Searchparameter(i int) ISearchparameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchparameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchparameterContext)
}

func (s *SearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSearch(s)
	}
}

func (s *SearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSearch(s)
	}
}

func (p *CypherParser) Search() (localctx ISearchContext) {
	this := p
	_ = this

	localctx = NewSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CypherParserRULE_search)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Searchparameter()
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__10 {
		{
			p.SetState(626)
			p.Match(CypherParserT__10)
		}
		{
			p.SetState(627)
			p.Searchparameter()
		}

		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISearchparameterContext is an interface to support dynamic dispatch.
type ISearchparameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchparameterContext differentiates from other interfaces.
	IsSearchparameterContext()
}

type SearchparameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchparameterContext() *SearchparameterContext {
	var p = new(SearchparameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_searchparameter
	return p
}

func (*SearchparameterContext) IsSearchparameterContext() {}

func NewSearchparameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchparameterContext {
	var p = new(SearchparameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_searchparameter

	return p
}

func (s *SearchparameterContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchparameterContext) AllStr() []IStrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStrContext); ok {
			len++
		}
	}

	tst := make([]IStrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStrContext); ok {
			tst[i] = t.(IStrContext)
			i++
		}
	}

	return tst
}

func (s *SearchparameterContext) Str(i int) IStrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *SearchparameterContext) UrlDigits() IUrlDigitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUrlDigitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUrlDigitsContext)
}

func (s *SearchparameterContext) UrlHex() antlr.TerminalNode {
	return s.GetToken(CypherParserUrlHex, 0)
}

func (s *SearchparameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchparameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchparameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSearchparameter(s)
	}
}

func (s *SearchparameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSearchparameter(s)
	}
}

func (p *CypherParser) Searchparameter() (localctx ISearchparameterContext) {
	this := p
	_ = this

	localctx = NewSearchparameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CypherParserRULE_searchparameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Str()
	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__11 {
		{
			p.SetState(634)
			p.Match(CypherParserT__11)
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
			{
				p.SetState(635)
				p.Str()
			}

		case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger:
			{
				p.SetState(636)
				p.UrlDigits()
			}

		case CypherParserUrlHex:
			{
				p.SetState(637)
				p.Match(CypherParserUrlHex)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IStrContext is an interface to support dynamic dispatch.
type IStrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrContext differentiates from other interfaces.
	IsStrContext()
}

type StrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrContext() *StrContext {
	var p = new(StrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_str
	return p
}

func (*StrContext) IsStrContext() {}

func NewStrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrContext {
	var p = new(StrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_str

	return p
}

func (s *StrContext) GetParser() antlr.Parser { return s.parser }

func (s *StrContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *StrContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *StrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStr(s)
	}
}

func (s *StrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStr(s)
	}
}

func (p *CypherParser) Str() (localctx IStrContext) {
	this := p
	_ = this

	localctx = NewStrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CypherParserRULE_str)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.SymbolicName()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(644)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserT__6 || _la == CypherParserT__12 {
				{
					p.SetState(643)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CypherParserT__6 || _la == CypherParserT__12) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(646)
				p.SymbolicName()
			}

		}
		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}

	return localctx
}

// IUrlDigitsContext is an interface to support dynamic dispatch.
type IUrlDigitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUrlDigitsContext differentiates from other interfaces.
	IsUrlDigitsContext()
}

type UrlDigitsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUrlDigitsContext() *UrlDigitsContext {
	var p = new(UrlDigitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_urlDigits
	return p
}

func (*UrlDigitsContext) IsUrlDigitsContext() {}

func NewUrlDigitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UrlDigitsContext {
	var p = new(UrlDigitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_urlDigits

	return p
}

func (s *UrlDigitsContext) GetParser() antlr.Parser { return s.parser }

func (s *UrlDigitsContext) AllIntegerLiteral() []IIntegerLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			len++
		}
	}

	tst := make([]IIntegerLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntegerLiteralContext); ok {
			tst[i] = t.(IIntegerLiteralContext)
			i++
		}
	}

	return tst
}

func (s *UrlDigitsContext) IntegerLiteral(i int) IIntegerLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *UrlDigitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UrlDigitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UrlDigitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUrlDigits(s)
	}
}

func (s *UrlDigitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUrlDigits(s)
	}
}

func (p *CypherParser) UrlDigits() (localctx IUrlDigitsContext) {
	this := p
	_ = this

	localctx = NewUrlDigitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CypherParserRULE_urlDigits)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-210)&-(0x1f+1)) == 0 && ((1<<uint((_la-210)))&((1<<(CypherParserHexInteger-210))|(1<<(CypherParserDecimalInteger-210))|(1<<(CypherParserOctalInteger-210)))) != 0) {
		{
			p.SetState(652)
			p.IntegerLiteral()
		}

		p.SetState(655)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IJsonContext is an interface to support dynamic dispatch.
type IJsonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJsonContext differentiates from other interfaces.
	IsJsonContext()
}

type JsonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonContext() *JsonContext {
	var p = new(JsonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_json
	return p
}

func (*JsonContext) IsJsonContext() {}

func NewJsonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonContext {
	var p = new(JsonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_json

	return p
}

func (s *JsonContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *JsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterJson(s)
	}
}

func (s *JsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitJson(s)
	}
}

func (p *CypherParser) Json() (localctx IJsonContext) {
	this := p
	_ = this

	localctx = NewJsonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CypherParserRULE_json)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Value()
	}

	return localctx
}

// IObjContext is an interface to support dynamic dispatch.
type IObjContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjContext differentiates from other interfaces.
	IsObjContext()
}

type ObjContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjContext() *ObjContext {
	var p = new(ObjContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_obj
	return p
}

func (*ObjContext) IsObjContext() {}

func NewObjContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjContext {
	var p = new(ObjContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_obj

	return p
}

func (s *ObjContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjContext) AllPair() []IPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPairContext); ok {
			len++
		}
	}

	tst := make([]IPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPairContext); ok {
			tst[i] = t.(IPairContext)
			i++
		}
	}

	return tst
}

func (s *ObjContext) Pair(i int) IPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPairContext)
}

func (s *ObjContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ObjContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterObj(s)
	}
}

func (s *ObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitObj(s)
	}
}

func (p *CypherParser) Obj() (localctx IObjContext) {
	this := p
	_ = this

	localctx = NewObjContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CypherParserRULE_obj)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(659)
			p.Match(CypherParserT__13)
		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(660)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(663)
			p.Pair()
		}
		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(664)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__14 {
			{
				p.SetState(667)
				p.Match(CypherParserT__14)
			}
			p.SetState(669)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(668)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(671)
				p.Pair()
			}
			p.SetState(673)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(672)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(679)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(680)
			p.Match(CypherParserT__15)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(682)
			p.Match(CypherParserT__13)
		}
		p.SetState(684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(683)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(686)
			p.Match(CypherParserT__15)
		}

	}

	return localctx
}

// IPairContext is an interface to support dynamic dispatch.
type IPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPairContext differentiates from other interfaces.
	IsPairContext()
}

type PairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPairContext() *PairContext {
	var p = new(PairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_pair
	return p
}

func (*PairContext) IsPairContext() {}

func NewPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PairContext {
	var p = new(PairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_pair

	return p
}

func (s *PairContext) GetParser() antlr.Parser { return s.parser }

func (s *PairContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PairContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *PairContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PairContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPair(s)
	}
}

func (s *PairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPair(s)
	}
}

func (p *CypherParser) Pair() (localctx IPairContext) {
	this := p
	_ = this

	localctx = NewPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CypherParserRULE_pair)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(689)
		p.StringLiteral()
	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(690)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(693)
		p.Match(CypherParserT__1)
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(694)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(697)
		p.Value()
	}

	return localctx
}

// IArrayContext is an interface to support dynamic dispatch.
type IArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayContext differentiates from other interfaces.
	IsArrayContext()
}

type ArrayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayContext() *ArrayContext {
	var p = new(ArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_array
	return p
}

func (*ArrayContext) IsArrayContext() {}

func NewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayContext {
	var p = new(ArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_array

	return p
}

func (s *ArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ArrayContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ArrayContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ArrayContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterArray(s)
	}
}

func (s *ArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitArray(s)
	}
}

func (p *CypherParser) Array() (localctx IArrayContext) {
	this := p
	_ = this

	localctx = NewArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CypherParserRULE_array)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(699)
			p.Match(CypherParserT__16)
		}
		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(700)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(703)
			p.Value()
		}
		p.SetState(705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(704)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__14 {
			{
				p.SetState(707)
				p.Match(CypherParserT__14)
			}
			p.SetState(709)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(708)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(711)
				p.Value()
			}
			p.SetState(713)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(712)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(719)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(720)
			p.Match(CypherParserT__17)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(722)
			p.Match(CypherParserT__16)
		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(723)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(726)
			p.Match(CypherParserT__17)
		}

	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ValueContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *ValueContext) Obj() IObjContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjContext)
}

func (s *ValueContext) Array() IArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayContext)
}

func (s *ValueContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *CypherParser) Value() (localctx IValueContext) {
	this := p
	_ = this

	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CypherParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(735)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserStringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(729)
			p.StringLiteral()
		}

	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(730)
			p.NumberLiteral()
		}

	case CypherParserT__13:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(731)
			p.Obj()
		}

	case CypherParserT__16:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(732)
			p.Array()
		}

	case CypherParserTRUE, CypherParserFALSE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(733)
			p.BooleanLiteral()
		}

	case CypherParserNULL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(734)
			p.Match(CypherParserNULL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyValueLiteralContext is an interface to support dynamic dispatch.
type IKeyValueLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyValueLiteralContext differentiates from other interfaces.
	IsKeyValueLiteralContext()
}

type KeyValueLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyValueLiteralContext() *KeyValueLiteralContext {
	var p = new(KeyValueLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_keyValueLiteral
	return p
}

func (*KeyValueLiteralContext) IsKeyValueLiteralContext() {}

func NewKeyValueLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyValueLiteralContext {
	var p = new(KeyValueLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_keyValueLiteral

	return p
}

func (s *KeyValueLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyValueLiteralContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *KeyValueLiteralContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *KeyValueLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *KeyValueLiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *KeyValueLiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *KeyValueLiteralContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *KeyValueLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyValueLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyValueLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterKeyValueLiteral(s)
	}
}

func (s *KeyValueLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitKeyValueLiteral(s)
	}
}

func (p *CypherParser) KeyValueLiteral() (localctx IKeyValueLiteralContext) {
	this := p
	_ = this

	localctx = NewKeyValueLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CypherParserRULE_keyValueLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Variable()
	}
	{
		p.SetState(738)
		p.Match(CypherParserT__1)
	}
	{
		p.SetState(739)
		p.Match(CypherParserSP)
	}
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(740)
			p.Match(CypherParserStringLiteral)
		}

	case 2:
		{
			p.SetState(741)
			p.NumberLiteral()
		}

	case 3:
		{
			p.SetState(742)
			p.BooleanLiteral()
		}

	case 4:
		{
			p.SetState(743)
			p.SymbolicName()
		}

	}

	return localctx
}

// ICommandPathContext is an interface to support dynamic dispatch.
type ICommandPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandPathContext differentiates from other interfaces.
	IsCommandPathContext()
}

type CommandPathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandPathContext() *CommandPathContext {
	var p = new(CommandPathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_commandPath
	return p
}

func (*CommandPathContext) IsCommandPathContext() {}

func NewCommandPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandPathContext {
	var p = new(CommandPathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_commandPath

	return p
}

func (s *CommandPathContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandPathContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *CommandPathContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *CommandPathContext) AllNumberLiteral() []INumberLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberLiteralContext); ok {
			len++
		}
	}

	tst := make([]INumberLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberLiteralContext); ok {
			tst[i] = t.(INumberLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CommandPathContext) NumberLiteral(i int) INumberLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *CommandPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCommandPath(s)
	}
}

func (s *CommandPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCommandPath(s)
	}
}

func (p *CypherParser) CommandPath() (localctx ICommandPathContext) {
	this := p
	_ = this

	localctx = NewCommandPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CypherParserRULE_commandPath)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(746)
				p.Match(CypherParserT__5)
			}
			p.SetState(749)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
				{
					p.SetState(747)
					p.SymbolicName()
				}

			case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
				{
					p.SetState(748)
					p.NumberLiteral()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__5 {
		{
			p.SetState(755)
			p.Match(CypherParserT__5)
		}

	}

	return localctx
}

// ISubCommandContext is an interface to support dynamic dispatch.
type ISubCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubCommandContext differentiates from other interfaces.
	IsSubCommandContext()
}

type SubCommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubCommandContext() *SubCommandContext {
	var p = new(SubCommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_subCommand
	return p
}

func (*SubCommandContext) IsSubCommandContext() {}

func NewSubCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubCommandContext {
	var p = new(SubCommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_subCommand

	return p
}

func (s *SubCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SubCommandContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *SubCommandContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *SubCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSubCommand(s)
	}
}

func (s *SubCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSubCommand(s)
	}
}

func (p *CypherParser) SubCommand() (localctx ISubCommandContext) {
	this := p
	_ = this

	localctx = NewSubCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CypherParserRULE_subCommand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.SymbolicName()
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__2 {
		{
			p.SetState(759)
			p.Match(CypherParserT__2)
		}
		{
			p.SetState(760)
			p.SymbolicName()
		}

		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICypherQueryContext is an interface to support dynamic dispatch.
type ICypherQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherQueryContext differentiates from other interfaces.
	IsCypherQueryContext()
}

type CypherQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherQueryContext() *CypherQueryContext {
	var p = new(CypherQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypherQuery
	return p
}

func (*CypherQueryContext) IsCypherQueryContext() {}

func NewCypherQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherQueryContext {
	var p = new(CypherQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypherQuery

	return p
}

func (s *CypherQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherQueryContext) QueryOptions() IQueryOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOptionsContext)
}

func (s *CypherQueryContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CypherQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypherQuery(s)
	}
}

func (s *CypherQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypherQuery(s)
	}
}

func (p *CypherParser) CypherQuery() (localctx ICypherQueryContext) {
	this := p
	_ = this

	localctx = NewCypherQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CypherParserRULE_cypherQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.QueryOptions()
	}
	{
		p.SetState(767)
		p.Statement()
	}

	return localctx
}

// IQueryOptionsContext is an interface to support dynamic dispatch.
type IQueryOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryOptionsContext differentiates from other interfaces.
	IsQueryOptionsContext()
}

type QueryOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryOptionsContext() *QueryOptionsContext {
	var p = new(QueryOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_queryOptions
	return p
}

func (*QueryOptionsContext) IsQueryOptionsContext() {}

func NewQueryOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryOptionsContext {
	var p = new(QueryOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_queryOptions

	return p
}

func (s *QueryOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryOptionsContext) AllAnyCypherOption() []IAnyCypherOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnyCypherOptionContext); ok {
			len++
		}
	}

	tst := make([]IAnyCypherOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnyCypherOptionContext); ok {
			tst[i] = t.(IAnyCypherOptionContext)
			i++
		}
	}

	return tst
}

func (s *QueryOptionsContext) AnyCypherOption(i int) IAnyCypherOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyCypherOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyCypherOptionContext)
}

func (s *QueryOptionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *QueryOptionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *QueryOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterQueryOptions(s)
	}
}

func (s *QueryOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitQueryOptions(s)
	}
}

func (p *CypherParser) QueryOptions() (localctx IQueryOptionsContext) {
	this := p
	_ = this

	localctx = NewQueryOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CypherParserRULE_queryOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(CypherParserCYPHER-54))|(1<<(CypherParserEXPLAIN-54))|(1<<(CypherParserPROFILE-54)))) != 0 {
		{
			p.SetState(769)
			p.AnyCypherOption()
		}
		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(770)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnyCypherOptionContext is an interface to support dynamic dispatch.
type IAnyCypherOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnyCypherOptionContext differentiates from other interfaces.
	IsAnyCypherOptionContext()
}

type AnyCypherOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyCypherOptionContext() *AnyCypherOptionContext {
	var p = new(AnyCypherOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_anyCypherOption
	return p
}

func (*AnyCypherOptionContext) IsAnyCypherOptionContext() {}

func NewAnyCypherOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyCypherOptionContext {
	var p = new(AnyCypherOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_anyCypherOption

	return p
}

func (s *AnyCypherOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyCypherOptionContext) CypherOption() ICypherOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICypherOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICypherOptionContext)
}

func (s *AnyCypherOptionContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *AnyCypherOptionContext) Profile() IProfileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProfileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProfileContext)
}

func (s *AnyCypherOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyCypherOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyCypherOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAnyCypherOption(s)
	}
}

func (s *AnyCypherOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAnyCypherOption(s)
	}
}

func (p *CypherParser) AnyCypherOption() (localctx IAnyCypherOptionContext) {
	this := p
	_ = this

	localctx = NewAnyCypherOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CypherParserRULE_anyCypherOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(781)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCYPHER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(778)
			p.CypherOption()
		}

	case CypherParserEXPLAIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(779)
			p.Explain()
		}

	case CypherParserPROFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(780)
			p.Profile()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICypherOptionContext is an interface to support dynamic dispatch.
type ICypherOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherOptionContext differentiates from other interfaces.
	IsCypherOptionContext()
}

type CypherOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherOptionContext() *CypherOptionContext {
	var p = new(CypherOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypherOption
	return p
}

func (*CypherOptionContext) IsCypherOptionContext() {}

func NewCypherOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherOptionContext {
	var p = new(CypherOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypherOption

	return p
}

func (s *CypherOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherOptionContext) CYPHER() antlr.TerminalNode {
	return s.GetToken(CypherParserCYPHER, 0)
}

func (s *CypherOptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CypherOptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CypherOptionContext) VersionNumber() IVersionNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionNumberContext)
}

func (s *CypherOptionContext) AllConfigurationOption() []IConfigurationOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConfigurationOptionContext); ok {
			len++
		}
	}

	tst := make([]IConfigurationOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConfigurationOptionContext); ok {
			tst[i] = t.(IConfigurationOptionContext)
			i++
		}
	}

	return tst
}

func (s *CypherOptionContext) ConfigurationOption(i int) IConfigurationOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConfigurationOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConfigurationOptionContext)
}

func (s *CypherOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypherOption(s)
	}
}

func (s *CypherOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypherOption(s)
	}
}

func (p *CypherParser) CypherOption() (localctx ICypherOptionContext) {
	this := p
	_ = this

	localctx = NewCypherOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CypherParserRULE_cypherOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Match(CypherParserCYPHER)
	}
	p.SetState(786)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(784)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(785)
			p.VersionNumber()
		}

	}
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(788)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(789)
				p.ConfigurationOption()
			}

		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}

	return localctx
}

// IVersionNumberContext is an interface to support dynamic dispatch.
type IVersionNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionNumberContext differentiates from other interfaces.
	IsVersionNumberContext()
}

type VersionNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionNumberContext() *VersionNumberContext {
	var p = new(VersionNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_versionNumber
	return p
}

func (*VersionNumberContext) IsVersionNumberContext() {}

func NewVersionNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionNumberContext {
	var p = new(VersionNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_versionNumber

	return p
}

func (s *VersionNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionNumberContext) RegularDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserRegularDecimalReal, 0)
}

func (s *VersionNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterVersionNumber(s)
	}
}

func (s *VersionNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitVersionNumber(s)
	}
}

func (p *CypherParser) VersionNumber() (localctx IVersionNumberContext) {
	this := p
	_ = this

	localctx = NewVersionNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CypherParserRULE_versionNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.Match(CypherParserRegularDecimalReal)
	}

	return localctx
}

// IExplainContext is an interface to support dynamic dispatch.
type IExplainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplainContext differentiates from other interfaces.
	IsExplainContext()
}

type ExplainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainContext() *ExplainContext {
	var p = new(ExplainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_explain
	return p
}

func (*ExplainContext) IsExplainContext() {}

func NewExplainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainContext {
	var p = new(ExplainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_explain

	return p
}

func (s *ExplainContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(CypherParserEXPLAIN, 0)
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExplain(s)
	}
}

func (p *CypherParser) Explain() (localctx IExplainContext) {
	this := p
	_ = this

	localctx = NewExplainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CypherParserRULE_explain)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.Match(CypherParserEXPLAIN)
	}

	return localctx
}

// IProfileContext is an interface to support dynamic dispatch.
type IProfileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProfileContext differentiates from other interfaces.
	IsProfileContext()
}

type ProfileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProfileContext() *ProfileContext {
	var p = new(ProfileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_profile
	return p
}

func (*ProfileContext) IsProfileContext() {}

func NewProfileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProfileContext {
	var p = new(ProfileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_profile

	return p
}

func (s *ProfileContext) GetParser() antlr.Parser { return s.parser }

func (s *ProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(CypherParserPROFILE, 0)
}

func (s *ProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProfileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProfile(s)
	}
}

func (s *ProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProfile(s)
	}
}

func (p *CypherParser) Profile() (localctx IProfileContext) {
	this := p
	_ = this

	localctx = NewProfileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CypherParserRULE_profile)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.Match(CypherParserPROFILE)
	}

	return localctx
}

// IConfigurationOptionContext is an interface to support dynamic dispatch.
type IConfigurationOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationOptionContext differentiates from other interfaces.
	IsConfigurationOptionContext()
}

type ConfigurationOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationOptionContext() *ConfigurationOptionContext {
	var p = new(ConfigurationOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_configurationOption
	return p
}

func (*ConfigurationOptionContext) IsConfigurationOptionContext() {}

func NewConfigurationOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationOptionContext {
	var p = new(ConfigurationOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_configurationOption

	return p
}

func (s *ConfigurationOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationOptionContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *ConfigurationOptionContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ConfigurationOptionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ConfigurationOptionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ConfigurationOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterConfigurationOption(s)
	}
}

func (s *ConfigurationOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitConfigurationOption(s)
	}
}

func (p *CypherParser) ConfigurationOption() (localctx IConfigurationOptionContext) {
	this := p
	_ = this

	localctx = NewConfigurationOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CypherParserRULE_configurationOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.SymbolicName()
	}
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(802)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(805)
		p.Match(CypherParserT__11)
	}
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(806)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(809)
		p.SymbolicName()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Command() ICommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *StatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementContext) SystemCommand() ISystemCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemCommandContext)
}

func (s *StatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(CypherParserCATALOG, 0)
}

func (s *StatementContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *CypherParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CypherParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(811)
			p.Command()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(812)
			p.Query()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserCATALOG {
			{
				p.SetState(813)
				p.Match(CypherParserCATALOG)
			}
			{
				p.SetState(814)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(817)
			p.SystemCommand()
		}

	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) RegularQuery() IRegularQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularQueryContext)
}

func (s *QueryContext) BulkImportQuery() IBulkImportQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulkImportQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulkImportQueryContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *CypherParser) Query() (localctx IQueryContext) {
	this := p
	_ = this

	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CypherParserRULE_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(822)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCREATE, CypherParserLOAD, CypherParserWITH, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserRETURN, CypherParserSTART, CypherParserCALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(820)
			p.RegularQuery()
		}

	case CypherParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(821)
			p.BulkImportQuery()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRegularQueryContext is an interface to support dynamic dispatch.
type IRegularQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularQueryContext differentiates from other interfaces.
	IsRegularQueryContext()
}

type RegularQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularQueryContext() *RegularQueryContext {
	var p = new(RegularQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_regularQuery
	return p
}

func (*RegularQueryContext) IsRegularQueryContext() {}

func NewRegularQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularQueryContext {
	var p = new(RegularQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_regularQuery

	return p
}

func (s *RegularQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularQueryContext) SingleQuery() ISingleQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *RegularQueryContext) AllUnion() []IUnionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionContext); ok {
			len++
		}
	}

	tst := make([]IUnionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionContext); ok {
			tst[i] = t.(IUnionContext)
			i++
		}
	}

	return tst
}

func (s *RegularQueryContext) Union(i int) IUnionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionContext)
}

func (s *RegularQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RegularQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RegularQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRegularQuery(s)
	}
}

func (s *RegularQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRegularQuery(s)
	}
}

func (p *CypherParser) RegularQuery() (localctx IRegularQueryContext) {
	this := p
	_ = this

	localctx = NewRegularQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CypherParserRULE_regularQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.SingleQuery()
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(826)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(825)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(828)
				p.Union()
			}

		}
		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
	}

	return localctx
}

// IBulkImportQueryContext is an interface to support dynamic dispatch.
type IBulkImportQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBulkImportQueryContext differentiates from other interfaces.
	IsBulkImportQueryContext()
}

type BulkImportQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulkImportQueryContext() *BulkImportQueryContext {
	var p = new(BulkImportQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_bulkImportQuery
	return p
}

func (*BulkImportQueryContext) IsBulkImportQueryContext() {}

func NewBulkImportQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulkImportQueryContext {
	var p = new(BulkImportQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_bulkImportQuery

	return p
}

func (s *BulkImportQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *BulkImportQueryContext) PeriodicCommitHint() IPeriodicCommitHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPeriodicCommitHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPeriodicCommitHintContext)
}

func (s *BulkImportQueryContext) LoadCSVQuery() ILoadCSVQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadCSVQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadCSVQueryContext)
}

func (s *BulkImportQueryContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *BulkImportQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulkImportQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulkImportQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterBulkImportQuery(s)
	}
}

func (s *BulkImportQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitBulkImportQuery(s)
	}
}

func (p *CypherParser) BulkImportQuery() (localctx IBulkImportQueryContext) {
	this := p
	_ = this

	localctx = NewBulkImportQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CypherParserRULE_bulkImportQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(834)
		p.PeriodicCommitHint()
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(835)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(838)
		p.LoadCSVQuery()
	}

	return localctx
}

// ISingleQueryContext is an interface to support dynamic dispatch.
type ISingleQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleQueryContext differentiates from other interfaces.
	IsSingleQueryContext()
}

type SingleQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQueryContext() *SingleQueryContext {
	var p = new(SingleQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_singleQuery
	return p
}

func (*SingleQueryContext) IsSingleQueryContext() {}

func NewSingleQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQueryContext {
	var p = new(SingleQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singleQuery

	return p
}

func (s *SingleQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQueryContext) AllClause() []IClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClauseContext); ok {
			len++
		}
	}

	tst := make([]IClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClauseContext); ok {
			tst[i] = t.(IClauseContext)
			i++
		}
	}

	return tst
}

func (s *SingleQueryContext) Clause(i int) IClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClauseContext)
}

func (s *SingleQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SingleQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SingleQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSingleQuery(s)
	}
}

func (s *SingleQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSingleQuery(s)
	}
}

func (p *CypherParser) SingleQuery() (localctx ISingleQueryContext) {
	this := p
	_ = this

	localctx = NewSingleQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CypherParserRULE_singleQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Clause()
	}
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(842)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(841)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(844)
				p.Clause()
			}

		}
		p.SetState(849)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}

	return localctx
}

// IPeriodicCommitHintContext is an interface to support dynamic dispatch.
type IPeriodicCommitHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPeriodicCommitHintContext differentiates from other interfaces.
	IsPeriodicCommitHintContext()
}

type PeriodicCommitHintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriodicCommitHintContext() *PeriodicCommitHintContext {
	var p = new(PeriodicCommitHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_periodicCommitHint
	return p
}

func (*PeriodicCommitHintContext) IsPeriodicCommitHintContext() {}

func NewPeriodicCommitHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeriodicCommitHintContext {
	var p = new(PeriodicCommitHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_periodicCommitHint

	return p
}

func (s *PeriodicCommitHintContext) GetParser() antlr.Parser { return s.parser }

func (s *PeriodicCommitHintContext) USING() antlr.TerminalNode {
	return s.GetToken(CypherParserUSING, 0)
}

func (s *PeriodicCommitHintContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PeriodicCommitHintContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PeriodicCommitHintContext) PERIODIC() antlr.TerminalNode {
	return s.GetToken(CypherParserPERIODIC, 0)
}

func (s *PeriodicCommitHintContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMIT, 0)
}

func (s *PeriodicCommitHintContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PeriodicCommitHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeriodicCommitHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeriodicCommitHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPeriodicCommitHint(s)
	}
}

func (s *PeriodicCommitHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPeriodicCommitHint(s)
	}
}

func (p *CypherParser) PeriodicCommitHint() (localctx IPeriodicCommitHintContext) {
	this := p
	_ = this

	localctx = NewPeriodicCommitHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CypherParserRULE_periodicCommitHint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(CypherParserUSING)
	}
	{
		p.SetState(851)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(852)
		p.Match(CypherParserPERIODIC)
	}
	{
		p.SetState(853)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(854)
		p.Match(CypherParserCOMMIT)
	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(855)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(856)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// ILoadCSVQueryContext is an interface to support dynamic dispatch.
type ILoadCSVQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoadCSVQueryContext differentiates from other interfaces.
	IsLoadCSVQueryContext()
}

type LoadCSVQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadCSVQueryContext() *LoadCSVQueryContext {
	var p = new(LoadCSVQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_loadCSVQuery
	return p
}

func (*LoadCSVQueryContext) IsLoadCSVQueryContext() {}

func NewLoadCSVQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadCSVQueryContext {
	var p = new(LoadCSVQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_loadCSVQuery

	return p
}

func (s *LoadCSVQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadCSVQueryContext) LoadCSVClause() ILoadCSVClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadCSVClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadCSVClauseContext)
}

func (s *LoadCSVQueryContext) AllClause() []IClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClauseContext); ok {
			len++
		}
	}

	tst := make([]IClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClauseContext); ok {
			tst[i] = t.(IClauseContext)
			i++
		}
	}

	return tst
}

func (s *LoadCSVQueryContext) Clause(i int) IClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClauseContext)
}

func (s *LoadCSVQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *LoadCSVQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *LoadCSVQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadCSVQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadCSVQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLoadCSVQuery(s)
	}
}

func (s *LoadCSVQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLoadCSVQuery(s)
	}
}

func (p *CypherParser) LoadCSVQuery() (localctx ILoadCSVQueryContext) {
	this := p
	_ = this

	localctx = NewLoadCSVQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CypherParserRULE_loadCSVQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.LoadCSVClause()
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(861)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(860)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(863)
				p.Clause()
			}

		}
		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// IUnionContext is an interface to support dynamic dispatch.
type IUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionContext differentiates from other interfaces.
	IsUnionContext()
}

type UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionContext() *UnionContext {
	var p = new(UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_union
	return p
}

func (*UnionContext) IsUnionContext() {}

func NewUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionContext {
	var p = new(UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_union

	return p
}

func (s *UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *UnionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnionContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *UnionContext) SingleQuery() ISingleQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *CypherParser) Union() (localctx IUnionContext) {
	this := p
	_ = this

	localctx = NewUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CypherParserRULE_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(869)
			p.Match(CypherParserUNION)
		}
		{
			p.SetState(870)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(871)
			p.Match(CypherParserALL)
		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(872)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(875)
			p.SingleQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(876)
			p.Match(CypherParserUNION)
		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(877)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(880)
			p.SingleQuery()
		}

	}

	return localctx
}

// IClauseContext is an interface to support dynamic dispatch.
type IClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClauseContext differentiates from other interfaces.
	IsClauseContext()
}

type ClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClauseContext() *ClauseContext {
	var p = new(ClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_clause
	return p
}

func (*ClauseContext) IsClauseContext() {}

func NewClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClauseContext {
	var p = new(ClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_clause

	return p
}

func (s *ClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClauseContext) LoadCSVClause() ILoadCSVClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadCSVClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadCSVClauseContext)
}

func (s *ClauseContext) StartClause() IStartClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartClauseContext)
}

func (s *ClauseContext) MatchClause() IMatchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchClauseContext)
}

func (s *ClauseContext) UnwindClause() IUnwindClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnwindClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnwindClauseContext)
}

func (s *ClauseContext) MergeClause() IMergeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeClauseContext)
}

func (s *ClauseContext) CreateClause() ICreateClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateClauseContext)
}

func (s *ClauseContext) CreateUniqueClause() ICreateUniqueClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUniqueClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUniqueClauseContext)
}

func (s *ClauseContext) SetClause() ISetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetClauseContext)
}

func (s *ClauseContext) DeleteClause() IDeleteClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteClauseContext)
}

func (s *ClauseContext) RemoveClause() IRemoveClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveClauseContext)
}

func (s *ClauseContext) ForeachClause() IForeachClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeachClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeachClauseContext)
}

func (s *ClauseContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *ClauseContext) ReturnClause() IReturnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnClauseContext)
}

func (s *ClauseContext) Call() ICallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallContext)
}

func (s *ClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterClause(s)
	}
}

func (s *ClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitClause(s)
	}
}

func (p *CypherParser) Clause() (localctx IClauseContext) {
	this := p
	_ = this

	localctx = NewClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CypherParserRULE_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(883)
			p.LoadCSVClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(884)
			p.StartClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(885)
			p.MatchClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(886)
			p.UnwindClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(887)
			p.MergeClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(888)
			p.CreateClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(889)
			p.CreateUniqueClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(890)
			p.SetClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(891)
			p.DeleteClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(892)
			p.RemoveClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(893)
			p.ForeachClause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(894)
			p.WithClause()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(895)
			p.ReturnClause()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(896)
			p.Call()
		}

	}

	return localctx
}

// ICommandContext is an interface to support dynamic dispatch.
type ICommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandContext differentiates from other interfaces.
	IsCommandContext()
}

type CommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandContext() *CommandContext {
	var p = new(CommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_command
	return p
}

func (*CommandContext) IsCommandContext() {}

func NewCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandContext {
	var p = new(CommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_command

	return p
}

func (s *CommandContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *CommandContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *CommandContext) CreateUniqueConstraint() ICreateUniqueConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUniqueConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUniqueConstraintContext)
}

func (s *CommandContext) DropUniqueConstraint() IDropUniqueConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUniqueConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUniqueConstraintContext)
}

func (s *CommandContext) CreateNodeKeyConstraint() ICreateNodeKeyConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateNodeKeyConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateNodeKeyConstraintContext)
}

func (s *CommandContext) DropNodeKeyConstraint() IDropNodeKeyConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropNodeKeyConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropNodeKeyConstraintContext)
}

func (s *CommandContext) CreateNodePropertyExistenceConstraint() ICreateNodePropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateNodePropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateNodePropertyExistenceConstraintContext)
}

func (s *CommandContext) DropNodePropertyExistenceConstraint() IDropNodePropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropNodePropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropNodePropertyExistenceConstraintContext)
}

func (s *CommandContext) CreateRelationshipPropertyExistenceConstraint() ICreateRelationshipPropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRelationshipPropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRelationshipPropertyExistenceConstraintContext)
}

func (s *CommandContext) DropRelationshipPropertyExistenceConstraint() IDropRelationshipPropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRelationshipPropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRelationshipPropertyExistenceConstraintContext)
}

func (s *CommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCommand(s)
	}
}

func (s *CommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCommand(s)
	}
}

func (p *CypherParser) Command() (localctx ICommandContext) {
	this := p
	_ = this

	localctx = NewCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CypherParserRULE_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.CreateIndex()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.DropIndex()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(901)
			p.CreateUniqueConstraint()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(902)
			p.DropUniqueConstraint()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(903)
			p.CreateNodeKeyConstraint()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(904)
			p.DropNodeKeyConstraint()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(905)
			p.CreateNodePropertyExistenceConstraint()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(906)
			p.DropNodePropertyExistenceConstraint()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(907)
			p.CreateRelationshipPropertyExistenceConstraint()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(908)
			p.DropRelationshipPropertyExistenceConstraint()
		}

	}

	return localctx
}

// ISystemCommandContext is an interface to support dynamic dispatch.
type ISystemCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystemCommandContext differentiates from other interfaces.
	IsSystemCommandContext()
}

type SystemCommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemCommandContext() *SystemCommandContext {
	var p = new(SystemCommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_systemCommand
	return p
}

func (*SystemCommandContext) IsSystemCommandContext() {}

func NewSystemCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemCommandContext {
	var p = new(SystemCommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_systemCommand

	return p
}

func (s *SystemCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemCommandContext) MultidatabaseCommand() IMultidatabaseCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultidatabaseCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultidatabaseCommandContext)
}

func (s *SystemCommandContext) UserCommand() IUserCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserCommandContext)
}

func (s *SystemCommandContext) PrivilegeCommand() IPrivilegeCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeCommandContext)
}

func (s *SystemCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSystemCommand(s)
	}
}

func (s *SystemCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSystemCommand(s)
	}
}

func (p *CypherParser) SystemCommand() (localctx ISystemCommandContext) {
	this := p
	_ = this

	localctx = NewSystemCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CypherParserRULE_systemCommand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(911)
			p.MultidatabaseCommand()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(912)
			p.UserCommand()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(913)
			p.PrivilegeCommand()
		}

	}

	return localctx
}

// IMultidatabaseCommandContext is an interface to support dynamic dispatch.
type IMultidatabaseCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultidatabaseCommandContext differentiates from other interfaces.
	IsMultidatabaseCommandContext()
}

type MultidatabaseCommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultidatabaseCommandContext() *MultidatabaseCommandContext {
	var p = new(MultidatabaseCommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_multidatabaseCommand
	return p
}

func (*MultidatabaseCommandContext) IsMultidatabaseCommandContext() {}

func NewMultidatabaseCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultidatabaseCommandContext {
	var p = new(MultidatabaseCommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multidatabaseCommand

	return p
}

func (s *MultidatabaseCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *MultidatabaseCommandContext) ShowDatabase() IShowDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDatabaseContext)
}

func (s *MultidatabaseCommandContext) CreateDatabase() ICreateDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *MultidatabaseCommandContext) DropDatabase() IDropDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *MultidatabaseCommandContext) StartDatabase() IStartDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartDatabaseContext)
}

func (s *MultidatabaseCommandContext) StopDatabase() IStopDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopDatabaseContext)
}

func (s *MultidatabaseCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultidatabaseCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultidatabaseCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMultidatabaseCommand(s)
	}
}

func (s *MultidatabaseCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMultidatabaseCommand(s)
	}
}

func (p *CypherParser) MultidatabaseCommand() (localctx IMultidatabaseCommandContext) {
	this := p
	_ = this

	localctx = NewMultidatabaseCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CypherParserRULE_multidatabaseCommand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(921)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserSHOW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(916)
			p.ShowDatabase()
		}

	case CypherParserCREATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.CreateDatabase()
		}

	case CypherParserDROP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(918)
			p.DropDatabase()
		}

	case CypherParserSTART:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(919)
			p.StartDatabase()
		}

	case CypherParserSTOP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(920)
			p.StopDatabase()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUserCommandContext is an interface to support dynamic dispatch.
type IUserCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserCommandContext differentiates from other interfaces.
	IsUserCommandContext()
}

type UserCommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserCommandContext() *UserCommandContext {
	var p = new(UserCommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_userCommand
	return p
}

func (*UserCommandContext) IsUserCommandContext() {}

func NewUserCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserCommandContext {
	var p = new(UserCommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_userCommand

	return p
}

func (s *UserCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *UserCommandContext) ShowRoles() IShowRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRolesContext)
}

func (s *UserCommandContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *UserCommandContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *UserCommandContext) ShowUsers() IShowUsersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUsersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUsersContext)
}

func (s *UserCommandContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *UserCommandContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *UserCommandContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *UserCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUserCommand(s)
	}
}

func (s *UserCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUserCommand(s)
	}
}

func (p *CypherParser) UserCommand() (localctx IUserCommandContext) {
	this := p
	_ = this

	localctx = NewUserCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CypherParserRULE_userCommand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(923)
			p.ShowRoles()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(924)
			p.CreateRole()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(925)
			p.DropRole()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(926)
			p.ShowUsers()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(927)
			p.CreateUser()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(928)
			p.DropUser()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(929)
			p.AlterUser()
		}

	}

	return localctx
}

// IPrivilegeCommandContext is an interface to support dynamic dispatch.
type IPrivilegeCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeCommandContext differentiates from other interfaces.
	IsPrivilegeCommandContext()
}

type PrivilegeCommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeCommandContext() *PrivilegeCommandContext {
	var p = new(PrivilegeCommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_privilegeCommand
	return p
}

func (*PrivilegeCommandContext) IsPrivilegeCommandContext() {}

func NewPrivilegeCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeCommandContext {
	var p = new(PrivilegeCommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_privilegeCommand

	return p
}

func (s *PrivilegeCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeCommandContext) ShowPrivileges() IShowPrivilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPrivilegesContext)
}

func (s *PrivilegeCommandContext) GrantPrivilege() IGrantPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantPrivilegeContext)
}

func (s *PrivilegeCommandContext) DenyPrivilege() IDenyPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDenyPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDenyPrivilegeContext)
}

func (s *PrivilegeCommandContext) RevokePrivilege() IRevokePrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokePrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokePrivilegeContext)
}

func (s *PrivilegeCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPrivilegeCommand(s)
	}
}

func (s *PrivilegeCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPrivilegeCommand(s)
	}
}

func (p *CypherParser) PrivilegeCommand() (localctx IPrivilegeCommandContext) {
	this := p
	_ = this

	localctx = NewPrivilegeCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CypherParserRULE_privilegeCommand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(936)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserSHOW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.ShowPrivileges()
		}

	case CypherParserGRANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.GrantPrivilege()
		}

	case CypherParserDENY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(934)
			p.DenyPrivilege()
		}

	case CypherParserREVOKE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(935)
			p.RevokePrivilege()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowRolesContext is an interface to support dynamic dispatch.
type IShowRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowRolesContext differentiates from other interfaces.
	IsShowRolesContext()
}

type ShowRolesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRolesContext() *ShowRolesContext {
	var p = new(ShowRolesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_showRoles
	return p
}

func (*ShowRolesContext) IsShowRolesContext() {}

func NewShowRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRolesContext {
	var p = new(ShowRolesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_showRoles

	return p
}

func (s *ShowRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRolesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(CypherParserSHOW, 0)
}

func (s *ShowRolesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ShowRolesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ShowRolesContext) ROLES() antlr.TerminalNode {
	return s.GetToken(CypherParserROLES, 0)
}

func (s *ShowRolesContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *ShowRolesContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *ShowRolesContext) USERS() antlr.TerminalNode {
	return s.GetToken(CypherParserUSERS, 0)
}

func (s *ShowRolesContext) POPULATED() antlr.TerminalNode {
	return s.GetToken(CypherParserPOPULATED, 0)
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

func (p *CypherParser) ShowRoles() (localctx IShowRolesContext) {
	this := p
	_ = this

	localctx = NewShowRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CypherParserRULE_showRoles)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(964)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(938)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(939)
			p.Match(CypherParserSP)
		}
		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserALL {
			{
				p.SetState(940)
				p.Match(CypherParserALL)
			}
			{
				p.SetState(941)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(944)
			p.Match(CypherParserROLES)
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(945)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(946)
				p.Match(CypherParserWITH)
			}
			{
				p.SetState(947)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(948)
				p.Match(CypherParserUSERS)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(951)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(952)
			p.Match(CypherParserSP)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserPOPULATED {
			{
				p.SetState(953)
				p.Match(CypherParserPOPULATED)
			}
			{
				p.SetState(954)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(957)
			p.Match(CypherParserROLES)
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(958)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(959)
				p.Match(CypherParserWITH)
			}
			{
				p.SetState(960)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(961)
				p.Match(CypherParserUSERS)
			}

		}

	}

	return localctx
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createRole
	return p
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateRoleContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CreateRoleContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *CreateRoleContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *CreateRoleContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateRoleContext) CopyRole() ICopyRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopyRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopyRoleContext)
}

func (s *CreateRoleContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (p *CypherParser) CreateRole() (localctx ICreateRoleContext) {
	this := p
	_ = this

	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CypherParserRULE_createRole)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(966)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(967)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(968)
			p.Match(CypherParserROLE)
		}
		{
			p.SetState(969)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(970)
			p.SymbolicName()
		}
		p.SetState(973)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(971)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(972)
				p.IfNotExists()
			}

		}
		p.SetState(977)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(975)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(976)
				p.CopyRole()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(979)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(980)
			p.Match(CypherParserSP)
		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserOR {
			{
				p.SetState(981)
				p.OrReplace()
			}
			{
				p.SetState(982)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(986)
			p.Match(CypherParserROLE)
		}
		{
			p.SetState(987)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(988)
			p.SymbolicName()
		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(989)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(990)
				p.CopyRole()
			}

		}

	}

	return localctx
}

// ICopyRoleContext is an interface to support dynamic dispatch.
type ICopyRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCopyRoleContext differentiates from other interfaces.
	IsCopyRoleContext()
}

type CopyRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopyRoleContext() *CopyRoleContext {
	var p = new(CopyRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_copyRole
	return p
}

func (*CopyRoleContext) IsCopyRoleContext() {}

func NewCopyRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopyRoleContext {
	var p = new(CopyRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_copyRole

	return p
}

func (s *CopyRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CopyRoleContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *CopyRoleContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CopyRoleContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CopyRoleContext) COPY() antlr.TerminalNode {
	return s.GetToken(CypherParserCOPY, 0)
}

func (s *CopyRoleContext) OF() antlr.TerminalNode {
	return s.GetToken(CypherParserOF, 0)
}

func (s *CopyRoleContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *CopyRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopyRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCopyRole(s)
	}
}

func (s *CopyRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCopyRole(s)
	}
}

func (p *CypherParser) CopyRole() (localctx ICopyRoleContext) {
	this := p
	_ = this

	localctx = NewCopyRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CypherParserRULE_copyRole)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Match(CypherParserAS)
	}
	{
		p.SetState(996)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(997)
		p.Match(CypherParserCOPY)
	}
	{
		p.SetState(998)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(999)
		p.Match(CypherParserOF)
	}
	{
		p.SetState(1000)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1001)
		p.SymbolicName()
	}

	return localctx
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropRole
	return p
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropRoleContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DropRoleContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *DropRoleContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *DropRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(CypherParserIF, 0)
}

func (s *DropRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (p *CypherParser) DropRole() (localctx IDropRoleContext) {
	this := p
	_ = this

	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CypherParserRULE_dropRole)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1004)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1005)
		p.Match(CypherParserROLE)
	}
	{
		p.SetState(1006)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1007)
		p.SymbolicName()
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1008)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1009)
			p.Match(CypherParserIF)
		}
		{
			p.SetState(1010)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1011)
			p.Match(CypherParserEXISTS)
		}

	}

	return localctx
}

// IShowUsersContext is an interface to support dynamic dispatch.
type IShowUsersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowUsersContext differentiates from other interfaces.
	IsShowUsersContext()
}

type ShowUsersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUsersContext() *ShowUsersContext {
	var p = new(ShowUsersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_showUsers
	return p
}

func (*ShowUsersContext) IsShowUsersContext() {}

func NewShowUsersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUsersContext {
	var p = new(ShowUsersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_showUsers

	return p
}

func (s *ShowUsersContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUsersContext) SHOW() antlr.TerminalNode {
	return s.GetToken(CypherParserSHOW, 0)
}

func (s *ShowUsersContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *ShowUsersContext) USERS() antlr.TerminalNode {
	return s.GetToken(CypherParserUSERS, 0)
}

func (s *ShowUsersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUsersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUsersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterShowUsers(s)
	}
}

func (s *ShowUsersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitShowUsers(s)
	}
}

func (p *CypherParser) ShowUsers() (localctx IShowUsersContext) {
	this := p
	_ = this

	localctx = NewShowUsersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CypherParserRULE_showUsers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1014)
		p.Match(CypherParserSHOW)
	}
	{
		p.SetState(1015)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1016)
		p.Match(CypherParserUSERS)
	}

	return localctx
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createUser
	return p
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateUserContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CreateUserContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(CypherParserUSER, 0)
}

func (s *CreateUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserContext) SetPassword() ISetPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetPasswordContext)
}

func (s *CreateUserContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserContext) SetStatus() ISetStatusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatusContext)
}

func (s *CreateUserContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

func (p *CypherParser) CreateUser() (localctx ICreateUserContext) {
	this := p
	_ = this

	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CypherParserRULE_createUser)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1018)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1019)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1020)
			p.Match(CypherParserUSER)
		}
		{
			p.SetState(1021)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1022)
			p.User()
		}
		{
			p.SetState(1023)
			p.Match(CypherParserSP)
		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1024)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1025)
				p.IfNotExists()
			}

		}
		{
			p.SetState(1028)
			p.SetPassword()
		}
		p.SetState(1031)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1029)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1030)
				p.SetStatus()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1033)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1034)
			p.Match(CypherParserSP)
		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserOR {
			{
				p.SetState(1035)
				p.OrReplace()
			}
			{
				p.SetState(1036)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1040)
			p.Match(CypherParserUSER)
		}
		{
			p.SetState(1041)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1042)
			p.User()
		}
		{
			p.SetState(1043)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1044)
			p.SetPassword()
		}
		p.SetState(1047)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1045)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1046)
				p.SetStatus()
			}

		}

	}

	return localctx
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropUser
	return p
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropUserContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DropUserContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(CypherParserUSER, 0)
}

func (s *DropUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DropUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (p *CypherParser) DropUser() (localctx IDropUserContext) {
	this := p
	_ = this

	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CypherParserRULE_dropUser)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1052)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1053)
		p.Match(CypherParserUSER)
	}
	{
		p.SetState(1054)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1055)
		p.User()
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1056)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1057)
			p.IfExists()
		}

	}

	return localctx
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_alterUser
	return p
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) ALTER() antlr.TerminalNode {
	return s.GetToken(CypherParserALTER, 0)
}

func (s *AlterUserContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AlterUserContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AlterUserContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(CypherParserCURRENT, 0)
}

func (s *AlterUserContext) USER() antlr.TerminalNode {
	return s.GetToken(CypherParserUSER, 0)
}

func (s *AlterUserContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *AlterUserContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(CypherParserPASSWORD, 0)
}

func (s *AlterUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(CypherParserFROM, 0)
}

func (s *AlterUserContext) TO() antlr.TerminalNode {
	return s.GetToken(CypherParserTO, 0)
}

func (s *AlterUserContext) AllPassword() []IPasswordContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPasswordContext); ok {
			len++
		}
	}

	tst := make([]IPasswordContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPasswordContext); ok {
			tst[i] = t.(IPasswordContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserContext) Password(i int) IPasswordContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordContext)
}

func (s *AlterUserContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *AlterUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserContext) SetPassword() ISetPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetPasswordContext)
}

func (s *AlterUserContext) SetStatus() ISetStatusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatusContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

func (p *CypherParser) AlterUser() (localctx IAlterUserContext) {
	this := p
	_ = this

	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CypherParserRULE_alterUser)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1060)
			p.Match(CypherParserALTER)
		}
		{
			p.SetState(1061)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1062)
			p.Match(CypherParserCURRENT)
		}
		{
			p.SetState(1063)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1064)
			p.Match(CypherParserUSER)
		}
		{
			p.SetState(1065)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1066)
			p.Match(CypherParserSET)
		}
		{
			p.SetState(1067)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1068)
			p.Match(CypherParserPASSWORD)
		}
		{
			p.SetState(1069)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1070)
			p.Match(CypherParserFROM)
		}
		{
			p.SetState(1071)
			p.Match(CypherParserSP)
		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
			{
				p.SetState(1072)
				p.Password()
			}

		case CypherParserT__13, CypherParserT__33:
			{
				p.SetState(1073)
				p.Parameter()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1076)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1077)
			p.Match(CypherParserSP)
		}
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
			{
				p.SetState(1078)
				p.Password()
			}

		case CypherParserT__13, CypherParserT__33:
			{
				p.SetState(1079)
				p.Parameter()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1082)
			p.Match(CypherParserALTER)
		}
		{
			p.SetState(1083)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1084)
			p.Match(CypherParserUSER)
		}
		{
			p.SetState(1085)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1086)
			p.User()
		}
		{
			p.SetState(1087)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1088)
			p.SetPassword()
		}
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1089)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1090)
				p.SetStatus()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1093)
			p.Match(CypherParserALTER)
		}
		{
			p.SetState(1094)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1095)
			p.Match(CypherParserUSER)
		}
		{
			p.SetState(1096)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1097)
			p.User()
		}
		{
			p.SetState(1098)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1099)
			p.SetStatus()
		}

	}

	return localctx
}

// IShowPrivilegesContext is an interface to support dynamic dispatch.
type IShowPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowPrivilegesContext differentiates from other interfaces.
	IsShowPrivilegesContext()
}

type ShowPrivilegesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPrivilegesContext() *ShowPrivilegesContext {
	var p = new(ShowPrivilegesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_showPrivileges
	return p
}

func (*ShowPrivilegesContext) IsShowPrivilegesContext() {}

func NewShowPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPrivilegesContext {
	var p = new(ShowPrivilegesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_showPrivileges

	return p
}

func (s *ShowPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPrivilegesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(CypherParserSHOW, 0)
}

func (s *ShowPrivilegesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ShowPrivilegesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ShowPrivilegesContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(CypherParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *ShowPrivilegesContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *ShowPrivilegesContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ShowPrivilegesContext) USER() antlr.TerminalNode {
	return s.GetToken(CypherParserUSER, 0)
}

func (s *ShowPrivilegesContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterShowPrivileges(s)
	}
}

func (s *ShowPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitShowPrivileges(s)
	}
}

func (p *CypherParser) ShowPrivileges() (localctx IShowPrivilegesContext) {
	this := p
	_ = this

	localctx = NewShowPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CypherParserRULE_showPrivileges)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1130)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1103)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(1104)
			p.Match(CypherParserSP)
		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserALL {
			{
				p.SetState(1105)
				p.Match(CypherParserALL)
			}
			{
				p.SetState(1106)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1109)
			p.Match(CypherParserPRIVILEGES)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1110)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(1111)
			p.Match(CypherParserSP)
		}
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserROLE {
			{
				p.SetState(1112)
				p.Match(CypherParserROLE)
			}
			{
				p.SetState(1113)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1114)
				p.SymbolicName()
			}
			{
				p.SetState(1115)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1119)
			p.Match(CypherParserPRIVILEGES)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1120)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(1121)
			p.Match(CypherParserSP)
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserUSER {
			{
				p.SetState(1122)
				p.Match(CypherParserUSER)
			}
			{
				p.SetState(1123)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1124)
				p.User()
			}
			{
				p.SetState(1125)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1129)
			p.Match(CypherParserPRIVILEGES)
		}

	}

	return localctx
}

// IGrantPrivilegeContext is an interface to support dynamic dispatch.
type IGrantPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrantPrivilegeContext differentiates from other interfaces.
	IsGrantPrivilegeContext()
}

type GrantPrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantPrivilegeContext() *GrantPrivilegeContext {
	var p = new(GrantPrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_grantPrivilege
	return p
}

func (*GrantPrivilegeContext) IsGrantPrivilegeContext() {}

func NewGrantPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantPrivilegeContext {
	var p = new(GrantPrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_grantPrivilege

	return p
}

func (s *GrantPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantPrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(CypherParserGRANT, 0)
}

func (s *GrantPrivilegeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *GrantPrivilegeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *GrantPrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *GrantPrivilegeContext) Roles() IRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *GrantPrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(CypherParserTO, 0)
}

func (s *GrantPrivilegeContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantPrivilegeContext) DatasbasePrivilege() IDatasbasePrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatasbasePrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatasbasePrivilegeContext)
}

func (s *GrantPrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *GrantPrivilegeContext) DatabaseScope() IDatabaseScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseScopeContext)
}

func (s *GrantPrivilegeContext) GrantableGraphPrivileges() IGrantableGraphPrivilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantableGraphPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantableGraphPrivilegesContext)
}

func (s *GrantPrivilegeContext) GraphScope() IGraphScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphScopeContext)
}

func (s *GrantPrivilegeContext) ElementScope() IElementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementScopeContext)
}

func (s *GrantPrivilegeContext) DbmsPrivilege() IDbmsPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbmsPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbmsPrivilegeContext)
}

func (s *GrantPrivilegeContext) DBMS() antlr.TerminalNode {
	return s.GetToken(CypherParserDBMS, 0)
}

func (s *GrantPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterGrantPrivilege(s)
	}
}

func (s *GrantPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitGrantPrivilege(s)
	}
}

func (p *CypherParser) GrantPrivilege() (localctx IGrantPrivilegeContext) {
	this := p
	_ = this

	localctx = NewGrantPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CypherParserRULE_grantPrivilege)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1132)
			p.Match(CypherParserGRANT)
		}
		{
			p.SetState(1133)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1134)
			p.Match(CypherParserROLE)
		}
		{
			p.SetState(1135)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1136)
			p.Roles()
		}
		{
			p.SetState(1137)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1138)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1139)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1140)
			p.User()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1142)
			p.Match(CypherParserGRANT)
		}
		{
			p.SetState(1143)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1144)
			p.DatasbasePrivilege()
		}
		{
			p.SetState(1145)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1146)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1147)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1148)
			p.DatabaseScope()
		}
		{
			p.SetState(1149)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1150)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1151)
			p.Roles()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1153)
			p.Match(CypherParserGRANT)
		}
		{
			p.SetState(1154)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1155)
			p.GrantableGraphPrivileges()
		}
		{
			p.SetState(1156)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1157)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1158)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1159)
			p.GraphScope()
		}
		{
			p.SetState(1160)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1161)
			p.ElementScope()
		}
		{
			p.SetState(1162)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1163)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1164)
			p.Roles()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1166)
			p.Match(CypherParserGRANT)
		}
		{
			p.SetState(1167)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1168)
			p.DbmsPrivilege()
		}
		{
			p.SetState(1169)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1170)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1171)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1172)
			p.Match(CypherParserDBMS)
		}
		{
			p.SetState(1173)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1174)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1175)
			p.Roles()
		}

	}

	return localctx
}

// IDenyPrivilegeContext is an interface to support dynamic dispatch.
type IDenyPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDenyPrivilegeContext differentiates from other interfaces.
	IsDenyPrivilegeContext()
}

type DenyPrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDenyPrivilegeContext() *DenyPrivilegeContext {
	var p = new(DenyPrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_denyPrivilege
	return p
}

func (*DenyPrivilegeContext) IsDenyPrivilegeContext() {}

func NewDenyPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DenyPrivilegeContext {
	var p = new(DenyPrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_denyPrivilege

	return p
}

func (s *DenyPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *DenyPrivilegeContext) DENY() antlr.TerminalNode {
	return s.GetToken(CypherParserDENY, 0)
}

func (s *DenyPrivilegeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DenyPrivilegeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DenyPrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *DenyPrivilegeContext) Roles() IRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *DenyPrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(CypherParserTO, 0)
}

func (s *DenyPrivilegeContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DenyPrivilegeContext) DatasbasePrivilege() IDatasbasePrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatasbasePrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatasbasePrivilegeContext)
}

func (s *DenyPrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *DenyPrivilegeContext) DatabaseScope() IDatabaseScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseScopeContext)
}

func (s *DenyPrivilegeContext) GrantableGraphPrivileges() IGrantableGraphPrivilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantableGraphPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantableGraphPrivilegesContext)
}

func (s *DenyPrivilegeContext) GraphScope() IGraphScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphScopeContext)
}

func (s *DenyPrivilegeContext) ElementScope() IElementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementScopeContext)
}

func (s *DenyPrivilegeContext) DbmsPrivilege() IDbmsPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbmsPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbmsPrivilegeContext)
}

func (s *DenyPrivilegeContext) DBMS() antlr.TerminalNode {
	return s.GetToken(CypherParserDBMS, 0)
}

func (s *DenyPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DenyPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DenyPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDenyPrivilege(s)
	}
}

func (s *DenyPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDenyPrivilege(s)
	}
}

func (p *CypherParser) DenyPrivilege() (localctx IDenyPrivilegeContext) {
	this := p
	_ = this

	localctx = NewDenyPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CypherParserRULE_denyPrivilege)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1224)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1179)
			p.Match(CypherParserDENY)
		}
		{
			p.SetState(1180)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1181)
			p.Match(CypherParserROLE)
		}
		{
			p.SetState(1182)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1183)
			p.Roles()
		}
		{
			p.SetState(1184)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1185)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1186)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1187)
			p.User()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1189)
			p.Match(CypherParserDENY)
		}
		{
			p.SetState(1190)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1191)
			p.DatasbasePrivilege()
		}
		{
			p.SetState(1192)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1193)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1194)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1195)
			p.DatabaseScope()
		}
		{
			p.SetState(1196)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1197)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1198)
			p.Roles()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1200)
			p.Match(CypherParserDENY)
		}
		{
			p.SetState(1201)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1202)
			p.GrantableGraphPrivileges()
		}
		{
			p.SetState(1203)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1204)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1205)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1206)
			p.GraphScope()
		}
		{
			p.SetState(1207)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1208)
			p.ElementScope()
		}
		{
			p.SetState(1209)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1210)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1211)
			p.Roles()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1213)
			p.Match(CypherParserDENY)
		}
		{
			p.SetState(1214)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1215)
			p.DbmsPrivilege()
		}
		{
			p.SetState(1216)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1217)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1218)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1219)
			p.Match(CypherParserDBMS)
		}
		{
			p.SetState(1220)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1221)
			p.Match(CypherParserTO)
		}
		{
			p.SetState(1222)
			p.Roles()
		}

	}

	return localctx
}

// IRevokePrivilegeContext is an interface to support dynamic dispatch.
type IRevokePrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRevokePrivilegeContext differentiates from other interfaces.
	IsRevokePrivilegeContext()
}

type RevokePrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokePrivilegeContext() *RevokePrivilegeContext {
	var p = new(RevokePrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_revokePrivilege
	return p
}

func (*RevokePrivilegeContext) IsRevokePrivilegeContext() {}

func NewRevokePrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokePrivilegeContext {
	var p = new(RevokePrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_revokePrivilege

	return p
}

func (s *RevokePrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(CypherParserREVOKE, 0)
}

func (s *RevokePrivilegeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RevokePrivilegeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RevokePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *RevokePrivilegeContext) Roles() IRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *RevokePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(CypherParserFROM, 0)
}

func (s *RevokePrivilegeContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokePrivilegeContext) RevokePart() IRevokePartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokePartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokePartContext)
}

func (s *RevokePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(CypherParserGRANT, 0)
}

func (s *RevokePrivilegeContext) DENY() antlr.TerminalNode {
	return s.GetToken(CypherParserDENY, 0)
}

func (s *RevokePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokePrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRevokePrivilege(s)
	}
}

func (s *RevokePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRevokePrivilege(s)
	}
}

func (p *CypherParser) RevokePrivilege() (localctx IRevokePrivilegeContext) {
	this := p
	_ = this

	localctx = NewRevokePrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CypherParserRULE_revokePrivilege)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1226)
			p.Match(CypherParserREVOKE)
		}
		{
			p.SetState(1227)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1228)
			p.Match(CypherParserROLE)
		}
		{
			p.SetState(1229)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1230)
			p.Roles()
		}
		{
			p.SetState(1231)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1232)
			p.Match(CypherParserFROM)
		}
		{
			p.SetState(1233)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1234)
			p.User()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1236)
			p.Match(CypherParserREVOKE)
		}
		p.SetState(1239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1237)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1238)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CypherParserGRANT || _la == CypherParserDENY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1241)
			p.RevokePart()
		}
		{
			p.SetState(1242)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1243)
			p.Match(CypherParserFROM)
		}
		{
			p.SetState(1244)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1245)
			p.Roles()
		}

	}

	return localctx
}

// IRevokePartContext is an interface to support dynamic dispatch.
type IRevokePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRevokePartContext differentiates from other interfaces.
	IsRevokePartContext()
}

type RevokePartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokePartContext() *RevokePartContext {
	var p = new(RevokePartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_revokePart
	return p
}

func (*RevokePartContext) IsRevokePartContext() {}

func NewRevokePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokePartContext {
	var p = new(RevokePartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_revokePart

	return p
}

func (s *RevokePartContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokePartContext) DatasbasePrivilege() IDatasbasePrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatasbasePrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatasbasePrivilegeContext)
}

func (s *RevokePartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RevokePartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RevokePartContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *RevokePartContext) DatabaseScope() IDatabaseScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseScopeContext)
}

func (s *RevokePartContext) RevokeableGraphPrivileges() IRevokeableGraphPrivilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeableGraphPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeableGraphPrivilegesContext)
}

func (s *RevokePartContext) GraphScope() IGraphScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphScopeContext)
}

func (s *RevokePartContext) DbmsPrivilege() IDbmsPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDbmsPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDbmsPrivilegeContext)
}

func (s *RevokePartContext) DBMS() antlr.TerminalNode {
	return s.GetToken(CypherParserDBMS, 0)
}

func (s *RevokePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokePartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRevokePart(s)
	}
}

func (s *RevokePartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRevokePart(s)
	}
}

func (p *CypherParser) RevokePart() (localctx IRevokePartContext) {
	this := p
	_ = this

	localctx = NewRevokePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CypherParserRULE_revokePart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1267)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1249)
			p.DatasbasePrivilege()
		}
		{
			p.SetState(1250)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1251)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1252)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1253)
			p.DatabaseScope()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1255)
			p.RevokeableGraphPrivileges()
		}
		{
			p.SetState(1256)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1257)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1258)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1259)
			p.GraphScope()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1261)
			p.DbmsPrivilege()
		}
		{
			p.SetState(1262)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1263)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1264)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1265)
			p.Match(CypherParserDBMS)
		}

	}

	return localctx
}

// IDatabaseScopeContext is an interface to support dynamic dispatch.
type IDatabaseScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseScopeContext differentiates from other interfaces.
	IsDatabaseScopeContext()
}

type DatabaseScopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseScopeContext() *DatabaseScopeContext {
	var p = new(DatabaseScopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_databaseScope
	return p
}

func (*DatabaseScopeContext) IsDatabaseScopeContext() {}

func NewDatabaseScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseScopeContext {
	var p = new(DatabaseScopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_databaseScope

	return p
}

func (s *DatabaseScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseScopeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DatabaseScopeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DatabaseScopeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *DatabaseScopeContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASES, 0)
}

func (s *DatabaseScopeContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *DatabaseScopeContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *DatabaseScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDatabaseScope(s)
	}
}

func (s *DatabaseScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDatabaseScope(s)
	}
}

func (p *CypherParser) DatabaseScope() (localctx IDatabaseScopeContext) {
	this := p
	_ = this

	localctx = NewDatabaseScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CypherParserRULE_databaseScope)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1288)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1269)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserDATABASE || _la == CypherParserDATABASES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1270)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1271)
			p.Match(CypherParserT__18)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1272)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserDATABASE || _la == CypherParserDATABASES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1273)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1274)
			p.SymbolicName()
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1276)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1275)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1278)
					p.Match(CypherParserT__14)
				}
				p.SetState(1280)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1279)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1282)
					p.SymbolicName()
				}

			}
			p.SetState(1287)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IGraphScopeContext is an interface to support dynamic dispatch.
type IGraphScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGraphScopeContext differentiates from other interfaces.
	IsGraphScopeContext()
}

type GraphScopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphScopeContext() *GraphScopeContext {
	var p = new(GraphScopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_graphScope
	return p
}

func (*GraphScopeContext) IsGraphScopeContext() {}

func NewGraphScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphScopeContext {
	var p = new(GraphScopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_graphScope

	return p
}

func (s *GraphScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphScopeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *GraphScopeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *GraphScopeContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(CypherParserGRAPH, 0)
}

func (s *GraphScopeContext) GRAPHS() antlr.TerminalNode {
	return s.GetToken(CypherParserGRAPHS, 0)
}

func (s *GraphScopeContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *GraphScopeContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *GraphScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterGraphScope(s)
	}
}

func (s *GraphScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitGraphScope(s)
	}
}

func (p *CypherParser) GraphScope() (localctx IGraphScopeContext) {
	this := p
	_ = this

	localctx = NewGraphScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CypherParserRULE_graphScope)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1309)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1290)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserGRAPH || _la == CypherParserGRAPHS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1291)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1292)
			p.Match(CypherParserT__18)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1293)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserGRAPH || _la == CypherParserGRAPHS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1294)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1295)
			p.SymbolicName()
		}
		p.SetState(1306)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1297)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1296)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1299)
					p.Match(CypherParserT__14)
				}
				p.SetState(1301)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1300)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1303)
					p.SymbolicName()
				}

			}
			p.SetState(1308)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IRolesContext is an interface to support dynamic dispatch.
type IRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRolesContext differentiates from other interfaces.
	IsRolesContext()
}

type RolesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRolesContext() *RolesContext {
	var p = new(RolesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_roles
	return p
}

func (*RolesContext) IsRolesContext() {}

func NewRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RolesContext {
	var p = new(RolesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_roles

	return p
}

func (s *RolesContext) GetParser() antlr.Parser { return s.parser }

func (s *RolesContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *RolesContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *RolesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RolesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRoles(s)
	}
}

func (s *RolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRoles(s)
	}
}

func (p *CypherParser) Roles() (localctx IRolesContext) {
	this := p
	_ = this

	localctx = NewRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CypherParserRULE_roles)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1311)
		p.SymbolicName()
	}
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1313)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1312)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1315)
				p.Match(CypherParserT__14)
			}
			p.SetState(1317)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1316)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1319)
				p.SymbolicName()
			}

		}
		p.SetState(1324)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
	}

	return localctx
}

// IGrantableGraphPrivilegesContext is an interface to support dynamic dispatch.
type IGrantableGraphPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrantableGraphPrivilegesContext differentiates from other interfaces.
	IsGrantableGraphPrivilegesContext()
}

type GrantableGraphPrivilegesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantableGraphPrivilegesContext() *GrantableGraphPrivilegesContext {
	var p = new(GrantableGraphPrivilegesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_grantableGraphPrivileges
	return p
}

func (*GrantableGraphPrivilegesContext) IsGrantableGraphPrivilegesContext() {}

func NewGrantableGraphPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantableGraphPrivilegesContext {
	var p = new(GrantableGraphPrivilegesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_grantableGraphPrivileges

	return p
}

func (s *GrantableGraphPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantableGraphPrivilegesContext) RevokeableGraphPrivileges() IRevokeableGraphPrivilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeableGraphPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeableGraphPrivilegesContext)
}

func (s *GrantableGraphPrivilegesContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *GrantableGraphPrivilegesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *GrantableGraphPrivilegesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *GrantableGraphPrivilegesContext) PropertiesList() IPropertiesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesListContext)
}

func (s *GrantableGraphPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantableGraphPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantableGraphPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterGrantableGraphPrivileges(s)
	}
}

func (s *GrantableGraphPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitGrantableGraphPrivileges(s)
	}
}

func (p *CypherParser) GrantableGraphPrivileges() (localctx IGrantableGraphPrivilegesContext) {
	this := p
	_ = this

	localctx = NewGrantableGraphPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CypherParserRULE_grantableGraphPrivileges)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1335)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1325)
			p.RevokeableGraphPrivileges()
		}

	case CypherParserMATCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1326)
			p.Match(CypherParserMATCH)
		}
		{
			p.SetState(1327)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1328)
			p.Match(CypherParserT__13)
		}
		p.SetState(1330)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1329)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1332)
			p.PropertiesList()
		}
		{
			p.SetState(1333)
			p.Match(CypherParserT__15)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRevokeableGraphPrivilegesContext is an interface to support dynamic dispatch.
type IRevokeableGraphPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRevokeableGraphPrivilegesContext differentiates from other interfaces.
	IsRevokeableGraphPrivilegesContext()
}

type RevokeableGraphPrivilegesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeableGraphPrivilegesContext() *RevokeableGraphPrivilegesContext {
	var p = new(RevokeableGraphPrivilegesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_revokeableGraphPrivileges
	return p
}

func (*RevokeableGraphPrivilegesContext) IsRevokeableGraphPrivilegesContext() {}

func NewRevokeableGraphPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeableGraphPrivilegesContext {
	var p = new(RevokeableGraphPrivilegesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_revokeableGraphPrivileges

	return p
}

func (s *RevokeableGraphPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeableGraphPrivilegesContext) TRAVERSE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRAVERSE, 0)
}

func (s *RevokeableGraphPrivilegesContext) READ() antlr.TerminalNode {
	return s.GetToken(CypherParserREAD, 0)
}

func (s *RevokeableGraphPrivilegesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RevokeableGraphPrivilegesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RevokeableGraphPrivilegesContext) PropertiesList() IPropertiesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesListContext)
}

func (s *RevokeableGraphPrivilegesContext) WRITE() antlr.TerminalNode {
	return s.GetToken(CypherParserWRITE, 0)
}

func (s *RevokeableGraphPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeableGraphPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeableGraphPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRevokeableGraphPrivileges(s)
	}
}

func (s *RevokeableGraphPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRevokeableGraphPrivileges(s)
	}
}

func (p *CypherParser) RevokeableGraphPrivileges() (localctx IRevokeableGraphPrivilegesContext) {
	this := p
	_ = this

	localctx = NewRevokeableGraphPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CypherParserRULE_revokeableGraphPrivileges)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1348)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserTRAVERSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1337)
			p.Match(CypherParserTRAVERSE)
		}

	case CypherParserREAD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1338)
			p.Match(CypherParserREAD)
		}
		{
			p.SetState(1339)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1340)
			p.Match(CypherParserT__13)
		}
		p.SetState(1342)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1341)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1344)
			p.PropertiesList()
		}
		{
			p.SetState(1345)
			p.Match(CypherParserT__15)
		}

	case CypherParserWRITE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1347)
			p.Match(CypherParserWRITE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDatasbasePrivilegeContext is an interface to support dynamic dispatch.
type IDatasbasePrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatasbasePrivilegeContext differentiates from other interfaces.
	IsDatasbasePrivilegeContext()
}

type DatasbasePrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatasbasePrivilegeContext() *DatasbasePrivilegeContext {
	var p = new(DatasbasePrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_datasbasePrivilege
	return p
}

func (*DatasbasePrivilegeContext) IsDatasbasePrivilegeContext() {}

func NewDatasbasePrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatasbasePrivilegeContext {
	var p = new(DatasbasePrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_datasbasePrivilege

	return p
}

func (s *DatasbasePrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *DatasbasePrivilegeContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(CypherParserACCESS, 0)
}

func (s *DatasbasePrivilegeContext) START() antlr.TerminalNode {
	return s.GetToken(CypherParserSTART, 0)
}

func (s *DatasbasePrivilegeContext) STOP() antlr.TerminalNode {
	return s.GetToken(CypherParserSTOP, 0)
}

func (s *DatasbasePrivilegeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *DatasbasePrivilegeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DatasbasePrivilegeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DatasbasePrivilegeContext) INDEX() antlr.TerminalNode {
	return s.GetToken(CypherParserINDEX, 0)
}

func (s *DatasbasePrivilegeContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(CypherParserINDEXES, 0)
}

func (s *DatasbasePrivilegeContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DatasbasePrivilegeContext) MANAGEMENT() antlr.TerminalNode {
	return s.GetToken(CypherParserMANAGEMENT, 0)
}

func (s *DatasbasePrivilegeContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *DatasbasePrivilegeContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINTS, 0)
}

func (s *DatasbasePrivilegeContext) NEW() antlr.TerminalNode {
	return s.GetToken(CypherParserNEW, 0)
}

func (s *DatasbasePrivilegeContext) LABEL() antlr.TerminalNode {
	return s.GetToken(CypherParserLABEL, 0)
}

func (s *DatasbasePrivilegeContext) LABELS() antlr.TerminalNode {
	return s.GetToken(CypherParserLABELS, 0)
}

func (s *DatasbasePrivilegeContext) NODE() antlr.TerminalNode {
	return s.GetToken(CypherParserNODE, 0)
}

func (s *DatasbasePrivilegeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(CypherParserTYPE, 0)
}

func (s *DatasbasePrivilegeContext) TYPES() antlr.TerminalNode {
	return s.GetToken(CypherParserTYPES, 0)
}

func (s *DatasbasePrivilegeContext) RELATIONSHIP() antlr.TerminalNode {
	return s.GetToken(CypherParserRELATIONSHIP, 0)
}

func (s *DatasbasePrivilegeContext) NAME() antlr.TerminalNode {
	return s.GetToken(CypherParserNAME, 0)
}

func (s *DatasbasePrivilegeContext) NAMES() antlr.TerminalNode {
	return s.GetToken(CypherParserNAMES, 0)
}

func (s *DatasbasePrivilegeContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(CypherParserPROPERTY, 0)
}

func (s *DatasbasePrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *DatasbasePrivilegeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(CypherParserPRIVILEGES, 0)
}

func (s *DatasbasePrivilegeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *DatasbasePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatasbasePrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatasbasePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDatasbasePrivilege(s)
	}
}

func (s *DatasbasePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDatasbasePrivilege(s)
	}
}

func (p *CypherParser) DatasbasePrivilege() (localctx IDatasbasePrivilegeContext) {
	this := p
	_ = this

	localctx = NewDatasbasePrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CypherParserRULE_datasbasePrivilege)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1350)
			p.Match(CypherParserACCESS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1351)
			p.Match(CypherParserSTART)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1352)
			p.Match(CypherParserSTOP)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1353)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1354)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1355)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserINDEX || _la == CypherParserINDEXES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1356)
			p.Match(CypherParserDROP)
		}
		{
			p.SetState(1357)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1358)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserINDEX || _la == CypherParserINDEXES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1359)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserINDEX || _la == CypherParserINDEXES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1360)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1361)
			p.Match(CypherParserMANAGEMENT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1362)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1363)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1364)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserCONSTRAINT || _la == CypherParserCONSTRAINTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1365)
			p.Match(CypherParserDROP)
		}
		{
			p.SetState(1366)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1367)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserCONSTRAINT || _la == CypherParserCONSTRAINTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1368)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserCONSTRAINT || _la == CypherParserCONSTRAINTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1369)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1370)
			p.Match(CypherParserMANAGEMENT)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1371)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1372)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1373)
			p.Match(CypherParserNEW)
		}
		{
			p.SetState(1374)
			p.Match(CypherParserSP)
		}
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserNODE {
			{
				p.SetState(1375)
				p.Match(CypherParserNODE)
			}
			{
				p.SetState(1376)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1379)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserLABEL || _la == CypherParserLABELS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1380)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1381)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1382)
			p.Match(CypherParserNEW)
		}
		{
			p.SetState(1383)
			p.Match(CypherParserSP)
		}
		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserRELATIONSHIP {
			{
				p.SetState(1384)
				p.Match(CypherParserRELATIONSHIP)
			}
			{
				p.SetState(1385)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1388)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserTYPE || _la == CypherParserTYPES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1389)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1390)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1391)
			p.Match(CypherParserNEW)
		}
		{
			p.SetState(1392)
			p.Match(CypherParserSP)
		}
		p.SetState(1395)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserPROPERTY {
			{
				p.SetState(1393)
				p.Match(CypherParserPROPERTY)
			}
			{
				p.SetState(1394)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1397)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserNAME || _la == CypherParserNAMES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1398)
			p.Match(CypherParserNAME)
		}
		p.SetState(1401)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1399)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1400)
				p.Match(CypherParserMANAGEMENT)
			}

		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1403)
			p.Match(CypherParserALL)
		}
		p.SetState(1410)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1404)
				p.Match(CypherParserSP)
			}
			p.SetState(1407)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserDATABASE {
				{
					p.SetState(1405)
					p.Match(CypherParserDATABASE)
				}
				{
					p.SetState(1406)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1409)
				p.Match(CypherParserPRIVILEGES)
			}

		}

	}

	return localctx
}

// IDbmsPrivilegeContext is an interface to support dynamic dispatch.
type IDbmsPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDbmsPrivilegeContext differentiates from other interfaces.
	IsDbmsPrivilegeContext()
}

type DbmsPrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDbmsPrivilegeContext() *DbmsPrivilegeContext {
	var p = new(DbmsPrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dbmsPrivilege
	return p
}

func (*DbmsPrivilegeContext) IsDbmsPrivilegeContext() {}

func NewDbmsPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DbmsPrivilegeContext {
	var p = new(DbmsPrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dbmsPrivilege

	return p
}

func (s *DbmsPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *DbmsPrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *DbmsPrivilegeContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *DbmsPrivilegeContext) MANAGEMENT() antlr.TerminalNode {
	return s.GetToken(CypherParserMANAGEMENT, 0)
}

func (s *DbmsPrivilegeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *DbmsPrivilegeContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DbmsPrivilegeContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CypherParserASSIGN, 0)
}

func (s *DbmsPrivilegeContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *DbmsPrivilegeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(CypherParserSHOW, 0)
}

func (s *DbmsPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DbmsPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DbmsPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDbmsPrivilege(s)
	}
}

func (s *DbmsPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDbmsPrivilege(s)
	}
}

func (p *CypherParser) DbmsPrivilege() (localctx IDbmsPrivilegeContext) {
	this := p
	_ = this

	localctx = NewDbmsPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CypherParserRULE_dbmsPrivilege)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1432)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserROLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1414)
			p.Match(CypherParserROLE)
		}
		{
			p.SetState(1415)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1416)
			p.Match(CypherParserMANAGEMENT)
		}

	case CypherParserCREATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1417)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1418)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1419)
			p.Match(CypherParserROLE)
		}

	case CypherParserDROP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1420)
			p.Match(CypherParserDROP)
		}
		{
			p.SetState(1421)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1422)
			p.Match(CypherParserROLE)
		}

	case CypherParserASSIGN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1423)
			p.Match(CypherParserASSIGN)
		}
		{
			p.SetState(1424)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1425)
			p.Match(CypherParserROLE)
		}

	case CypherParserREMOVE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1426)
			p.Match(CypherParserREMOVE)
		}
		{
			p.SetState(1427)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1428)
			p.Match(CypherParserROLE)
		}

	case CypherParserSHOW:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1429)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(1430)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1431)
			p.Match(CypherParserROLE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IElementScopeContext is an interface to support dynamic dispatch.
type IElementScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementScopeContext differentiates from other interfaces.
	IsElementScopeContext()
}

type ElementScopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementScopeContext() *ElementScopeContext {
	var p = new(ElementScopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_elementScope
	return p
}

func (*ElementScopeContext) IsElementScopeContext() {}

func NewElementScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementScopeContext {
	var p = new(ElementScopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_elementScope

	return p
}

func (s *ElementScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementScopeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ElementScopeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ElementScopeContext) PropertiesList() IPropertiesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesListContext)
}

func (s *ElementScopeContext) RELATIONSHIP() antlr.TerminalNode {
	return s.GetToken(CypherParserRELATIONSHIP, 0)
}

func (s *ElementScopeContext) RELATIONSHIPS() antlr.TerminalNode {
	return s.GetToken(CypherParserRELATIONSHIPS, 0)
}

func (s *ElementScopeContext) PropertyScope() IPropertyScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyScopeContext)
}

func (s *ElementScopeContext) NODE() antlr.TerminalNode {
	return s.GetToken(CypherParserNODE, 0)
}

func (s *ElementScopeContext) NODES() antlr.TerminalNode {
	return s.GetToken(CypherParserNODES, 0)
}

func (s *ElementScopeContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(CypherParserELEMENT, 0)
}

func (s *ElementScopeContext) ELEMENTS() antlr.TerminalNode {
	return s.GetToken(CypherParserELEMENTS, 0)
}

func (s *ElementScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterElementScope(s)
	}
}

func (s *ElementScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitElementScope(s)
	}
}

func (p *CypherParser) ElementScope() (localctx IElementScopeContext) {
	this := p
	_ = this

	localctx = NewElementScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CypherParserRULE_elementScope)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserRELATIONSHIP, CypherParserRELATIONSHIPS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1434)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserRELATIONSHIP || _la == CypherParserRELATIONSHIPS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1435)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1436)
			p.PropertiesList()
		}
		p.SetState(1439)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1437)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1438)
				p.PropertyScope()
			}

		}

	case CypherParserNODE, CypherParserNODES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1441)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserNODE || _la == CypherParserNODES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1442)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1443)
			p.PropertiesList()
		}
		p.SetState(1446)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1444)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1445)
				p.PropertyScope()
			}

		}

	case CypherParserELEMENT, CypherParserELEMENTS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1448)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserELEMENT || _la == CypherParserELEMENTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1449)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1450)
			p.PropertiesList()
		}
		p.SetState(1453)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1451)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1452)
				p.PropertyScope()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertiesListContext is an interface to support dynamic dispatch.
type IPropertiesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertiesListContext differentiates from other interfaces.
	IsPropertiesListContext()
}

type PropertiesListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesListContext() *PropertiesListContext {
	var p = new(PropertiesListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertiesList
	return p
}

func (*PropertiesListContext) IsPropertiesListContext() {}

func NewPropertiesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesListContext {
	var p = new(PropertiesListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertiesList

	return p
}

func (s *PropertiesListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesListContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *PropertiesListContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *PropertiesListContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertiesListContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertiesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertiesList(s)
	}
}

func (s *PropertiesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertiesList(s)
	}
}

func (p *CypherParser) PropertiesList() (localctx IPropertiesListContext) {
	this := p
	_ = this

	localctx = NewPropertiesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CypherParserRULE_propertiesList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1472)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__18:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1457)
			p.Match(CypherParserT__18)
		}

	case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1458)
			p.SymbolicName()
		}
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1460)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1459)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1462)
					p.Match(CypherParserT__14)
				}
				p.SetState(1464)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1463)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1466)
					p.SymbolicName()
				}

			}
			p.SetState(1471)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertyScopeContext is an interface to support dynamic dispatch.
type IPropertyScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyScopeContext differentiates from other interfaces.
	IsPropertyScopeContext()
}

type PropertyScopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyScopeContext() *PropertyScopeContext {
	var p = new(PropertyScopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyScope
	return p
}

func (*PropertyScopeContext) IsPropertyScopeContext() {}

func NewPropertyScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyScopeContext {
	var p = new(PropertyScopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyScope

	return p
}

func (s *PropertyScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyScopeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyScopeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyScope(s)
	}
}

func (s *PropertyScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyScope(s)
	}
}

func (p *CypherParser) PropertyScope() (localctx IPropertyScopeContext) {
	this := p
	_ = this

	localctx = NewPropertyScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CypherParserRULE_propertyScope)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1474)
		p.Match(CypherParserT__19)
	}
	p.SetState(1476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1475)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1478)
		p.Match(CypherParserT__18)
	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1479)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1482)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IShowDatabaseContext is an interface to support dynamic dispatch.
type IShowDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowDatabaseContext differentiates from other interfaces.
	IsShowDatabaseContext()
}

type ShowDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDatabaseContext() *ShowDatabaseContext {
	var p = new(ShowDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_showDatabase
	return p
}

func (*ShowDatabaseContext) IsShowDatabaseContext() {}

func NewShowDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDatabaseContext {
	var p = new(ShowDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_showDatabase

	return p
}

func (s *ShowDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDatabaseContext) SHOW() antlr.TerminalNode {
	return s.GetToken(CypherParserSHOW, 0)
}

func (s *ShowDatabaseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ShowDatabaseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ShowDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *ShowDatabaseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(CypherParserDEFAULT, 0)
}

func (s *ShowDatabaseContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASES, 0)
}

func (s *ShowDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterShowDatabase(s)
	}
}

func (s *ShowDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitShowDatabase(s)
	}
}

func (p *CypherParser) ShowDatabase() (localctx IShowDatabaseContext) {
	this := p
	_ = this

	localctx = NewShowDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CypherParserRULE_showDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1484)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(1485)
			p.Match(CypherParserSP)
		}
		p.SetState(1488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserDEFAULT {
			{
				p.SetState(1486)
				p.Match(CypherParserDEFAULT)
			}
			{
				p.SetState(1487)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1490)
			p.Match(CypherParserDATABASE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1491)
			p.Match(CypherParserSHOW)
		}
		{
			p.SetState(1492)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1493)
			p.Match(CypherParserDATABASES)
		}

	}

	return localctx
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createDatabase
	return p
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateDatabaseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CreateDatabaseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *CreateDatabaseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (p *CypherParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	this := p
	_ = this

	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CypherParserRULE_createDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1496)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1497)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1498)
			p.Match(CypherParserDATABASE)
		}
		{
			p.SetState(1499)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1500)
			p.SymbolicName()
		}
		p.SetState(1503)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1501)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1502)
				p.IfNotExists()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1505)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1506)
			p.Match(CypherParserSP)
		}
		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserOR {
			{
				p.SetState(1507)
				p.OrReplace()
			}
			{
				p.SetState(1508)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1512)
			p.Match(CypherParserDATABASE)
		}
		{
			p.SetState(1513)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1514)
			p.SymbolicName()
		}

	}

	return localctx
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropDatabase
	return p
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropDatabaseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DropDatabaseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *DropDatabaseContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *DropDatabaseContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (p *CypherParser) DropDatabase() (localctx IDropDatabaseContext) {
	this := p
	_ = this

	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CypherParserRULE_dropDatabase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1518)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1519)
		p.Match(CypherParserDATABASE)
	}
	{
		p.SetState(1520)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1521)
		p.SymbolicName()
	}
	p.SetState(1524)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1522)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1523)
			p.IfExists()
		}

	}

	return localctx
}

// IStartDatabaseContext is an interface to support dynamic dispatch.
type IStartDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartDatabaseContext differentiates from other interfaces.
	IsStartDatabaseContext()
}

type StartDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartDatabaseContext() *StartDatabaseContext {
	var p = new(StartDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_startDatabase
	return p
}

func (*StartDatabaseContext) IsStartDatabaseContext() {}

func NewStartDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartDatabaseContext {
	var p = new(StartDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_startDatabase

	return p
}

func (s *StartDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *StartDatabaseContext) START() antlr.TerminalNode {
	return s.GetToken(CypherParserSTART, 0)
}

func (s *StartDatabaseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StartDatabaseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StartDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *StartDatabaseContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *StartDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStartDatabase(s)
	}
}

func (s *StartDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStartDatabase(s)
	}
}

func (p *CypherParser) StartDatabase() (localctx IStartDatabaseContext) {
	this := p
	_ = this

	localctx = NewStartDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CypherParserRULE_startDatabase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		p.Match(CypherParserSTART)
	}
	{
		p.SetState(1527)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1528)
		p.Match(CypherParserDATABASE)
	}
	{
		p.SetState(1529)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1530)
		p.SymbolicName()
	}

	return localctx
}

// IStopDatabaseContext is an interface to support dynamic dispatch.
type IStopDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStopDatabaseContext differentiates from other interfaces.
	IsStopDatabaseContext()
}

type StopDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopDatabaseContext() *StopDatabaseContext {
	var p = new(StopDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_stopDatabase
	return p
}

func (*StopDatabaseContext) IsStopDatabaseContext() {}

func NewStopDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopDatabaseContext {
	var p = new(StopDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stopDatabase

	return p
}

func (s *StopDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *StopDatabaseContext) STOP() antlr.TerminalNode {
	return s.GetToken(CypherParserSTOP, 0)
}

func (s *StopDatabaseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StopDatabaseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StopDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *StopDatabaseContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *StopDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStopDatabase(s)
	}
}

func (s *StopDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStopDatabase(s)
	}
}

func (p *CypherParser) StopDatabase() (localctx IStopDatabaseContext) {
	this := p
	_ = this

	localctx = NewStopDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CypherParserRULE_stopDatabase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1532)
		p.Match(CypherParserSTOP)
	}
	{
		p.SetState(1533)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1534)
		p.Match(CypherParserDATABASE)
	}
	{
		p.SetState(1535)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1536)
		p.SymbolicName()
	}

	return localctx
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_ifNotExists
	return p
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(CypherParserIF, 0)
}

func (s *IfNotExistsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *IfNotExistsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (p *CypherParser) IfNotExists() (localctx IIfNotExistsContext) {
	this := p
	_ = this

	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CypherParserRULE_ifNotExists)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1538)
		p.Match(CypherParserIF)
	}
	{
		p.SetState(1539)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1540)
		p.Match(CypherParserNOT)
	}
	{
		p.SetState(1541)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1542)
		p.Match(CypherParserEXISTS)
	}

	return localctx
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_ifExists
	return p
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(CypherParserIF, 0)
}

func (s *IfExistsContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *IfExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (p *CypherParser) IfExists() (localctx IIfExistsContext) {
	this := p
	_ = this

	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CypherParserRULE_ifExists)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1544)
		p.Match(CypherParserIF)
	}
	{
		p.SetState(1545)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1546)
		p.Match(CypherParserEXISTS)
	}

	return localctx
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_orReplace
	return p
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(CypherParserOR, 0)
}

func (s *OrReplaceContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(CypherParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (p *CypherParser) OrReplace() (localctx IOrReplaceContext) {
	this := p
	_ = this

	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CypherParserRULE_orReplace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1548)
		p.Match(CypherParserOR)
	}
	{
		p.SetState(1549)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1550)
		p.Match(CypherParserREPLACE)
	}

	return localctx
}

// ISetPasswordContext is an interface to support dynamic dispatch.
type ISetPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetPasswordContext differentiates from other interfaces.
	IsSetPasswordContext()
}

type SetPasswordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetPasswordContext() *SetPasswordContext {
	var p = new(SetPasswordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_setPassword
	return p
}

func (*SetPasswordContext) IsSetPasswordContext() {}

func NewSetPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetPasswordContext {
	var p = new(SetPasswordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setPassword

	return p
}

func (s *SetPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *SetPasswordContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *SetPasswordContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SetPasswordContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SetPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(CypherParserPASSWORD, 0)
}

func (s *SetPasswordContext) Password() IPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordContext)
}

func (s *SetPasswordContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *SetPasswordContext) PasswordStatus() IPasswordStatusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordStatusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordStatusContext)
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

func (p *CypherParser) SetPassword() (localctx ISetPasswordContext) {
	this := p
	_ = this

	localctx = NewSetPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CypherParserRULE_setPassword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1569)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1552)
			p.Match(CypherParserSET)
		}
		{
			p.SetState(1553)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1554)
			p.Match(CypherParserPASSWORD)
		}
		{
			p.SetState(1555)
			p.Match(CypherParserSP)
		}
		p.SetState(1558)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
			{
				p.SetState(1556)
				p.Password()
			}

		case CypherParserT__13, CypherParserT__33:
			{
				p.SetState(1557)
				p.Parameter()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1560)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1561)
				p.PasswordStatus()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1564)
			p.Match(CypherParserSET)
		}
		{
			p.SetState(1565)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1566)
			p.Match(CypherParserPASSWORD)
		}
		{
			p.SetState(1567)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1568)
			p.PasswordStatus()
		}

	}

	return localctx
}

// IPasswordStatusContext is an interface to support dynamic dispatch.
type IPasswordStatusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPasswordStatusContext differentiates from other interfaces.
	IsPasswordStatusContext()
}

type PasswordStatusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordStatusContext() *PasswordStatusContext {
	var p = new(PasswordStatusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_passwordStatus
	return p
}

func (*PasswordStatusContext) IsPasswordStatusContext() {}

func NewPasswordStatusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordStatusContext {
	var p = new(PasswordStatusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_passwordStatus

	return p
}

func (s *PasswordStatusContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordStatusContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(CypherParserCHANGE, 0)
}

func (s *PasswordStatusContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PasswordStatusContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PasswordStatusContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(CypherParserREQUIRED, 0)
}

func (s *PasswordStatusContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *PasswordStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordStatusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPasswordStatus(s)
	}
}

func (s *PasswordStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPasswordStatus(s)
	}
}

func (p *CypherParser) PasswordStatus() (localctx IPasswordStatusContext) {
	this := p
	_ = this

	localctx = NewPasswordStatusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CypherParserRULE_passwordStatus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1571)
		p.Match(CypherParserCHANGE)
	}
	{
		p.SetState(1572)
		p.Match(CypherParserSP)
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserNOT {
		{
			p.SetState(1573)
			p.Match(CypherParserNOT)
		}
		{
			p.SetState(1574)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1577)
		p.Match(CypherParserREQUIRED)
	}

	return localctx
}

// ISetStatusContext is an interface to support dynamic dispatch.
type ISetStatusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetStatusContext differentiates from other interfaces.
	IsSetStatusContext()
}

type SetStatusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatusContext() *SetStatusContext {
	var p = new(SetStatusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_setStatus
	return p
}

func (*SetStatusContext) IsSetStatusContext() {}

func NewSetStatusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatusContext {
	var p = new(SetStatusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setStatus

	return p
}

func (s *SetStatusContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *SetStatusContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SetStatusContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SetStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTATUS, 0)
}

func (s *SetStatusContext) UserStatus() IUserStatusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserStatusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserStatusContext)
}

func (s *SetStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSetStatus(s)
	}
}

func (s *SetStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSetStatus(s)
	}
}

func (p *CypherParser) SetStatus() (localctx ISetStatusContext) {
	this := p
	_ = this

	localctx = NewSetStatusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CypherParserRULE_setStatus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1579)
		p.Match(CypherParserSET)
	}
	{
		p.SetState(1580)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1581)
		p.Match(CypherParserSTATUS)
	}
	{
		p.SetState(1582)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1583)
		p.UserStatus()
	}

	return localctx
}

// IUserStatusContext is an interface to support dynamic dispatch.
type IUserStatusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserStatusContext differentiates from other interfaces.
	IsUserStatusContext()
}

type UserStatusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserStatusContext() *UserStatusContext {
	var p = new(UserStatusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_userStatus
	return p
}

func (*UserStatusContext) IsUserStatusContext() {}

func NewUserStatusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserStatusContext {
	var p = new(UserStatusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_userStatus

	return p
}

func (s *UserStatusContext) GetParser() antlr.Parser { return s.parser }

func (s *UserStatusContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(CypherParserACTIVE, 0)
}

func (s *UserStatusContext) SUSPENDED() antlr.TerminalNode {
	return s.GetToken(CypherParserSUSPENDED, 0)
}

func (s *UserStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserStatusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUserStatus(s)
	}
}

func (s *UserStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUserStatus(s)
	}
}

func (p *CypherParser) UserStatus() (localctx IUserStatusContext) {
	this := p
	_ = this

	localctx = NewUserStatusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CypherParserRULE_userStatus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1585)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserACTIVE || _la == CypherParserSUSPENDED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICreateUniqueConstraintContext is an interface to support dynamic dispatch.
type ICreateUniqueConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateUniqueConstraintContext differentiates from other interfaces.
	IsCreateUniqueConstraintContext()
}

type CreateUniqueConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUniqueConstraintContext() *CreateUniqueConstraintContext {
	var p = new(CreateUniqueConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createUniqueConstraint
	return p
}

func (*CreateUniqueConstraintContext) IsCreateUniqueConstraintContext() {}

func NewCreateUniqueConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUniqueConstraintContext {
	var p = new(CreateUniqueConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createUniqueConstraint

	return p
}

func (s *CreateUniqueConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUniqueConstraintContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateUniqueConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateUniqueConstraintContext) UniqueConstraint() IUniqueConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueConstraintContext)
}

func (s *CreateUniqueConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUniqueConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUniqueConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateUniqueConstraint(s)
	}
}

func (s *CreateUniqueConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateUniqueConstraint(s)
	}
}

func (p *CypherParser) CreateUniqueConstraint() (localctx ICreateUniqueConstraintContext) {
	this := p
	_ = this

	localctx = NewCreateUniqueConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CypherParserRULE_createUniqueConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1587)
		p.Match(CypherParserCREATE)
	}
	{
		p.SetState(1588)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1589)
		p.UniqueConstraint()
	}

	return localctx
}

// ICreateNodeKeyConstraintContext is an interface to support dynamic dispatch.
type ICreateNodeKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateNodeKeyConstraintContext differentiates from other interfaces.
	IsCreateNodeKeyConstraintContext()
}

type CreateNodeKeyConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateNodeKeyConstraintContext() *CreateNodeKeyConstraintContext {
	var p = new(CreateNodeKeyConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createNodeKeyConstraint
	return p
}

func (*CreateNodeKeyConstraintContext) IsCreateNodeKeyConstraintContext() {}

func NewCreateNodeKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateNodeKeyConstraintContext {
	var p = new(CreateNodeKeyConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createNodeKeyConstraint

	return p
}

func (s *CreateNodeKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateNodeKeyConstraintContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateNodeKeyConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateNodeKeyConstraintContext) NodeKeyConstraint() INodeKeyConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeKeyConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeKeyConstraintContext)
}

func (s *CreateNodeKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateNodeKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateNodeKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateNodeKeyConstraint(s)
	}
}

func (s *CreateNodeKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateNodeKeyConstraint(s)
	}
}

func (p *CypherParser) CreateNodeKeyConstraint() (localctx ICreateNodeKeyConstraintContext) {
	this := p
	_ = this

	localctx = NewCreateNodeKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CypherParserRULE_createNodeKeyConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1591)
		p.Match(CypherParserCREATE)
	}
	{
		p.SetState(1592)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1593)
		p.NodeKeyConstraint()
	}

	return localctx
}

// ICreateNodePropertyExistenceConstraintContext is an interface to support dynamic dispatch.
type ICreateNodePropertyExistenceConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateNodePropertyExistenceConstraintContext differentiates from other interfaces.
	IsCreateNodePropertyExistenceConstraintContext()
}

type CreateNodePropertyExistenceConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateNodePropertyExistenceConstraintContext() *CreateNodePropertyExistenceConstraintContext {
	var p = new(CreateNodePropertyExistenceConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createNodePropertyExistenceConstraint
	return p
}

func (*CreateNodePropertyExistenceConstraintContext) IsCreateNodePropertyExistenceConstraintContext() {
}

func NewCreateNodePropertyExistenceConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateNodePropertyExistenceConstraintContext {
	var p = new(CreateNodePropertyExistenceConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createNodePropertyExistenceConstraint

	return p
}

func (s *CreateNodePropertyExistenceConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateNodePropertyExistenceConstraintContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateNodePropertyExistenceConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateNodePropertyExistenceConstraintContext) NodePropertyExistenceConstraint() INodePropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePropertyExistenceConstraintContext)
}

func (s *CreateNodePropertyExistenceConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateNodePropertyExistenceConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateNodePropertyExistenceConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateNodePropertyExistenceConstraint(s)
	}
}

func (s *CreateNodePropertyExistenceConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateNodePropertyExistenceConstraint(s)
	}
}

func (p *CypherParser) CreateNodePropertyExistenceConstraint() (localctx ICreateNodePropertyExistenceConstraintContext) {
	this := p
	_ = this

	localctx = NewCreateNodePropertyExistenceConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CypherParserRULE_createNodePropertyExistenceConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1595)
		p.Match(CypherParserCREATE)
	}
	{
		p.SetState(1596)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1597)
		p.NodePropertyExistenceConstraint()
	}

	return localctx
}

// ICreateRelationshipPropertyExistenceConstraintContext is an interface to support dynamic dispatch.
type ICreateRelationshipPropertyExistenceConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateRelationshipPropertyExistenceConstraintContext differentiates from other interfaces.
	IsCreateRelationshipPropertyExistenceConstraintContext()
}

type CreateRelationshipPropertyExistenceConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRelationshipPropertyExistenceConstraintContext() *CreateRelationshipPropertyExistenceConstraintContext {
	var p = new(CreateRelationshipPropertyExistenceConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createRelationshipPropertyExistenceConstraint
	return p
}

func (*CreateRelationshipPropertyExistenceConstraintContext) IsCreateRelationshipPropertyExistenceConstraintContext() {
}

func NewCreateRelationshipPropertyExistenceConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRelationshipPropertyExistenceConstraintContext {
	var p = new(CreateRelationshipPropertyExistenceConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createRelationshipPropertyExistenceConstraint

	return p
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) RelationshipPropertyExistenceConstraint() IRelationshipPropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipPropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipPropertyExistenceConstraintContext)
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateRelationshipPropertyExistenceConstraint(s)
	}
}

func (s *CreateRelationshipPropertyExistenceConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateRelationshipPropertyExistenceConstraint(s)
	}
}

func (p *CypherParser) CreateRelationshipPropertyExistenceConstraint() (localctx ICreateRelationshipPropertyExistenceConstraintContext) {
	this := p
	_ = this

	localctx = NewCreateRelationshipPropertyExistenceConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CypherParserRULE_createRelationshipPropertyExistenceConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1599)
		p.Match(CypherParserCREATE)
	}
	{
		p.SetState(1600)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1601)
		p.RelationshipPropertyExistenceConstraint()
	}

	return localctx
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createIndex
	return p
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateIndexContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateIndexContext) Index() IIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexContext)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (p *CypherParser) CreateIndex() (localctx ICreateIndexContext) {
	this := p
	_ = this

	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CypherParserRULE_createIndex)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1603)
		p.Match(CypherParserCREATE)
	}
	{
		p.SetState(1604)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1605)
		p.Index()
	}

	return localctx
}

// IDropUniqueConstraintContext is an interface to support dynamic dispatch.
type IDropUniqueConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropUniqueConstraintContext differentiates from other interfaces.
	IsDropUniqueConstraintContext()
}

type DropUniqueConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUniqueConstraintContext() *DropUniqueConstraintContext {
	var p = new(DropUniqueConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropUniqueConstraint
	return p
}

func (*DropUniqueConstraintContext) IsDropUniqueConstraintContext() {}

func NewDropUniqueConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUniqueConstraintContext {
	var p = new(DropUniqueConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropUniqueConstraint

	return p
}

func (s *DropUniqueConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUniqueConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropUniqueConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *DropUniqueConstraintContext) UniqueConstraint() IUniqueConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUniqueConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUniqueConstraintContext)
}

func (s *DropUniqueConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUniqueConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUniqueConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropUniqueConstraint(s)
	}
}

func (s *DropUniqueConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropUniqueConstraint(s)
	}
}

func (p *CypherParser) DropUniqueConstraint() (localctx IDropUniqueConstraintContext) {
	this := p
	_ = this

	localctx = NewDropUniqueConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CypherParserRULE_dropUniqueConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1607)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1608)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1609)
		p.UniqueConstraint()
	}

	return localctx
}

// IDropNodeKeyConstraintContext is an interface to support dynamic dispatch.
type IDropNodeKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropNodeKeyConstraintContext differentiates from other interfaces.
	IsDropNodeKeyConstraintContext()
}

type DropNodeKeyConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropNodeKeyConstraintContext() *DropNodeKeyConstraintContext {
	var p = new(DropNodeKeyConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropNodeKeyConstraint
	return p
}

func (*DropNodeKeyConstraintContext) IsDropNodeKeyConstraintContext() {}

func NewDropNodeKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropNodeKeyConstraintContext {
	var p = new(DropNodeKeyConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropNodeKeyConstraint

	return p
}

func (s *DropNodeKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *DropNodeKeyConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropNodeKeyConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *DropNodeKeyConstraintContext) NodeKeyConstraint() INodeKeyConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeKeyConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeKeyConstraintContext)
}

func (s *DropNodeKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropNodeKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropNodeKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropNodeKeyConstraint(s)
	}
}

func (s *DropNodeKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropNodeKeyConstraint(s)
	}
}

func (p *CypherParser) DropNodeKeyConstraint() (localctx IDropNodeKeyConstraintContext) {
	this := p
	_ = this

	localctx = NewDropNodeKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CypherParserRULE_dropNodeKeyConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1612)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1613)
		p.NodeKeyConstraint()
	}

	return localctx
}

// IDropNodePropertyExistenceConstraintContext is an interface to support dynamic dispatch.
type IDropNodePropertyExistenceConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropNodePropertyExistenceConstraintContext differentiates from other interfaces.
	IsDropNodePropertyExistenceConstraintContext()
}

type DropNodePropertyExistenceConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropNodePropertyExistenceConstraintContext() *DropNodePropertyExistenceConstraintContext {
	var p = new(DropNodePropertyExistenceConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropNodePropertyExistenceConstraint
	return p
}

func (*DropNodePropertyExistenceConstraintContext) IsDropNodePropertyExistenceConstraintContext() {}

func NewDropNodePropertyExistenceConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropNodePropertyExistenceConstraintContext {
	var p = new(DropNodePropertyExistenceConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropNodePropertyExistenceConstraint

	return p
}

func (s *DropNodePropertyExistenceConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *DropNodePropertyExistenceConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropNodePropertyExistenceConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *DropNodePropertyExistenceConstraintContext) NodePropertyExistenceConstraint() INodePropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePropertyExistenceConstraintContext)
}

func (s *DropNodePropertyExistenceConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropNodePropertyExistenceConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropNodePropertyExistenceConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropNodePropertyExistenceConstraint(s)
	}
}

func (s *DropNodePropertyExistenceConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropNodePropertyExistenceConstraint(s)
	}
}

func (p *CypherParser) DropNodePropertyExistenceConstraint() (localctx IDropNodePropertyExistenceConstraintContext) {
	this := p
	_ = this

	localctx = NewDropNodePropertyExistenceConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CypherParserRULE_dropNodePropertyExistenceConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1616)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1617)
		p.NodePropertyExistenceConstraint()
	}

	return localctx
}

// IDropRelationshipPropertyExistenceConstraintContext is an interface to support dynamic dispatch.
type IDropRelationshipPropertyExistenceConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropRelationshipPropertyExistenceConstraintContext differentiates from other interfaces.
	IsDropRelationshipPropertyExistenceConstraintContext()
}

type DropRelationshipPropertyExistenceConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRelationshipPropertyExistenceConstraintContext() *DropRelationshipPropertyExistenceConstraintContext {
	var p = new(DropRelationshipPropertyExistenceConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropRelationshipPropertyExistenceConstraint
	return p
}

func (*DropRelationshipPropertyExistenceConstraintContext) IsDropRelationshipPropertyExistenceConstraintContext() {
}

func NewDropRelationshipPropertyExistenceConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRelationshipPropertyExistenceConstraintContext {
	var p = new(DropRelationshipPropertyExistenceConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropRelationshipPropertyExistenceConstraint

	return p
}

func (s *DropRelationshipPropertyExistenceConstraintContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *DropRelationshipPropertyExistenceConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropRelationshipPropertyExistenceConstraintContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *DropRelationshipPropertyExistenceConstraintContext) RelationshipPropertyExistenceConstraint() IRelationshipPropertyExistenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipPropertyExistenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipPropertyExistenceConstraintContext)
}

func (s *DropRelationshipPropertyExistenceConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRelationshipPropertyExistenceConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRelationshipPropertyExistenceConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropRelationshipPropertyExistenceConstraint(s)
	}
}

func (s *DropRelationshipPropertyExistenceConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropRelationshipPropertyExistenceConstraint(s)
	}
}

func (p *CypherParser) DropRelationshipPropertyExistenceConstraint() (localctx IDropRelationshipPropertyExistenceConstraintContext) {
	this := p
	_ = this

	localctx = NewDropRelationshipPropertyExistenceConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CypherParserRULE_dropRelationshipPropertyExistenceConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1619)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1620)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1621)
		p.RelationshipPropertyExistenceConstraint()
	}

	return localctx
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dropIndex
	return p
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *DropIndexContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *DropIndexContext) Index() IIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexContext)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (p *CypherParser) DropIndex() (localctx IDropIndexContext) {
	this := p
	_ = this

	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CypherParserRULE_dropIndex)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		p.Match(CypherParserDROP)
	}
	{
		p.SetState(1624)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1625)
		p.Index()
	}

	return localctx
}

// IIndexContext is an interface to support dynamic dispatch.
type IIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexContext differentiates from other interfaces.
	IsIndexContext()
}

type IndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexContext() *IndexContext {
	var p = new(IndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_index
	return p
}

func (*IndexContext) IsIndexContext() {}

func NewIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexContext {
	var p = new(IndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_index

	return p
}

func (s *IndexContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(CypherParserINDEX, 0)
}

func (s *IndexContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *IndexContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *IndexContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *IndexContext) NodeLabel() INodeLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *IndexContext) PropertyKeys() IPropertyKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeysContext)
}

func (s *IndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIndex(s)
	}
}

func (s *IndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIndex(s)
	}
}

func (p *CypherParser) Index() (localctx IIndexContext) {
	this := p
	_ = this

	localctx = NewIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CypherParserRULE_index)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(CypherParserINDEX)
	}
	{
		p.SetState(1628)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1629)
		p.Match(CypherParserON)
	}
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1630)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1633)
		p.NodeLabel()
	}
	p.SetState(1635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1634)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1637)
		p.Match(CypherParserT__19)
	}
	p.SetState(1639)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1638)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1641)
		p.PropertyKeys()
	}
	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1642)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1645)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IUniqueConstraintContext is an interface to support dynamic dispatch.
type IUniqueConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUniqueConstraintContext differentiates from other interfaces.
	IsUniqueConstraintContext()
}

type UniqueConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueConstraintContext() *UniqueConstraintContext {
	var p = new(UniqueConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_uniqueConstraint
	return p
}

func (*UniqueConstraintContext) IsUniqueConstraintContext() {}

func NewUniqueConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueConstraintContext {
	var p = new(UniqueConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_uniqueConstraint

	return p
}

func (s *UniqueConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *UniqueConstraintContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UniqueConstraintContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UniqueConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *UniqueConstraintContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *UniqueConstraintContext) NodeLabel() INodeLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *UniqueConstraintContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(CypherParserASSERT, 0)
}

func (s *UniqueConstraintContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *UniqueConstraintContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *UniqueConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CypherParserUNIQUE, 0)
}

func (s *UniqueConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UniqueConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUniqueConstraint(s)
	}
}

func (s *UniqueConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUniqueConstraint(s)
	}
}

func (p *CypherParser) UniqueConstraint() (localctx IUniqueConstraintContext) {
	this := p
	_ = this

	localctx = NewUniqueConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CypherParserRULE_uniqueConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1647)
		p.Match(CypherParserCONSTRAINT)
	}
	{
		p.SetState(1648)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1649)
		p.Match(CypherParserON)
	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1650)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1653)
		p.Match(CypherParserT__19)
	}
	p.SetState(1655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1654)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1657)
		p.Variable()
	}
	{
		p.SetState(1658)
		p.NodeLabel()
	}
	p.SetState(1660)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1659)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1662)
		p.Match(CypherParserT__20)
	}
	p.SetState(1664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1663)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1666)
		p.Match(CypherParserASSERT)
	}
	{
		p.SetState(1667)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1668)
		p.PropertyExpression()
	}
	{
		p.SetState(1669)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1670)
		p.Match(CypherParserIS)
	}
	{
		p.SetState(1671)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1672)
		p.Match(CypherParserUNIQUE)
	}

	return localctx
}

// INodeKeyConstraintContext is an interface to support dynamic dispatch.
type INodeKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeKeyConstraintContext differentiates from other interfaces.
	IsNodeKeyConstraintContext()
}

type NodeKeyConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeKeyConstraintContext() *NodeKeyConstraintContext {
	var p = new(NodeKeyConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeKeyConstraint
	return p
}

func (*NodeKeyConstraintContext) IsNodeKeyConstraintContext() {}

func NewNodeKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeKeyConstraintContext {
	var p = new(NodeKeyConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeKeyConstraint

	return p
}

func (s *NodeKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeKeyConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *NodeKeyConstraintContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodeKeyConstraintContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodeKeyConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *NodeKeyConstraintContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *NodeKeyConstraintContext) NodeLabel() INodeLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *NodeKeyConstraintContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(CypherParserASSERT, 0)
}

func (s *NodeKeyConstraintContext) PropertyExpressions() IPropertyExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionsContext)
}

func (s *NodeKeyConstraintContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *NodeKeyConstraintContext) NODE() antlr.TerminalNode {
	return s.GetToken(CypherParserNODE, 0)
}

func (s *NodeKeyConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(CypherParserKEY, 0)
}

func (s *NodeKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodeKeyConstraint(s)
	}
}

func (s *NodeKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodeKeyConstraint(s)
	}
}

func (p *CypherParser) NodeKeyConstraint() (localctx INodeKeyConstraintContext) {
	this := p
	_ = this

	localctx = NewNodeKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CypherParserRULE_nodeKeyConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1674)
		p.Match(CypherParserCONSTRAINT)
	}
	{
		p.SetState(1675)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1676)
		p.Match(CypherParserON)
	}
	p.SetState(1678)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1677)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1680)
		p.Match(CypherParserT__19)
	}
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1681)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1684)
		p.Variable()
	}
	{
		p.SetState(1685)
		p.NodeLabel()
	}
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1686)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1689)
		p.Match(CypherParserT__20)
	}
	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1690)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1693)
		p.Match(CypherParserASSERT)
	}
	{
		p.SetState(1694)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1695)
		p.Match(CypherParserT__19)
	}
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1696)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1699)
		p.PropertyExpressions()
	}
	p.SetState(1701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1700)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1703)
		p.Match(CypherParserT__20)
	}
	{
		p.SetState(1704)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1705)
		p.Match(CypherParserIS)
	}
	{
		p.SetState(1706)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1707)
		p.Match(CypherParserNODE)
	}
	{
		p.SetState(1708)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1709)
		p.Match(CypherParserKEY)
	}

	return localctx
}

// INodePropertyExistenceConstraintContext is an interface to support dynamic dispatch.
type INodePropertyExistenceConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodePropertyExistenceConstraintContext differentiates from other interfaces.
	IsNodePropertyExistenceConstraintContext()
}

type NodePropertyExistenceConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodePropertyExistenceConstraintContext() *NodePropertyExistenceConstraintContext {
	var p = new(NodePropertyExistenceConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodePropertyExistenceConstraint
	return p
}

func (*NodePropertyExistenceConstraintContext) IsNodePropertyExistenceConstraintContext() {}

func NewNodePropertyExistenceConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodePropertyExistenceConstraintContext {
	var p = new(NodePropertyExistenceConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodePropertyExistenceConstraint

	return p
}

func (s *NodePropertyExistenceConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *NodePropertyExistenceConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *NodePropertyExistenceConstraintContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodePropertyExistenceConstraintContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodePropertyExistenceConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *NodePropertyExistenceConstraintContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *NodePropertyExistenceConstraintContext) NodeLabel() INodeLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *NodePropertyExistenceConstraintContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(CypherParserASSERT, 0)
}

func (s *NodePropertyExistenceConstraintContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *NodePropertyExistenceConstraintContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *NodePropertyExistenceConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodePropertyExistenceConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodePropertyExistenceConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodePropertyExistenceConstraint(s)
	}
}

func (s *NodePropertyExistenceConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodePropertyExistenceConstraint(s)
	}
}

func (p *CypherParser) NodePropertyExistenceConstraint() (localctx INodePropertyExistenceConstraintContext) {
	this := p
	_ = this

	localctx = NewNodePropertyExistenceConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, CypherParserRULE_nodePropertyExistenceConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1711)
		p.Match(CypherParserCONSTRAINT)
	}
	{
		p.SetState(1712)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1713)
		p.Match(CypherParserON)
	}
	p.SetState(1715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1714)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1717)
		p.Match(CypherParserT__19)
	}
	{
		p.SetState(1718)
		p.Variable()
	}
	{
		p.SetState(1719)
		p.NodeLabel()
	}
	{
		p.SetState(1720)
		p.Match(CypherParserT__20)
	}
	p.SetState(1722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1721)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1724)
		p.Match(CypherParserASSERT)
	}
	{
		p.SetState(1725)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1726)
		p.Match(CypherParserEXISTS)
	}
	p.SetState(1728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1727)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1730)
		p.Match(CypherParserT__19)
	}
	{
		p.SetState(1731)
		p.PropertyExpression()
	}
	{
		p.SetState(1732)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IRelationshipPropertyExistenceConstraintContext is an interface to support dynamic dispatch.
type IRelationshipPropertyExistenceConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipPropertyExistenceConstraintContext differentiates from other interfaces.
	IsRelationshipPropertyExistenceConstraintContext()
}

type RelationshipPropertyExistenceConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPropertyExistenceConstraintContext() *RelationshipPropertyExistenceConstraintContext {
	var p = new(RelationshipPropertyExistenceConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPropertyExistenceConstraint
	return p
}

func (*RelationshipPropertyExistenceConstraintContext) IsRelationshipPropertyExistenceConstraintContext() {
}

func NewRelationshipPropertyExistenceConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPropertyExistenceConstraintContext {
	var p = new(RelationshipPropertyExistenceConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPropertyExistenceConstraint

	return p
}

func (s *RelationshipPropertyExistenceConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPropertyExistenceConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *RelationshipPropertyExistenceConstraintContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipPropertyExistenceConstraintContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipPropertyExistenceConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *RelationshipPropertyExistenceConstraintContext) RelationshipPatternSyntax() IRelationshipPatternSyntaxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipPatternSyntaxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipPatternSyntaxContext)
}

func (s *RelationshipPropertyExistenceConstraintContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(CypherParserASSERT, 0)
}

func (s *RelationshipPropertyExistenceConstraintContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *RelationshipPropertyExistenceConstraintContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *RelationshipPropertyExistenceConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPropertyExistenceConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPropertyExistenceConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipPropertyExistenceConstraint(s)
	}
}

func (s *RelationshipPropertyExistenceConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipPropertyExistenceConstraint(s)
	}
}

func (p *CypherParser) RelationshipPropertyExistenceConstraint() (localctx IRelationshipPropertyExistenceConstraintContext) {
	this := p
	_ = this

	localctx = NewRelationshipPropertyExistenceConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, CypherParserRULE_relationshipPropertyExistenceConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1734)
		p.Match(CypherParserCONSTRAINT)
	}
	{
		p.SetState(1735)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1736)
		p.Match(CypherParserON)
	}
	p.SetState(1738)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1737)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1740)
		p.RelationshipPatternSyntax()
	}
	p.SetState(1742)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1741)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1744)
		p.Match(CypherParserASSERT)
	}
	{
		p.SetState(1745)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1746)
		p.Match(CypherParserEXISTS)
	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1747)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1750)
		p.Match(CypherParserT__19)
	}
	{
		p.SetState(1751)
		p.PropertyExpression()
	}
	{
		p.SetState(1752)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IRelationshipPatternSyntaxContext is an interface to support dynamic dispatch.
type IRelationshipPatternSyntaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipPatternSyntaxContext differentiates from other interfaces.
	IsRelationshipPatternSyntaxContext()
}

type RelationshipPatternSyntaxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPatternSyntaxContext() *RelationshipPatternSyntaxContext {
	var p = new(RelationshipPatternSyntaxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPatternSyntax
	return p
}

func (*RelationshipPatternSyntaxContext) IsRelationshipPatternSyntaxContext() {}

func NewRelationshipPatternSyntaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPatternSyntaxContext {
	var p = new(RelationshipPatternSyntaxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPatternSyntax

	return p
}

func (s *RelationshipPatternSyntaxContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPatternSyntaxContext) AllDash() []IDashContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDashContext); ok {
			len++
		}
	}

	tst := make([]IDashContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDashContext); ok {
			tst[i] = t.(IDashContext)
			i++
		}
	}

	return tst
}

func (s *RelationshipPatternSyntaxContext) Dash(i int) IDashContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDashContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDashContext)
}

func (s *RelationshipPatternSyntaxContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RelationshipPatternSyntaxContext) RelType() IRelTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelTypeContext)
}

func (s *RelationshipPatternSyntaxContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipPatternSyntaxContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipPatternSyntaxContext) RightArrowHead() IRightArrowHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRightArrowHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRightArrowHeadContext)
}

func (s *RelationshipPatternSyntaxContext) LeftArrowHead() ILeftArrowHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftArrowHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftArrowHeadContext)
}

func (s *RelationshipPatternSyntaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPatternSyntaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPatternSyntaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipPatternSyntax(s)
	}
}

func (s *RelationshipPatternSyntaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipPatternSyntax(s)
	}
}

func (p *CypherParser) RelationshipPatternSyntax() (localctx IRelationshipPatternSyntaxContext) {
	this := p
	_ = this

	localctx = NewRelationshipPatternSyntaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, CypherParserRULE_relationshipPatternSyntax)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1807)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1754)
			p.Match(CypherParserT__19)
		}
		p.SetState(1756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1755)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1758)
			p.Match(CypherParserT__20)
		}
		{
			p.SetState(1759)
			p.Dash()
		}
		{
			p.SetState(1760)
			p.Match(CypherParserT__16)
		}
		{
			p.SetState(1761)
			p.Variable()
		}
		{
			p.SetState(1762)
			p.RelType()
		}
		{
			p.SetState(1763)
			p.Match(CypherParserT__17)
		}
		{
			p.SetState(1764)
			p.Dash()
		}
		{
			p.SetState(1765)
			p.Match(CypherParserT__19)
		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1766)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1769)
			p.Match(CypherParserT__20)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1771)
			p.Match(CypherParserT__19)
		}
		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1772)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1775)
			p.Match(CypherParserT__20)
		}
		{
			p.SetState(1776)
			p.Dash()
		}
		{
			p.SetState(1777)
			p.Match(CypherParserT__16)
		}
		{
			p.SetState(1778)
			p.Variable()
		}
		{
			p.SetState(1779)
			p.RelType()
		}
		{
			p.SetState(1780)
			p.Match(CypherParserT__17)
		}
		{
			p.SetState(1781)
			p.Dash()
		}
		{
			p.SetState(1782)
			p.RightArrowHead()
		}
		{
			p.SetState(1783)
			p.Match(CypherParserT__19)
		}
		p.SetState(1785)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1784)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1787)
			p.Match(CypherParserT__20)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1789)
			p.Match(CypherParserT__19)
		}
		p.SetState(1791)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1790)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1793)
			p.Match(CypherParserT__20)
		}
		{
			p.SetState(1794)
			p.LeftArrowHead()
		}
		{
			p.SetState(1795)
			p.Dash()
		}
		{
			p.SetState(1796)
			p.Match(CypherParserT__16)
		}
		{
			p.SetState(1797)
			p.Variable()
		}
		{
			p.SetState(1798)
			p.RelType()
		}
		{
			p.SetState(1799)
			p.Match(CypherParserT__17)
		}
		{
			p.SetState(1800)
			p.Dash()
		}
		{
			p.SetState(1801)
			p.Match(CypherParserT__19)
		}
		p.SetState(1803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1802)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1805)
			p.Match(CypherParserT__20)
		}

	}

	return localctx
}

// ILoadCSVClauseContext is an interface to support dynamic dispatch.
type ILoadCSVClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoadCSVClauseContext differentiates from other interfaces.
	IsLoadCSVClauseContext()
}

type LoadCSVClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadCSVClauseContext() *LoadCSVClauseContext {
	var p = new(LoadCSVClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_loadCSVClause
	return p
}

func (*LoadCSVClauseContext) IsLoadCSVClauseContext() {}

func NewLoadCSVClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadCSVClauseContext {
	var p = new(LoadCSVClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_loadCSVClause

	return p
}

func (s *LoadCSVClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadCSVClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(CypherParserLOAD, 0)
}

func (s *LoadCSVClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *LoadCSVClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *LoadCSVClauseContext) CSV() antlr.TerminalNode {
	return s.GetToken(CypherParserCSV, 0)
}

func (s *LoadCSVClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(CypherParserFROM, 0)
}

func (s *LoadCSVClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LoadCSVClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *LoadCSVClauseContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *LoadCSVClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *LoadCSVClauseContext) HEADERS() antlr.TerminalNode {
	return s.GetToken(CypherParserHEADERS, 0)
}

func (s *LoadCSVClauseContext) FIELDTERMINATOR() antlr.TerminalNode {
	return s.GetToken(CypherParserFIELDTERMINATOR, 0)
}

func (s *LoadCSVClauseContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *LoadCSVClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadCSVClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadCSVClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLoadCSVClause(s)
	}
}

func (s *LoadCSVClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLoadCSVClause(s)
	}
}

func (p *CypherParser) LoadCSVClause() (localctx ILoadCSVClauseContext) {
	this := p
	_ = this

	localctx = NewLoadCSVClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, CypherParserRULE_loadCSVClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1809)
		p.Match(CypherParserLOAD)
	}
	{
		p.SetState(1810)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1811)
		p.Match(CypherParserCSV)
	}
	{
		p.SetState(1812)
		p.Match(CypherParserSP)
	}
	p.SetState(1817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWITH {
		{
			p.SetState(1813)
			p.Match(CypherParserWITH)
		}
		{
			p.SetState(1814)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1815)
			p.Match(CypherParserHEADERS)
		}
		{
			p.SetState(1816)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1819)
		p.Match(CypherParserFROM)
	}
	{
		p.SetState(1820)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1821)
		p.Expression()
	}
	{
		p.SetState(1822)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1823)
		p.Match(CypherParserAS)
	}
	{
		p.SetState(1824)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1825)
		p.Variable()
	}
	{
		p.SetState(1826)
		p.Match(CypherParserSP)
	}
	p.SetState(1830)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserFIELDTERMINATOR {
		{
			p.SetState(1827)
			p.Match(CypherParserFIELDTERMINATOR)
		}
		{
			p.SetState(1828)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1829)
			p.Match(CypherParserStringLiteral)
		}

	}

	return localctx
}

// IMatchClauseContext is an interface to support dynamic dispatch.
type IMatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchClauseContext differentiates from other interfaces.
	IsMatchClauseContext()
}

type MatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchClauseContext() *MatchClauseContext {
	var p = new(MatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_matchClause
	return p
}

func (*MatchClauseContext) IsMatchClauseContext() {}

func NewMatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchClauseContext {
	var p = new(MatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_matchClause

	return p
}

func (s *MatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchClauseContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MatchClauseContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *MatchClauseContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *MatchClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MatchClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MatchClauseContext) AllHint() []IHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintContext); ok {
			len++
		}
	}

	tst := make([]IHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintContext); ok {
			tst[i] = t.(IHintContext)
			i++
		}
	}

	return tst
}

func (s *MatchClauseContext) Hint(i int) IHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *MatchClauseContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *MatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMatchClause(s)
	}
}

func (s *MatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMatchClause(s)
	}
}

func (p *CypherParser) MatchClause() (localctx IMatchClauseContext) {
	this := p
	_ = this

	localctx = NewMatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, CypherParserRULE_matchClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserOPTIONAL {
		{
			p.SetState(1832)
			p.Match(CypherParserOPTIONAL)
		}
		{
			p.SetState(1833)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1836)
		p.Match(CypherParserMATCH)
	}
	p.SetState(1838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1837)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1840)
		p.Pattern()
	}
	p.SetState(1844)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1841)
				p.Hint()
			}

		}
		p.SetState(1846)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())
	}
	p.SetState(1851)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1847)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1850)
			p.Where()
		}

	}

	return localctx
}

// IUnwindClauseContext is an interface to support dynamic dispatch.
type IUnwindClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnwindClauseContext differentiates from other interfaces.
	IsUnwindClauseContext()
}

type UnwindClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnwindClauseContext() *UnwindClauseContext {
	var p = new(UnwindClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_unwindClause
	return p
}

func (*UnwindClauseContext) IsUnwindClauseContext() {}

func NewUnwindClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnwindClauseContext {
	var p = new(UnwindClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unwindClause

	return p
}

func (s *UnwindClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnwindClauseContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *UnwindClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnwindClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnwindClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnwindClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *UnwindClauseContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *UnwindClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnwindClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnwindClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUnwindClause(s)
	}
}

func (s *UnwindClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUnwindClause(s)
	}
}

func (p *CypherParser) UnwindClause() (localctx IUnwindClauseContext) {
	this := p
	_ = this

	localctx = NewUnwindClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, CypherParserRULE_unwindClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1853)
		p.Match(CypherParserUNWIND)
	}
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1854)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1857)
		p.Expression()
	}
	{
		p.SetState(1858)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1859)
		p.Match(CypherParserAS)
	}
	{
		p.SetState(1860)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1861)
		p.Variable()
	}

	return localctx
}

// IMergeClauseContext is an interface to support dynamic dispatch.
type IMergeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeClauseContext differentiates from other interfaces.
	IsMergeClauseContext()
}

type MergeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeClauseContext() *MergeClauseContext {
	var p = new(MergeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mergeClause
	return p
}

func (*MergeClauseContext) IsMergeClauseContext() {}

func NewMergeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeClauseContext {
	var p = new(MergeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mergeClause

	return p
}

func (s *MergeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeClauseContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *MergeClauseContext) PatternPart() IPatternPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *MergeClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MergeClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MergeClauseContext) AllMergeAction() []IMergeActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeActionContext); ok {
			len++
		}
	}

	tst := make([]IMergeActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeActionContext); ok {
			tst[i] = t.(IMergeActionContext)
			i++
		}
	}

	return tst
}

func (s *MergeClauseContext) MergeAction(i int) IMergeActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeActionContext)
}

func (s *MergeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMergeClause(s)
	}
}

func (s *MergeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMergeClause(s)
	}
}

func (p *CypherParser) MergeClause() (localctx IMergeClauseContext) {
	this := p
	_ = this

	localctx = NewMergeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, CypherParserRULE_mergeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1863)
		p.Match(CypherParserMERGE)
	}
	p.SetState(1865)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1864)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1867)
		p.PatternPart()
	}
	p.SetState(1872)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1868)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(1869)
				p.MergeAction()
			}

		}
		p.SetState(1874)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())
	}

	return localctx
}

// IMergeActionContext is an interface to support dynamic dispatch.
type IMergeActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeActionContext differentiates from other interfaces.
	IsMergeActionContext()
}

type MergeActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeActionContext() *MergeActionContext {
	var p = new(MergeActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mergeAction
	return p
}

func (*MergeActionContext) IsMergeActionContext() {}

func NewMergeActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeActionContext {
	var p = new(MergeActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mergeAction

	return p
}

func (s *MergeActionContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeActionContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *MergeActionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MergeActionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MergeActionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MergeActionContext) SetClause() ISetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetClauseContext)
}

func (s *MergeActionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *MergeActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMergeAction(s)
	}
}

func (s *MergeActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMergeAction(s)
	}
}

func (p *CypherParser) MergeAction() (localctx IMergeActionContext) {
	this := p
	_ = this

	localctx = NewMergeActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, CypherParserRULE_mergeAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1885)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1875)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1876)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1877)
			p.Match(CypherParserMATCH)
		}
		{
			p.SetState(1878)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1879)
			p.SetClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1880)
			p.Match(CypherParserON)
		}
		{
			p.SetState(1881)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1882)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(1883)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1884)
			p.SetClause()
		}

	}

	return localctx
}

// ICreateClauseContext is an interface to support dynamic dispatch.
type ICreateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateClauseContext differentiates from other interfaces.
	IsCreateClauseContext()
}

type CreateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateClauseContext() *CreateClauseContext {
	var p = new(CreateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createClause
	return p
}

func (*CreateClauseContext) IsCreateClauseContext() {}

func NewCreateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateClauseContext {
	var p = new(CreateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createClause

	return p
}

func (s *CreateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateClauseContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CreateClauseContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateClause(s)
	}
}

func (s *CreateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateClause(s)
	}
}

func (p *CypherParser) CreateClause() (localctx ICreateClauseContext) {
	this := p
	_ = this

	localctx = NewCreateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, CypherParserRULE_createClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1887)
		p.Match(CypherParserCREATE)
	}
	p.SetState(1889)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1888)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1891)
		p.Pattern()
	}

	return localctx
}

// ICreateUniqueClauseContext is an interface to support dynamic dispatch.
type ICreateUniqueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateUniqueClauseContext differentiates from other interfaces.
	IsCreateUniqueClauseContext()
}

type CreateUniqueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUniqueClauseContext() *CreateUniqueClauseContext {
	var p = new(CreateUniqueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createUniqueClause
	return p
}

func (*CreateUniqueClauseContext) IsCreateUniqueClauseContext() {}

func NewCreateUniqueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUniqueClauseContext {
	var p = new(CreateUniqueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createUniqueClause

	return p
}

func (s *CreateUniqueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUniqueClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateUniqueClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CreateUniqueClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CreateUniqueClauseContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CypherParserUNIQUE, 0)
}

func (s *CreateUniqueClauseContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CreateUniqueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUniqueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUniqueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreateUniqueClause(s)
	}
}

func (s *CreateUniqueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreateUniqueClause(s)
	}
}

func (p *CypherParser) CreateUniqueClause() (localctx ICreateUniqueClauseContext) {
	this := p
	_ = this

	localctx = NewCreateUniqueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, CypherParserRULE_createUniqueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.Match(CypherParserCREATE)
	}
	{
		p.SetState(1894)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1895)
		p.Match(CypherParserUNIQUE)
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1896)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1899)
		p.Pattern()
	}

	return localctx
}

// ISetClauseContext is an interface to support dynamic dispatch.
type ISetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetClauseContext differentiates from other interfaces.
	IsSetClauseContext()
}

type SetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetClauseContext() *SetClauseContext {
	var p = new(SetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_setClause
	return p
}

func (*SetClauseContext) IsSetClauseContext() {}

func NewSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetClauseContext {
	var p = new(SetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setClause

	return p
}

func (s *SetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *SetClauseContext) AllSetItem() []ISetItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetItemContext); ok {
			len++
		}
	}

	tst := make([]ISetItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetItemContext); ok {
			tst[i] = t.(ISetItemContext)
			i++
		}
	}

	return tst
}

func (s *SetClauseContext) SetItem(i int) ISetItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetItemContext)
}

func (s *SetClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SetClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSetClause(s)
	}
}

func (s *SetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSetClause(s)
	}
}

func (p *CypherParser) SetClause() (localctx ISetClauseContext) {
	this := p
	_ = this

	localctx = NewSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, CypherParserRULE_setClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1901)
		p.Match(CypherParserSET)
	}
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1902)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1905)
		p.SetItem()
	}
	p.SetState(1916)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1907)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1906)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1909)
				p.Match(CypherParserT__14)
			}
			p.SetState(1911)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1910)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1913)
				p.SetItem()
			}

		}
		p.SetState(1918)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext())
	}

	return localctx
}

// ISetItemContext is an interface to support dynamic dispatch.
type ISetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetItemContext differentiates from other interfaces.
	IsSetItemContext()
}

type SetItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetItemContext() *SetItemContext {
	var p = new(SetItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_setItem
	return p
}

func (*SetItemContext) IsSetItemContext() {}

func NewSetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetItemContext {
	var p = new(SetItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setItem

	return p
}

func (s *SetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetItemContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *SetItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SetItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SetItemContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetItemContext) NodeLabels() INodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *SetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSetItem(s)
	}
}

func (s *SetItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSetItem(s)
	}
}

func (p *CypherParser) SetItem() (localctx ISetItemContext) {
	this := p
	_ = this

	localctx = NewSetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, CypherParserRULE_setItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1955)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1919)
			p.PropertyExpression()
		}
		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1920)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1923)
			p.Match(CypherParserT__11)
		}
		p.SetState(1925)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1924)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1927)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1929)
			p.Variable()
		}
		p.SetState(1931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1930)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1933)
			p.Match(CypherParserT__11)
		}
		p.SetState(1935)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1934)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1937)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1939)
			p.Variable()
		}
		p.SetState(1941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1940)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1943)
			p.Match(CypherParserT__21)
		}
		p.SetState(1945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1944)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1947)
			p.Expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1949)
			p.Variable()
		}
		p.SetState(1951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1950)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1953)
			p.NodeLabels()
		}

	}

	return localctx
}

// IDeleteClauseContext is an interface to support dynamic dispatch.
type IDeleteClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteClauseContext differentiates from other interfaces.
	IsDeleteClauseContext()
}

type DeleteClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteClauseContext() *DeleteClauseContext {
	var p = new(DeleteClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_deleteClause
	return p
}

func (*DeleteClauseContext) IsDeleteClauseContext() {}

func NewDeleteClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteClauseContext {
	var p = new(DeleteClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_deleteClause

	return p
}

func (s *DeleteClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *DeleteClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DeleteClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteClauseContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *DeleteClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DeleteClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DeleteClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDeleteClause(s)
	}
}

func (s *DeleteClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDeleteClause(s)
	}
}

func (p *CypherParser) DeleteClause() (localctx IDeleteClauseContext) {
	this := p
	_ = this

	localctx = NewDeleteClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, CypherParserRULE_deleteClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDETACH {
		{
			p.SetState(1957)
			p.Match(CypherParserDETACH)
		}
		{
			p.SetState(1958)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1961)
		p.Match(CypherParserDELETE)
	}
	p.SetState(1963)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1962)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1965)
		p.Expression()
	}
	p.SetState(1976)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1967)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1966)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1969)
				p.Match(CypherParserT__14)
			}
			p.SetState(1971)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1970)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1973)
				p.Expression()
			}

		}
		p.SetState(1978)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())
	}

	return localctx
}

// IRemoveClauseContext is an interface to support dynamic dispatch.
type IRemoveClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoveClauseContext differentiates from other interfaces.
	IsRemoveClauseContext()
}

type RemoveClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveClauseContext() *RemoveClauseContext {
	var p = new(RemoveClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_removeClause
	return p
}

func (*RemoveClauseContext) IsRemoveClauseContext() {}

func NewRemoveClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveClauseContext {
	var p = new(RemoveClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_removeClause

	return p
}

func (s *RemoveClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveClauseContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *RemoveClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RemoveClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RemoveClauseContext) AllRemoveItem() []IRemoveItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRemoveItemContext); ok {
			len++
		}
	}

	tst := make([]IRemoveItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRemoveItemContext); ok {
			tst[i] = t.(IRemoveItemContext)
			i++
		}
	}

	return tst
}

func (s *RemoveClauseContext) RemoveItem(i int) IRemoveItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveItemContext)
}

func (s *RemoveClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRemoveClause(s)
	}
}

func (s *RemoveClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRemoveClause(s)
	}
}

func (p *CypherParser) RemoveClause() (localctx IRemoveClauseContext) {
	this := p
	_ = this

	localctx = NewRemoveClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, CypherParserRULE_removeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1979)
		p.Match(CypherParserREMOVE)
	}
	{
		p.SetState(1980)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1981)
		p.RemoveItem()
	}
	p.SetState(1992)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1983)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1982)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1985)
				p.Match(CypherParserT__14)
			}
			p.SetState(1987)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1986)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1989)
				p.RemoveItem()
			}

		}
		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())
	}

	return localctx
}

// IRemoveItemContext is an interface to support dynamic dispatch.
type IRemoveItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoveItemContext differentiates from other interfaces.
	IsRemoveItemContext()
}

type RemoveItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveItemContext() *RemoveItemContext {
	var p = new(RemoveItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_removeItem
	return p
}

func (*RemoveItemContext) IsRemoveItemContext() {}

func NewRemoveItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveItemContext {
	var p = new(RemoveItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_removeItem

	return p
}

func (s *RemoveItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveItemContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RemoveItemContext) NodeLabels() INodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *RemoveItemContext) PropertyExpression() IPropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *RemoveItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRemoveItem(s)
	}
}

func (s *RemoveItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRemoveItem(s)
	}
}

func (p *CypherParser) RemoveItem() (localctx IRemoveItemContext) {
	this := p
	_ = this

	localctx = NewRemoveItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, CypherParserRULE_removeItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1999)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1995)
			p.Variable()
		}
		{
			p.SetState(1996)
			p.NodeLabels()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1998)
			p.PropertyExpression()
		}

	}

	return localctx
}

// IForeachClauseContext is an interface to support dynamic dispatch.
type IForeachClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeachClauseContext differentiates from other interfaces.
	IsForeachClauseContext()
}

type ForeachClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachClauseContext() *ForeachClauseContext {
	var p = new(ForeachClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_foreachClause
	return p
}

func (*ForeachClauseContext) IsForeachClauseContext() {}

func NewForeachClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachClauseContext {
	var p = new(ForeachClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_foreachClause

	return p
}

func (s *ForeachClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachClauseContext) FOREACH() antlr.TerminalNode {
	return s.GetToken(CypherParserFOREACH, 0)
}

func (s *ForeachClauseContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ForeachClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ForeachClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ForeachClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *ForeachClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForeachClauseContext) AllClause() []IClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClauseContext); ok {
			len++
		}
	}

	tst := make([]IClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClauseContext); ok {
			tst[i] = t.(IClauseContext)
			i++
		}
	}

	return tst
}

func (s *ForeachClauseContext) Clause(i int) IClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClauseContext)
}

func (s *ForeachClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterForeachClause(s)
	}
}

func (s *ForeachClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitForeachClause(s)
	}
}

func (p *CypherParser) ForeachClause() (localctx IForeachClauseContext) {
	this := p
	_ = this

	localctx = NewForeachClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, CypherParserRULE_foreachClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2001)
		p.Match(CypherParserFOREACH)
	}
	p.SetState(2003)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2002)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2005)
		p.Match(CypherParserT__19)
	}
	p.SetState(2007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2006)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2009)
		p.Variable()
	}
	{
		p.SetState(2010)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2011)
		p.Match(CypherParserIN)
	}
	{
		p.SetState(2012)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2013)
		p.Expression()
	}
	p.SetState(2015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2014)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2017)
		p.Match(CypherParserT__22)
	}
	p.SetState(2020)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2018)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(2019)
				p.Clause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2022)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())
	}
	p.SetState(2025)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2024)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2027)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_withClause
	return p
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *WithClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *WithClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *WithClauseContext) ReturnBody() IReturnBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnBodyContext)
}

func (s *WithClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *WithClauseContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (p *CypherParser) WithClause() (localctx IWithClauseContext) {
	this := p
	_ = this

	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, CypherParserRULE_withClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2029)
		p.Match(CypherParserWITH)
	}
	p.SetState(2034)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
		p.SetState(2031)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2030)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2033)
			p.Match(CypherParserDISTINCT)
		}

	}
	{
		p.SetState(2036)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2037)
		p.ReturnBody()
	}
	p.SetState(2042)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
		p.SetState(2039)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2038)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2041)
			p.Where()
		}

	}

	return localctx
}

// IReturnClauseContext is an interface to support dynamic dispatch.
type IReturnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnClauseContext differentiates from other interfaces.
	IsReturnClauseContext()
}

type ReturnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnClauseContext() *ReturnClauseContext {
	var p = new(ReturnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnClause
	return p
}

func (*ReturnClauseContext) IsReturnClauseContext() {}

func NewReturnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnClauseContext {
	var p = new(ReturnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnClause

	return p
}

func (s *ReturnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnClauseContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *ReturnClauseContext) ReturnBody() IReturnBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnBodyContext)
}

func (s *ReturnClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *ReturnClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturnClause(s)
	}
}

func (s *ReturnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturnClause(s)
	}
}

func (p *CypherParser) ReturnClause() (localctx IReturnClauseContext) {
	this := p
	_ = this

	localctx = NewReturnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, CypherParserRULE_returnClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2044)
		p.Match(CypherParserRETURN)
	}
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
		p.SetState(2046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2045)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2048)
			p.Match(CypherParserDISTINCT)
		}

	}
	p.SetState(2052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2051)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2054)
		p.ReturnBody()
	}

	return localctx
}

// IReturnBodyContext is an interface to support dynamic dispatch.
type IReturnBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnBodyContext differentiates from other interfaces.
	IsReturnBodyContext()
}

type ReturnBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnBodyContext() *ReturnBodyContext {
	var p = new(ReturnBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnBody
	return p
}

func (*ReturnBodyContext) IsReturnBodyContext() {}

func NewReturnBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnBodyContext {
	var p = new(ReturnBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnBody

	return p
}

func (s *ReturnBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnBodyContext) ReturnItems() IReturnItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnItemsContext)
}

func (s *ReturnBodyContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnBodyContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnBodyContext) Order() IOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderContext)
}

func (s *ReturnBodyContext) Skip() ISkipContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipContext)
}

func (s *ReturnBodyContext) Limit() ILimitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitContext)
}

func (s *ReturnBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturnBody(s)
	}
}

func (s *ReturnBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturnBody(s)
	}
}

func (p *CypherParser) ReturnBody() (localctx IReturnBodyContext) {
	this := p
	_ = this

	localctx = NewReturnBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, CypherParserRULE_returnBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2056)
		p.ReturnItems()
	}
	p.SetState(2059)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2057)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2058)
			p.Order()
		}

	}
	p.SetState(2063)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2061)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2062)
			p.Skip()
		}

	}
	p.SetState(2067)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2065)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2066)
			p.Limit()
		}

	}

	return localctx
}

// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_function
	return p
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) ProcedureInvocation() IProcedureInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureInvocationContext)
}

func (s *FunctionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *FunctionContext) ProcedureResults() IProcedureResultsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureResultsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureResultsContext)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFunction(s)
	}
}

func (s *FunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFunction(s)
	}
}

func (p *CypherParser) Function() (localctx IFunctionContext) {
	this := p
	_ = this

	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, CypherParserRULE_function)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2069)
		p.ProcedureInvocation()
	}
	p.SetState(2071)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2070)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2074)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserYIELD {
		{
			p.SetState(2073)
			p.ProcedureResults()
		}

	}

	return localctx
}

// IReturnItemsContext is an interface to support dynamic dispatch.
type IReturnItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnItemsContext differentiates from other interfaces.
	IsReturnItemsContext()
}

type ReturnItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemsContext() *ReturnItemsContext {
	var p = new(ReturnItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnItems
	return p
}

func (*ReturnItemsContext) IsReturnItemsContext() {}

func NewReturnItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemsContext {
	var p = new(ReturnItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnItems

	return p
}

func (s *ReturnItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemsContext) AllReturnItem() []IReturnItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReturnItemContext); ok {
			len++
		}
	}

	tst := make([]IReturnItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReturnItemContext); ok {
			tst[i] = t.(IReturnItemContext)
			i++
		}
	}

	return tst
}

func (s *ReturnItemsContext) ReturnItem(i int) IReturnItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnItemContext)
}

func (s *ReturnItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnItemsContext) Function() IFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *ReturnItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturnItems(s)
	}
}

func (s *ReturnItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturnItems(s)
	}
}

func (p *CypherParser) ReturnItems() (localctx IReturnItemsContext) {
	this := p
	_ = this

	localctx = NewReturnItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, CypherParserRULE_returnItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2105)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2076)
			p.Match(CypherParserT__18)
		}
		p.SetState(2087)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 228, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2078)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2077)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2080)
					p.Match(CypherParserT__14)
				}
				p.SetState(2082)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2081)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2084)
					p.ReturnItem()
				}

			}
			p.SetState(2089)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 228, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2090)
			p.ReturnItem()
		}
		p.SetState(2101)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2092)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2091)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2094)
					p.Match(CypherParserT__14)
				}
				p.SetState(2096)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2095)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2098)
					p.ReturnItem()
				}

			}
			p.SetState(2103)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext())
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2104)
			p.Function()
		}

	}

	return localctx
}

// IReturnItemContext is an interface to support dynamic dispatch.
type IReturnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnItemContext differentiates from other interfaces.
	IsReturnItemContext()
}

type ReturnItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemContext() *ReturnItemContext {
	var p = new(ReturnItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnItem
	return p
}

func (*ReturnItemContext) IsReturnItemContext() {}

func NewReturnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemContext {
	var p = new(ReturnItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnItem

	return p
}

func (s *ReturnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *ReturnItemContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ReturnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturnItem(s)
	}
}

func (s *ReturnItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturnItem(s)
	}
}

func (p *CypherParser) ReturnItem() (localctx IReturnItemContext) {
	this := p
	_ = this

	localctx = NewReturnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, CypherParserRULE_returnItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2114)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2107)
			p.Expression()
		}
		{
			p.SetState(2108)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2109)
			p.Match(CypherParserAS)
		}
		{
			p.SetState(2110)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2111)
			p.Variable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2113)
			p.Expression()
		}

	}

	return localctx
}

// ICallContext is an interface to support dynamic dispatch.
type ICallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallContext differentiates from other interfaces.
	IsCallContext()
}

type CallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallContext() *CallContext {
	var p = new(CallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_call
	return p
}

func (*CallContext) IsCallContext() {}

func NewCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallContext {
	var p = new(CallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_call

	return p
}

func (s *CallContext) GetParser() antlr.Parser { return s.parser }

func (s *CallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *CallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CallContext) ProcedureInvocation() IProcedureInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureInvocationContext)
}

func (s *CallContext) ProcedureResults() IProcedureResultsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureResultsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureResultsContext)
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCall(s)
	}
}

func (p *CypherParser) Call() (localctx ICallContext) {
	this := p
	_ = this

	localctx = NewCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, CypherParserRULE_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2116)
		p.Match(CypherParserCALL)
	}
	{
		p.SetState(2117)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2118)
		p.ProcedureInvocation()
	}
	p.SetState(2120)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2119)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserYIELD {
		{
			p.SetState(2122)
			p.ProcedureResults()
		}

	}

	return localctx
}

// IProcedureInvocationContext is an interface to support dynamic dispatch.
type IProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureInvocationContext differentiates from other interfaces.
	IsProcedureInvocationContext()
}

type ProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureInvocationContext() *ProcedureInvocationContext {
	var p = new(ProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureInvocation
	return p
}

func (*ProcedureInvocationContext) IsProcedureInvocationContext() {}

func NewProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureInvocationContext {
	var p = new(ProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureInvocation

	return p
}

func (s *ProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureInvocationContext) ProcedureInvocationBody() IProcedureInvocationBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureInvocationBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureInvocationBodyContext)
}

func (s *ProcedureInvocationContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *ProcedureInvocationContext) ProcedureArguments() IProcedureArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureArgumentsContext)
}

func (s *ProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureInvocation(s)
	}
}

func (s *ProcedureInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureInvocation(s)
	}
}

func (p *CypherParser) ProcedureInvocation() (localctx IProcedureInvocationContext) {
	this := p
	_ = this

	localctx = NewProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, CypherParserRULE_procedureInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2125)
		p.ProcedureInvocationBody()
	}
	p.SetState(2127)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2126)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2130)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__19 {
		{
			p.SetState(2129)
			p.ProcedureArguments()
		}

	}

	return localctx
}

// IProcedureInvocationBodyContext is an interface to support dynamic dispatch.
type IProcedureInvocationBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureInvocationBodyContext differentiates from other interfaces.
	IsProcedureInvocationBodyContext()
}

type ProcedureInvocationBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureInvocationBodyContext() *ProcedureInvocationBodyContext {
	var p = new(ProcedureInvocationBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureInvocationBody
	return p
}

func (*ProcedureInvocationBodyContext) IsProcedureInvocationBodyContext() {}

func NewProcedureInvocationBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureInvocationBodyContext {
	var p = new(ProcedureInvocationBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureInvocationBody

	return p
}

func (s *ProcedureInvocationBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureInvocationBodyContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *ProcedureInvocationBodyContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *ProcedureInvocationBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureInvocationBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureInvocationBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureInvocationBody(s)
	}
}

func (s *ProcedureInvocationBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureInvocationBody(s)
	}
}

func (p *CypherParser) ProcedureInvocationBody() (localctx IProcedureInvocationBodyContext) {
	this := p
	_ = this

	localctx = NewProcedureInvocationBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, CypherParserRULE_procedureInvocationBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2132)
		p.Namespace()
	}
	{
		p.SetState(2133)
		p.ProcedureName()
	}

	return localctx
}

// IProcedureArgumentsContext is an interface to support dynamic dispatch.
type IProcedureArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureArgumentsContext differentiates from other interfaces.
	IsProcedureArgumentsContext()
}

type ProcedureArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureArgumentsContext() *ProcedureArgumentsContext {
	var p = new(ProcedureArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureArguments
	return p
}

func (*ProcedureArgumentsContext) IsProcedureArgumentsContext() {}

func NewProcedureArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureArgumentsContext {
	var p = new(ProcedureArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureArguments

	return p
}

func (s *ProcedureArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureArgumentsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ProcedureArgumentsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ProcedureArgumentsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureArgumentsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ProcedureArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureArguments(s)
	}
}

func (s *ProcedureArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureArguments(s)
	}
}

func (p *CypherParser) ProcedureArguments() (localctx IProcedureArgumentsContext) {
	this := p
	_ = this

	localctx = NewProcedureArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, CypherParserRULE_procedureArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2135)
		p.Match(CypherParserT__19)
	}
	p.SetState(2137)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2136)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__2)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__16)|(1<<CypherParserT__19))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(CypherParserT__33-34))|(1<<(CypherParserCYPHER-34))|(1<<(CypherParserEXPLAIN-34))|(1<<(CypherParserPROFILE-34))|(1<<(CypherParserUSING-34))|(1<<(CypherParserPERIODIC-34))|(1<<(CypherParserCOMMIT-34))|(1<<(CypherParserUNION-34))|(1<<(CypherParserALL-34))|(1<<(CypherParserCREATE-34))|(1<<(CypherParserDROP-34))|(1<<(CypherParserINDEX-34))|(1<<(CypherParserON-34)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(CypherParserCONSTRAINT-66))|(1<<(CypherParserASSERT-66))|(1<<(CypherParserIS-66))|(1<<(CypherParserUNIQUE-66))|(1<<(CypherParserEXISTS-66))|(1<<(CypherParserLOAD-66))|(1<<(CypherParserCSV-66))|(1<<(CypherParserWITH-66))|(1<<(CypherParserHEADERS-66))|(1<<(CypherParserFROM-66))|(1<<(CypherParserAS-66))|(1<<(CypherParserFIELDTERMINATOR-66))|(1<<(CypherParserOPTIONAL-66))|(1<<(CypherParserMATCH-66))|(1<<(CypherParserUNWIND-66))|(1<<(CypherParserMERGE-66))|(1<<(CypherParserSET-66))|(1<<(CypherParserDETACH-66))|(1<<(CypherParserDELETE-66))|(1<<(CypherParserREMOVE-66))|(1<<(CypherParserFOREACH-66))|(1<<(CypherParserIN-66))|(1<<(CypherParserDISTINCT-66))|(1<<(CypherParserRETURN-66))|(1<<(CypherParserORDER-66))|(1<<(CypherParserBY-66))|(1<<(CypherParserL_SKIP-66))|(1<<(CypherParserLIMIT-66))|(1<<(CypherParserASCENDING-66))|(1<<(CypherParserASC-66))|(1<<(CypherParserDESCENDING-66))|(1<<(CypherParserDESC-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(CypherParserJOIN-98))|(1<<(CypherParserSCAN-98))|(1<<(CypherParserSTART-98))|(1<<(CypherParserNODE-98))|(1<<(CypherParserRELATIONSHIP-98))|(1<<(CypherParserREL-98))|(1<<(CypherParserWHERE-98))|(1<<(CypherParserSHORTESTPATH-98))|(1<<(CypherParserALLSHORTESTPATHS-98))|(1<<(CypherParserOR-98))|(1<<(CypherParserXOR-98))|(1<<(CypherParserAND-98))|(1<<(CypherParserNOT-98))|(1<<(CypherParserSTARTS-98))|(1<<(CypherParserENDS-98))|(1<<(CypherParserCONTAINS-98))|(1<<(CypherParserNULL-98))|(1<<(CypherParserCOUNT-98))|(1<<(CypherParserFILTER-98))|(1<<(CypherParserEXTRACT-98))|(1<<(CypherParserANY-98))|(1<<(CypherParserNONE-98))|(1<<(CypherParserSINGLE-98))|(1<<(CypherParserTRUE-98))|(1<<(CypherParserFALSE-98))|(1<<(CypherParserREDUCE-98))|(1<<(CypherParserCASE-98))|(1<<(CypherParserELSE-98))|(1<<(CypherParserEND-98))|(1<<(CypherParserWHEN-98))|(1<<(CypherParserTHEN-98))|(1<<(CypherParserCALL-98)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(CypherParserYIELD-130))|(1<<(CypherParserKEY-130))|(1<<(CypherParserCATALOG-130))|(1<<(CypherParserSHOW-130))|(1<<(CypherParserDEFAULT-130))|(1<<(CypherParserDBMS-130))|(1<<(CypherParserDATABASE-130))|(1<<(CypherParserDATABASES-130))|(1<<(CypherParserGRAPH-130))|(1<<(CypherParserGRAPHS-130))|(1<<(CypherParserREPLACE-130))|(1<<(CypherParserIF-130))|(1<<(CypherParserSTOP-130))|(1<<(CypherParserROLE-130))|(1<<(CypherParserROLES-130))|(1<<(CypherParserUSER-130))|(1<<(CypherParserUSERS-130))|(1<<(CypherParserPOPULATED-130))|(1<<(CypherParserPASSWORD-130))|(1<<(CypherParserCHANGE-130))|(1<<(CypherParserREQUIRED-130))|(1<<(CypherParserSTATUS-130))|(1<<(CypherParserACTIVE-130))|(1<<(CypherParserSUSPENDED-130))|(1<<(CypherParserALTER-130))|(1<<(CypherParserCURRENT-130))|(1<<(CypherParserTO-130))|(1<<(CypherParserPRIVILEGES-130))|(1<<(CypherParserGRANT-130))|(1<<(CypherParserDENY-130))|(1<<(CypherParserREVOKE-130))|(1<<(CypherParserRELATIONSHIPS-130)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(CypherParserNODES-162))|(1<<(CypherParserELEMENT-162))|(1<<(CypherParserELEMENTS-162))|(1<<(CypherParserCOPY-162))|(1<<(CypherParserOF-162))|(1<<(CypherParserTRAVERSE-162))|(1<<(CypherParserREAD-162))|(1<<(CypherParserWRITE-162))|(1<<(CypherParserACCESS-162))|(1<<(CypherParserINDEXES-162))|(1<<(CypherParserMANAGEMENT-162))|(1<<(CypherParserNEW-162))|(1<<(CypherParserLABEL-162))|(1<<(CypherParserLABELS-162))|(1<<(CypherParserNAME-162))|(1<<(CypherParserNAMES-162))|(1<<(CypherParserTYPE-162))|(1<<(CypherParserTYPES-162))|(1<<(CypherParserPROPERTY-162))|(1<<(CypherParserCONSTRAINTS-162))|(1<<(CypherParserASSIGN-162))|(1<<(CypherParserBTREE-162))|(1<<(CypherParserEXIST-162))|(1<<(CypherParserFOR-162))|(1<<(CypherParserOPTIONS-162))|(1<<(CypherParserEXECUTE-162))|(1<<(CypherParserDEFINED-162))|(1<<(CypherParserFUNCTION-162))|(1<<(CypherParserFUNCTIONS-162))|(1<<(CypherParserBOOSTED-162))|(1<<(CypherParserPROCEDURE-162))|(1<<(CypherParserPROCEDURES-162)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(CypherParserADMIN-194))|(1<<(CypherParserADMINISTRATOR-194))|(1<<(CypherParserBRIEF-194))|(1<<(CypherParserVERBOSE-194))|(1<<(CypherParserOUTPUT-194))|(1<<(CypherParserBUILT-194))|(1<<(CypherParserEACH-194))|(1<<(CypherParserEXECUTABLE-194))|(1<<(CypherParserEXISTENCE-194))|(1<<(CypherParserFULLTEXT-194))|(1<<(CypherParserHOME-194))|(1<<(CypherParserLOOKUP-194))|(1<<(CypherParserStringLiteral-194))|(1<<(CypherParserHexInteger-194))|(1<<(CypherParserDecimalInteger-194))|(1<<(CypherParserOctalInteger-194))|(1<<(CypherParserHexLetter-194))|(1<<(CypherParserExponentDecimalReal-194))|(1<<(CypherParserRegularDecimalReal-194))|(1<<(CypherParserUnescapedSymbolicName-194))|(1<<(CypherParserEscapedSymbolicName-194)))) != 0) {
		{
			p.SetState(2139)
			p.Expression()
		}

	}
	p.SetState(2152)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2143)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2142)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2145)
				p.Match(CypherParserT__14)
			}
			p.SetState(2147)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2146)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2149)
				p.Expression()
			}

		}
		p.SetState(2154)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())
	}
	p.SetState(2156)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2155)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2158)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IProcedureResultsContext is an interface to support dynamic dispatch.
type IProcedureResultsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureResultsContext differentiates from other interfaces.
	IsProcedureResultsContext()
}

type ProcedureResultsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureResultsContext() *ProcedureResultsContext {
	var p = new(ProcedureResultsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureResults
	return p
}

func (*ProcedureResultsContext) IsProcedureResultsContext() {}

func NewProcedureResultsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureResultsContext {
	var p = new(ProcedureResultsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureResults

	return p
}

func (s *ProcedureResultsContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureResultsContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *ProcedureResultsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ProcedureResultsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ProcedureResultsContext) AllProcedureResult() []IProcedureResultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureResultContext); ok {
			len++
		}
	}

	tst := make([]IProcedureResultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureResultContext); ok {
			tst[i] = t.(IProcedureResultContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureResultsContext) ProcedureResult(i int) IProcedureResultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureResultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureResultContext)
}

func (s *ProcedureResultsContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *ProcedureResultsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureResultsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureResultsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureResults(s)
	}
}

func (s *ProcedureResultsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureResults(s)
	}
}

func (p *CypherParser) ProcedureResults() (localctx IProcedureResultsContext) {
	this := p
	_ = this

	localctx = NewProcedureResultsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, CypherParserRULE_procedureResults)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2160)
		p.Match(CypherParserYIELD)
	}
	{
		p.SetState(2161)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2162)
		p.ProcedureResult()
	}
	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2164)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2163)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2166)
				p.Match(CypherParserT__14)
			}
			p.SetState(2168)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2167)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2170)
				p.ProcedureResult()
			}

		}
		p.SetState(2175)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext())
	}
	p.SetState(2178)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 247, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2176)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2177)
			p.Where()
		}

	}

	return localctx
}

// IProcedureResultContext is an interface to support dynamic dispatch.
type IProcedureResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureResultContext differentiates from other interfaces.
	IsProcedureResultContext()
}

type ProcedureResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureResultContext() *ProcedureResultContext {
	var p = new(ProcedureResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureResult
	return p
}

func (*ProcedureResultContext) IsProcedureResultContext() {}

func NewProcedureResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureResultContext {
	var p = new(ProcedureResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureResult

	return p
}

func (s *ProcedureResultContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureResultContext) AliasedProcedureResult() IAliasedProcedureResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedProcedureResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedProcedureResultContext)
}

func (s *ProcedureResultContext) SimpleProcedureResult() ISimpleProcedureResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleProcedureResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleProcedureResultContext)
}

func (s *ProcedureResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureResult(s)
	}
}

func (s *ProcedureResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureResult(s)
	}
}

func (p *CypherParser) ProcedureResult() (localctx IProcedureResultContext) {
	this := p
	_ = this

	localctx = NewProcedureResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, CypherParserRULE_procedureResult)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2182)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2180)
			p.AliasedProcedureResult()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2181)
			p.SimpleProcedureResult()
		}

	}

	return localctx
}

// IAliasedProcedureResultContext is an interface to support dynamic dispatch.
type IAliasedProcedureResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedProcedureResultContext differentiates from other interfaces.
	IsAliasedProcedureResultContext()
}

type AliasedProcedureResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedProcedureResultContext() *AliasedProcedureResultContext {
	var p = new(AliasedProcedureResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_aliasedProcedureResult
	return p
}

func (*AliasedProcedureResultContext) IsAliasedProcedureResultContext() {}

func NewAliasedProcedureResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedProcedureResultContext {
	var p = new(AliasedProcedureResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_aliasedProcedureResult

	return p
}

func (s *AliasedProcedureResultContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedProcedureResultContext) ProcedureOutput() IProcedureOutputContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOutputContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOutputContext)
}

func (s *AliasedProcedureResultContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AliasedProcedureResultContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AliasedProcedureResultContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *AliasedProcedureResultContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *AliasedProcedureResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedProcedureResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedProcedureResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAliasedProcedureResult(s)
	}
}

func (s *AliasedProcedureResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAliasedProcedureResult(s)
	}
}

func (p *CypherParser) AliasedProcedureResult() (localctx IAliasedProcedureResultContext) {
	this := p
	_ = this

	localctx = NewAliasedProcedureResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, CypherParserRULE_aliasedProcedureResult)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2184)
		p.ProcedureOutput()
	}
	{
		p.SetState(2185)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2186)
		p.Match(CypherParserAS)
	}
	{
		p.SetState(2187)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2188)
		p.Variable()
	}

	return localctx
}

// ISimpleProcedureResultContext is an interface to support dynamic dispatch.
type ISimpleProcedureResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleProcedureResultContext differentiates from other interfaces.
	IsSimpleProcedureResultContext()
}

type SimpleProcedureResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleProcedureResultContext() *SimpleProcedureResultContext {
	var p = new(SimpleProcedureResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_simpleProcedureResult
	return p
}

func (*SimpleProcedureResultContext) IsSimpleProcedureResultContext() {}

func NewSimpleProcedureResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleProcedureResultContext {
	var p = new(SimpleProcedureResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_simpleProcedureResult

	return p
}

func (s *SimpleProcedureResultContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleProcedureResultContext) ProcedureOutput() IProcedureOutputContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOutputContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOutputContext)
}

func (s *SimpleProcedureResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleProcedureResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleProcedureResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSimpleProcedureResult(s)
	}
}

func (s *SimpleProcedureResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSimpleProcedureResult(s)
	}
}

func (p *CypherParser) SimpleProcedureResult() (localctx ISimpleProcedureResultContext) {
	this := p
	_ = this

	localctx = NewSimpleProcedureResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, CypherParserRULE_simpleProcedureResult)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2190)
		p.ProcedureOutput()
	}

	return localctx
}

// IProcedureOutputContext is an interface to support dynamic dispatch.
type IProcedureOutputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureOutputContext differentiates from other interfaces.
	IsProcedureOutputContext()
}

type ProcedureOutputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOutputContext() *ProcedureOutputContext {
	var p = new(ProcedureOutputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureOutput
	return p
}

func (*ProcedureOutputContext) IsProcedureOutputContext() {}

func NewProcedureOutputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOutputContext {
	var p = new(ProcedureOutputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureOutput

	return p
}

func (s *ProcedureOutputContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOutputContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ProcedureOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOutputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureOutput(s)
	}
}

func (s *ProcedureOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureOutput(s)
	}
}

func (p *CypherParser) ProcedureOutput() (localctx IProcedureOutputContext) {
	this := p
	_ = this

	localctx = NewProcedureOutputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, CypherParserRULE_procedureOutput)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2192)
		p.SymbolicName()
	}

	return localctx
}

// IOrderContext is an interface to support dynamic dispatch.
type IOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderContext differentiates from other interfaces.
	IsOrderContext()
}

type OrderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderContext() *OrderContext {
	var p = new(OrderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_order
	return p
}

func (*OrderContext) IsOrderContext() {}

func NewOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderContext {
	var p = new(OrderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_order

	return p
}

func (s *OrderContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *OrderContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OrderContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OrderContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *OrderContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *OrderContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOrder(s)
	}
}

func (s *OrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOrder(s)
	}
}

func (p *CypherParser) Order() (localctx IOrderContext) {
	this := p
	_ = this

	localctx = NewOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, CypherParserRULE_order)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2194)
		p.Match(CypherParserORDER)
	}
	{
		p.SetState(2195)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2196)
		p.Match(CypherParserBY)
	}
	{
		p.SetState(2197)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2198)
		p.SortItem()
	}
	p.SetState(2209)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2200)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2199)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2202)
				p.Match(CypherParserT__14)
			}
			p.SetState(2204)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2203)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2206)
				p.SortItem()
			}

		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext())
	}

	return localctx
}

// ISkipContext is an interface to support dynamic dispatch.
type ISkipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSkipContext differentiates from other interfaces.
	IsSkipContext()
}

type SkipContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkipContext() *SkipContext {
	var p = new(SkipContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_skip
	return p
}

func (*SkipContext) IsSkipContext() {}

func NewSkipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipContext {
	var p = new(SkipContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_skip

	return p
}

func (s *SkipContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *SkipContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *SkipContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SkipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSkip(s)
	}
}

func (s *SkipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSkip(s)
	}
}

func (p *CypherParser) Skip() (localctx ISkipContext) {
	this := p
	_ = this

	localctx = NewSkipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, CypherParserRULE_skip)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2212)
		p.Match(CypherParserL_SKIP)
	}
	{
		p.SetState(2213)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2214)
		p.Expression()
	}

	return localctx
}

// ILimitContext is an interface to support dynamic dispatch.
type ILimitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitContext differentiates from other interfaces.
	IsLimitContext()
}

type LimitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitContext() *LimitContext {
	var p = new(LimitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_limit
	return p
}

func (*LimitContext) IsLimitContext() {}

func NewLimitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitContext {
	var p = new(LimitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_limit

	return p
}

func (s *LimitContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *LimitContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *LimitContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LimitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLimit(s)
	}
}

func (s *LimitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLimit(s)
	}
}

func (p *CypherParser) Limit() (localctx ILimitContext) {
	this := p
	_ = this

	localctx = NewLimitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, CypherParserRULE_limit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2216)
		p.Match(CypherParserLIMIT)
	}
	{
		p.SetState(2217)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2218)
		p.Expression()
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *SortItemContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *SortItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SortItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *CypherParser) SortItem() (localctx ISortItemContext) {
	this := p
	_ = this

	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, CypherParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2220)
		p.Expression()
	}
	p.SetState(2228)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
		p.SetState(2222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2221)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2224)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(CypherParserASCENDING-94))|(1<<(CypherParserASC-94))|(1<<(CypherParserDESCENDING-94))|(1<<(CypherParserDESC-94)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2226)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2225)
				p.Match(CypherParserSP)
			}

		}

	}

	return localctx
}

// IHintContext is an interface to support dynamic dispatch.
type IHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHintContext differentiates from other interfaces.
	IsHintContext()
}

type HintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintContext() *HintContext {
	var p = new(HintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_hint
	return p
}

func (*HintContext) IsHintContext() {}

func NewHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintContext {
	var p = new(HintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_hint

	return p
}

func (s *HintContext) GetParser() antlr.Parser { return s.parser }

func (s *HintContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *HintContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *HintContext) USING() antlr.TerminalNode {
	return s.GetToken(CypherParserUSING, 0)
}

func (s *HintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(CypherParserINDEX, 0)
}

func (s *HintContext) AllVariable() []IVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableContext); ok {
			len++
		}
	}

	tst := make([]IVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableContext); ok {
			tst[i] = t.(IVariableContext)
			i++
		}
	}

	return tst
}

func (s *HintContext) Variable(i int) IVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *HintContext) NodeLabel() INodeLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *HintContext) PropertyKeys() IPropertyKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeysContext)
}

func (s *HintContext) JOIN() antlr.TerminalNode {
	return s.GetToken(CypherParserJOIN, 0)
}

func (s *HintContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *HintContext) SCAN() antlr.TerminalNode {
	return s.GetToken(CypherParserSCAN, 0)
}

func (s *HintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterHint(s)
	}
}

func (s *HintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitHint(s)
	}
}

func (p *CypherParser) Hint() (localctx IHintContext) {
	this := p
	_ = this

	localctx = NewHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, CypherParserRULE_hint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2230)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2279)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2233)
			p.Match(CypherParserUSING)
		}
		{
			p.SetState(2234)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2235)
			p.Match(CypherParserINDEX)
		}
		{
			p.SetState(2236)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2237)
			p.Variable()
		}
		{
			p.SetState(2238)
			p.NodeLabel()
		}
		p.SetState(2240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2239)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2242)
			p.Match(CypherParserT__19)
		}
		p.SetState(2244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2243)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2246)
			p.PropertyKeys()
		}
		p.SetState(2248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2247)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2250)
			p.Match(CypherParserT__20)
		}

	case 2:
		{
			p.SetState(2252)
			p.Match(CypherParserUSING)
		}
		{
			p.SetState(2253)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2254)
			p.Match(CypherParserJOIN)
		}
		{
			p.SetState(2255)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2256)
			p.Match(CypherParserON)
		}
		{
			p.SetState(2257)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2258)
			p.Variable()
		}
		p.SetState(2269)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 261, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2260)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2259)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2262)
					p.Match(CypherParserT__14)
				}
				p.SetState(2264)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2263)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2266)
					p.Variable()
				}

			}
			p.SetState(2271)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 261, p.GetParserRuleContext())
		}

	case 3:
		{
			p.SetState(2272)
			p.Match(CypherParserUSING)
		}
		{
			p.SetState(2273)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2274)
			p.Match(CypherParserSCAN)
		}
		{
			p.SetState(2275)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(2276)
			p.Variable()
		}
		{
			p.SetState(2277)
			p.NodeLabel()
		}

	}

	return localctx
}

// IStartClauseContext is an interface to support dynamic dispatch.
type IStartClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartClauseContext differentiates from other interfaces.
	IsStartClauseContext()
}

type StartClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartClauseContext() *StartClauseContext {
	var p = new(StartClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_startClause
	return p
}

func (*StartClauseContext) IsStartClauseContext() {}

func NewStartClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartClauseContext {
	var p = new(StartClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_startClause

	return p
}

func (s *StartClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *StartClauseContext) START() antlr.TerminalNode {
	return s.GetToken(CypherParserSTART, 0)
}

func (s *StartClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StartClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StartClauseContext) AllStartPoint() []IStartPointContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStartPointContext); ok {
			len++
		}
	}

	tst := make([]IStartPointContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStartPointContext); ok {
			tst[i] = t.(IStartPointContext)
			i++
		}
	}

	return tst
}

func (s *StartClauseContext) StartPoint(i int) IStartPointContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartPointContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartPointContext)
}

func (s *StartClauseContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *StartClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStartClause(s)
	}
}

func (s *StartClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStartClause(s)
	}
}

func (p *CypherParser) StartClause() (localctx IStartClauseContext) {
	this := p
	_ = this

	localctx = NewStartClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, CypherParserRULE_startClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2281)
		p.Match(CypherParserSTART)
	}
	{
		p.SetState(2282)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2283)
		p.StartPoint()
	}
	p.SetState(2294)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2285)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2284)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2287)
				p.Match(CypherParserT__14)
			}
			p.SetState(2289)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2288)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2291)
				p.StartPoint()
			}

		}
		p.SetState(2296)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())
	}
	p.SetState(2298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(2297)
			p.Where()
		}

	}

	return localctx
}

// IStartPointContext is an interface to support dynamic dispatch.
type IStartPointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartPointContext differentiates from other interfaces.
	IsStartPointContext()
}

type StartPointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartPointContext() *StartPointContext {
	var p = new(StartPointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_startPoint
	return p
}

func (*StartPointContext) IsStartPointContext() {}

func NewStartPointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartPointContext {
	var p = new(StartPointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_startPoint

	return p
}

func (s *StartPointContext) GetParser() antlr.Parser { return s.parser }

func (s *StartPointContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *StartPointContext) Lookup() ILookupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookupContext)
}

func (s *StartPointContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StartPointContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StartPointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartPointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartPointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStartPoint(s)
	}
}

func (s *StartPointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStartPoint(s)
	}
}

func (p *CypherParser) StartPoint() (localctx IStartPointContext) {
	this := p
	_ = this

	localctx = NewStartPointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, CypherParserRULE_startPoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		p.Variable()
	}
	p.SetState(2302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2301)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2304)
		p.Match(CypherParserT__11)
	}
	p.SetState(2306)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2305)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2308)
		p.Lookup()
	}

	return localctx
}

// ILookupContext is an interface to support dynamic dispatch.
type ILookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLookupContext differentiates from other interfaces.
	IsLookupContext()
}

type LookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookupContext() *LookupContext {
	var p = new(LookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_lookup
	return p
}

func (*LookupContext) IsLookupContext() {}

func NewLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupContext {
	var p = new(LookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_lookup

	return p
}

func (s *LookupContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupContext) NodeLookup() INodeLookupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLookupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLookupContext)
}

func (s *LookupContext) RelationshipLookup() IRelationshipLookupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipLookupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipLookupContext)
}

func (s *LookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLookup(s)
	}
}

func (s *LookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLookup(s)
	}
}

func (p *CypherParser) Lookup() (localctx ILookupContext) {
	this := p
	_ = this

	localctx = NewLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, CypherParserRULE_lookup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2312)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserNODE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2310)
			p.NodeLookup()
		}

	case CypherParserRELATIONSHIP, CypherParserREL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2311)
			p.RelationshipLookup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INodeLookupContext is an interface to support dynamic dispatch.
type INodeLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeLookupContext differentiates from other interfaces.
	IsNodeLookupContext()
}

type NodeLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLookupContext() *NodeLookupContext {
	var p = new(NodeLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLookup
	return p
}

func (*NodeLookupContext) IsNodeLookupContext() {}

func NewNodeLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLookupContext {
	var p = new(NodeLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLookup

	return p
}

func (s *NodeLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLookupContext) NODE() antlr.TerminalNode {
	return s.GetToken(CypherParserNODE, 0)
}

func (s *NodeLookupContext) IdentifiedIndexLookup() IIdentifiedIndexLookupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifiedIndexLookupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifiedIndexLookupContext)
}

func (s *NodeLookupContext) IndexQuery() IIndexQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexQueryContext)
}

func (s *NodeLookupContext) IdLookup() IIdLookupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdLookupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdLookupContext)
}

func (s *NodeLookupContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *NodeLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodeLookup(s)
	}
}

func (s *NodeLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodeLookup(s)
	}
}

func (p *CypherParser) NodeLookup() (localctx INodeLookupContext) {
	this := p
	_ = this

	localctx = NewNodeLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, CypherParserRULE_nodeLookup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2314)
		p.Match(CypherParserNODE)
	}
	p.SetState(2316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2315)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2321)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2318)
			p.IdentifiedIndexLookup()
		}

	case 2:
		{
			p.SetState(2319)
			p.IndexQuery()
		}

	case 3:
		{
			p.SetState(2320)
			p.IdLookup()
		}

	}

	return localctx
}

// IRelationshipLookupContext is an interface to support dynamic dispatch.
type IRelationshipLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipLookupContext differentiates from other interfaces.
	IsRelationshipLookupContext()
}

type RelationshipLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipLookupContext() *RelationshipLookupContext {
	var p = new(RelationshipLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipLookup
	return p
}

func (*RelationshipLookupContext) IsRelationshipLookupContext() {}

func NewRelationshipLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipLookupContext {
	var p = new(RelationshipLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipLookup

	return p
}

func (s *RelationshipLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipLookupContext) RELATIONSHIP() antlr.TerminalNode {
	return s.GetToken(CypherParserRELATIONSHIP, 0)
}

func (s *RelationshipLookupContext) REL() antlr.TerminalNode {
	return s.GetToken(CypherParserREL, 0)
}

func (s *RelationshipLookupContext) IdentifiedIndexLookup() IIdentifiedIndexLookupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifiedIndexLookupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifiedIndexLookupContext)
}

func (s *RelationshipLookupContext) IndexQuery() IIndexQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexQueryContext)
}

func (s *RelationshipLookupContext) IdLookup() IIdLookupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdLookupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdLookupContext)
}

func (s *RelationshipLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipLookup(s)
	}
}

func (s *RelationshipLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipLookup(s)
	}
}

func (p *CypherParser) RelationshipLookup() (localctx IRelationshipLookupContext) {
	this := p
	_ = this

	localctx = NewRelationshipLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, CypherParserRULE_relationshipLookup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2323)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserRELATIONSHIP || _la == CypherParserREL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2327)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 272, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2324)
			p.IdentifiedIndexLookup()
		}

	case 2:
		{
			p.SetState(2325)
			p.IndexQuery()
		}

	case 3:
		{
			p.SetState(2326)
			p.IdLookup()
		}

	}

	return localctx
}

// IIdentifiedIndexLookupContext is an interface to support dynamic dispatch.
type IIdentifiedIndexLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifiedIndexLookupContext differentiates from other interfaces.
	IsIdentifiedIndexLookupContext()
}

type IdentifiedIndexLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifiedIndexLookupContext() *IdentifiedIndexLookupContext {
	var p = new(IdentifiedIndexLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_identifiedIndexLookup
	return p
}

func (*IdentifiedIndexLookupContext) IsIdentifiedIndexLookupContext() {}

func NewIdentifiedIndexLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifiedIndexLookupContext {
	var p = new(IdentifiedIndexLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_identifiedIndexLookup

	return p
}

func (s *IdentifiedIndexLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifiedIndexLookupContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *IdentifiedIndexLookupContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *IdentifiedIndexLookupContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *IdentifiedIndexLookupContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *IdentifiedIndexLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifiedIndexLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifiedIndexLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIdentifiedIndexLookup(s)
	}
}

func (s *IdentifiedIndexLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIdentifiedIndexLookup(s)
	}
}

func (p *CypherParser) IdentifiedIndexLookup() (localctx IIdentifiedIndexLookupContext) {
	this := p
	_ = this

	localctx = NewIdentifiedIndexLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, CypherParserRULE_identifiedIndexLookup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2329)
		p.Match(CypherParserT__1)
	}
	{
		p.SetState(2330)
		p.SymbolicName()
	}
	{
		p.SetState(2331)
		p.Match(CypherParserT__19)
	}
	{
		p.SetState(2332)
		p.SymbolicName()
	}
	{
		p.SetState(2333)
		p.Match(CypherParserT__11)
	}
	p.SetState(2336)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserStringLiteral:
		{
			p.SetState(2334)
			p.Match(CypherParserStringLiteral)
		}

	case CypherParserT__13, CypherParserT__33:
		{
			p.SetState(2335)
			p.Parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2338)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IIndexQueryContext is an interface to support dynamic dispatch.
type IIndexQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexQueryContext differentiates from other interfaces.
	IsIndexQueryContext()
}

type IndexQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexQueryContext() *IndexQueryContext {
	var p = new(IndexQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_indexQuery
	return p
}

func (*IndexQueryContext) IsIndexQueryContext() {}

func NewIndexQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexQueryContext {
	var p = new(IndexQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_indexQuery

	return p
}

func (s *IndexQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexQueryContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *IndexQueryContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *IndexQueryContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *IndexQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIndexQuery(s)
	}
}

func (s *IndexQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIndexQuery(s)
	}
}

func (p *CypherParser) IndexQuery() (localctx IIndexQueryContext) {
	this := p
	_ = this

	localctx = NewIndexQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, CypherParserRULE_indexQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2340)
		p.Match(CypherParserT__1)
	}
	{
		p.SetState(2341)
		p.SymbolicName()
	}
	{
		p.SetState(2342)
		p.Match(CypherParserT__19)
	}
	p.SetState(2345)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserStringLiteral:
		{
			p.SetState(2343)
			p.Match(CypherParserStringLiteral)
		}

	case CypherParserT__13, CypherParserT__33:
		{
			p.SetState(2344)
			p.Parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2347)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IIdLookupContext is an interface to support dynamic dispatch.
type IIdLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdLookupContext differentiates from other interfaces.
	IsIdLookupContext()
}

type IdLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdLookupContext() *IdLookupContext {
	var p = new(IdLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_idLookup
	return p
}

func (*IdLookupContext) IsIdLookupContext() {}

func NewIdLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdLookupContext {
	var p = new(IdLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_idLookup

	return p
}

func (s *IdLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *IdLookupContext) LiteralIds() ILiteralIdsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralIdsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralIdsContext)
}

func (s *IdLookupContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *IdLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIdLookup(s)
	}
}

func (s *IdLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIdLookup(s)
	}
}

func (p *CypherParser) IdLookup() (localctx IIdLookupContext) {
	this := p
	_ = this

	localctx = NewIdLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, CypherParserRULE_idLookup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2349)
		p.Match(CypherParserT__19)
	}
	p.SetState(2353)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger:
		{
			p.SetState(2350)
			p.LiteralIds()
		}

	case CypherParserT__13, CypherParserT__33:
		{
			p.SetState(2351)
			p.Parameter()
		}

	case CypherParserT__18:
		{
			p.SetState(2352)
			p.Match(CypherParserT__18)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2355)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// ILiteralIdsContext is an interface to support dynamic dispatch.
type ILiteralIdsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralIdsContext differentiates from other interfaces.
	IsLiteralIdsContext()
}

type LiteralIdsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralIdsContext() *LiteralIdsContext {
	var p = new(LiteralIdsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_literalIds
	return p
}

func (*LiteralIdsContext) IsLiteralIdsContext() {}

func NewLiteralIdsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralIdsContext {
	var p = new(LiteralIdsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_literalIds

	return p
}

func (s *LiteralIdsContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralIdsContext) AllIntegerLiteral() []IIntegerLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			len++
		}
	}

	tst := make([]IIntegerLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntegerLiteralContext); ok {
			tst[i] = t.(IIntegerLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LiteralIdsContext) IntegerLiteral(i int) IIntegerLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LiteralIdsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *LiteralIdsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *LiteralIdsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralIdsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralIdsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLiteralIds(s)
	}
}

func (s *LiteralIdsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLiteralIds(s)
	}
}

func (p *CypherParser) LiteralIds() (localctx ILiteralIdsContext) {
	this := p
	_ = this

	localctx = NewLiteralIdsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, CypherParserRULE_literalIds)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2357)
		p.IntegerLiteral()
	}
	p.SetState(2368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__14 || _la == CypherParserSP {
		p.SetState(2359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2358)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2361)
			p.Match(CypherParserT__14)
		}
		p.SetState(2363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2362)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2365)
			p.IntegerLiteral()
		}

		p.SetState(2370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IWhereContext is an interface to support dynamic dispatch.
type IWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereContext differentiates from other interfaces.
	IsWhereContext()
}

type WhereContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereContext() *WhereContext {
	var p = new(WhereContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_where
	return p
}

func (*WhereContext) IsWhereContext() {}

func NewWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereContext {
	var p = new(WhereContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_where

	return p
}

func (s *WhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *WhereContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *WhereContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterWhere(s)
	}
}

func (s *WhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitWhere(s)
	}
}

func (p *CypherParser) Where() (localctx IWhereContext) {
	this := p
	_ = this

	localctx = NewWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, CypherParserRULE_where)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2371)
		p.Match(CypherParserWHERE)
	}
	{
		p.SetState(2372)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(2373)
		p.Expression()
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllPatternPart() []IPatternPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternPartContext); ok {
			len++
		}
	}

	tst := make([]IPatternPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternPartContext); ok {
			tst[i] = t.(IPatternPartContext)
			i++
		}
	}

	return tst
}

func (s *PatternContext) PatternPart(i int) IPatternPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *PatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *CypherParser) Pattern() (localctx IPatternContext) {
	this := p
	_ = this

	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, CypherParserRULE_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2375)
		p.PatternPart()
	}
	p.SetState(2386)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 281, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2377)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2376)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2379)
				p.Match(CypherParserT__14)
			}
			p.SetState(2381)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2380)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2383)
				p.PatternPart()
			}

		}
		p.SetState(2388)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 281, p.GetParserRuleContext())
	}

	return localctx
}

// IPatternPartContext is an interface to support dynamic dispatch.
type IPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternPartContext differentiates from other interfaces.
	IsPatternPartContext()
}

type PatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternPartContext() *PatternPartContext {
	var p = new(PatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternPart
	return p
}

func (*PatternPartContext) IsPatternPartContext() {}

func NewPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternPartContext {
	var p = new(PatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternPart

	return p
}

func (s *PatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternPartContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PatternPartContext) AnonymousPatternPart() IAnonymousPatternPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousPatternPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousPatternPartContext)
}

func (s *PatternPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternPart(s)
	}
}

func (s *PatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternPart(s)
	}
}

func (p *CypherParser) PatternPart() (localctx IPatternPartContext) {
	this := p
	_ = this

	localctx = NewPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, CypherParserRULE_patternPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2400)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2389)
			p.Variable()
		}
		p.SetState(2391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2390)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2393)
			p.Match(CypherParserT__11)
		}
		p.SetState(2395)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2394)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2397)
			p.AnonymousPatternPart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2399)
			p.AnonymousPatternPart()
		}

	}

	return localctx
}

// IAnonymousPatternPartContext is an interface to support dynamic dispatch.
type IAnonymousPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousPatternPartContext differentiates from other interfaces.
	IsAnonymousPatternPartContext()
}

type AnonymousPatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousPatternPartContext() *AnonymousPatternPartContext {
	var p = new(AnonymousPatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_anonymousPatternPart
	return p
}

func (*AnonymousPatternPartContext) IsAnonymousPatternPartContext() {}

func NewAnonymousPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousPatternPartContext {
	var p = new(AnonymousPatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_anonymousPatternPart

	return p
}

func (s *AnonymousPatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousPatternPartContext) ShortestPathPatternFunction() IShortestPathPatternFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShortestPathPatternFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShortestPathPatternFunctionContext)
}

func (s *AnonymousPatternPartContext) PatternElement() IPatternElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElementContext)
}

func (s *AnonymousPatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousPatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousPatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAnonymousPatternPart(s)
	}
}

func (s *AnonymousPatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAnonymousPatternPart(s)
	}
}

func (p *CypherParser) AnonymousPatternPart() (localctx IAnonymousPatternPartContext) {
	this := p
	_ = this

	localctx = NewAnonymousPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, CypherParserRULE_anonymousPatternPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2404)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2402)
			p.ShortestPathPatternFunction()
		}

	case CypherParserT__19:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2403)
			p.PatternElement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPatternElementContext is an interface to support dynamic dispatch.
type IPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternElementContext differentiates from other interfaces.
	IsPatternElementContext()
}

type PatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElementContext() *PatternElementContext {
	var p = new(PatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternElement
	return p
}

func (*PatternElementContext) IsPatternElementContext() {}

func NewPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElementContext {
	var p = new(PatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElement

	return p
}

func (s *PatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElementContext) NodePattern() INodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElementContext) AllPatternElementChain() []IPatternElementChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternElementChainContext); ok {
			len++
		}
	}

	tst := make([]IPatternElementChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternElementChainContext); ok {
			tst[i] = t.(IPatternElementChainContext)
			i++
		}
	}

	return tst
}

func (s *PatternElementContext) PatternElementChain(i int) IPatternElementChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElementChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElementChainContext)
}

func (s *PatternElementContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternElementContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternElementContext) PatternElement() IPatternElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElementContext)
}

func (s *PatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternElement(s)
	}
}

func (s *PatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternElement(s)
	}
}

func (p *CypherParser) PatternElement() (localctx IPatternElementContext) {
	this := p
	_ = this

	localctx = NewPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, CypherParserRULE_patternElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 288, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2406)
			p.NodePattern()
		}
		p.SetState(2413)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2408)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2407)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2410)
					p.PatternElementChain()
				}

			}
			p.SetState(2415)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2416)
			p.Match(CypherParserT__19)
		}
		{
			p.SetState(2417)
			p.PatternElement()
		}
		{
			p.SetState(2418)
			p.Match(CypherParserT__20)
		}

	}

	return localctx
}

// INodePatternContext is an interface to support dynamic dispatch.
type INodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodePatternContext differentiates from other interfaces.
	IsNodePatternContext()
}

type NodePatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodePatternContext() *NodePatternContext {
	var p = new(NodePatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodePattern
	return p
}

func (*NodePatternContext) IsNodePatternContext() {}

func NewNodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodePatternContext {
	var p = new(NodePatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodePattern

	return p
}

func (s *NodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *NodePatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodePatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodePatternContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *NodePatternContext) NodeLabels() INodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *NodePatternContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *NodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodePattern(s)
	}
}

func (s *NodePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodePattern(s)
	}
}

func (p *CypherParser) NodePattern() (localctx INodePatternContext) {
	this := p
	_ = this

	localctx = NewNodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, CypherParserRULE_nodePattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2422)
		p.Match(CypherParserT__19)
	}
	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2423)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(CypherParserCYPHER-54))|(1<<(CypherParserEXPLAIN-54))|(1<<(CypherParserPROFILE-54))|(1<<(CypherParserUSING-54))|(1<<(CypherParserPERIODIC-54))|(1<<(CypherParserCOMMIT-54))|(1<<(CypherParserUNION-54))|(1<<(CypherParserALL-54))|(1<<(CypherParserCREATE-54))|(1<<(CypherParserDROP-54))|(1<<(CypherParserINDEX-54))|(1<<(CypherParserON-54))|(1<<(CypherParserCONSTRAINT-54))|(1<<(CypherParserASSERT-54))|(1<<(CypherParserIS-54))|(1<<(CypherParserUNIQUE-54))|(1<<(CypherParserEXISTS-54))|(1<<(CypherParserLOAD-54))|(1<<(CypherParserCSV-54))|(1<<(CypherParserWITH-54))|(1<<(CypherParserHEADERS-54))|(1<<(CypherParserFROM-54))|(1<<(CypherParserAS-54))|(1<<(CypherParserFIELDTERMINATOR-54))|(1<<(CypherParserOPTIONAL-54))|(1<<(CypherParserMATCH-54))|(1<<(CypherParserUNWIND-54))|(1<<(CypherParserMERGE-54))|(1<<(CypherParserSET-54))|(1<<(CypherParserDETACH-54))|(1<<(CypherParserDELETE-54))|(1<<(CypherParserREMOVE-54)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(CypherParserFOREACH-86))|(1<<(CypherParserIN-86))|(1<<(CypherParserDISTINCT-86))|(1<<(CypherParserRETURN-86))|(1<<(CypherParserORDER-86))|(1<<(CypherParserBY-86))|(1<<(CypherParserL_SKIP-86))|(1<<(CypherParserLIMIT-86))|(1<<(CypherParserASCENDING-86))|(1<<(CypherParserASC-86))|(1<<(CypherParserDESCENDING-86))|(1<<(CypherParserDESC-86))|(1<<(CypherParserJOIN-86))|(1<<(CypherParserSCAN-86))|(1<<(CypherParserSTART-86))|(1<<(CypherParserNODE-86))|(1<<(CypherParserRELATIONSHIP-86))|(1<<(CypherParserREL-86))|(1<<(CypherParserWHERE-86))|(1<<(CypherParserSHORTESTPATH-86))|(1<<(CypherParserALLSHORTESTPATHS-86))|(1<<(CypherParserOR-86))|(1<<(CypherParserXOR-86))|(1<<(CypherParserAND-86))|(1<<(CypherParserNOT-86))|(1<<(CypherParserSTARTS-86))|(1<<(CypherParserENDS-86))|(1<<(CypherParserCONTAINS-86))|(1<<(CypherParserNULL-86))|(1<<(CypherParserCOUNT-86))|(1<<(CypherParserFILTER-86))|(1<<(CypherParserEXTRACT-86)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(CypherParserANY-118))|(1<<(CypherParserNONE-118))|(1<<(CypherParserSINGLE-118))|(1<<(CypherParserTRUE-118))|(1<<(CypherParserFALSE-118))|(1<<(CypherParserREDUCE-118))|(1<<(CypherParserCASE-118))|(1<<(CypherParserELSE-118))|(1<<(CypherParserEND-118))|(1<<(CypherParserWHEN-118))|(1<<(CypherParserTHEN-118))|(1<<(CypherParserCALL-118))|(1<<(CypherParserYIELD-118))|(1<<(CypherParserKEY-118))|(1<<(CypherParserCATALOG-118))|(1<<(CypherParserSHOW-118))|(1<<(CypherParserDEFAULT-118))|(1<<(CypherParserDBMS-118))|(1<<(CypherParserDATABASE-118))|(1<<(CypherParserDATABASES-118))|(1<<(CypherParserGRAPH-118))|(1<<(CypherParserGRAPHS-118))|(1<<(CypherParserREPLACE-118))|(1<<(CypherParserIF-118))|(1<<(CypherParserSTOP-118))|(1<<(CypherParserROLE-118))|(1<<(CypherParserROLES-118))|(1<<(CypherParserUSER-118))|(1<<(CypherParserUSERS-118))|(1<<(CypherParserPOPULATED-118))|(1<<(CypherParserPASSWORD-118))|(1<<(CypherParserCHANGE-118)))) != 0) || (((_la-150)&-(0x1f+1)) == 0 && ((1<<uint((_la-150)))&((1<<(CypherParserREQUIRED-150))|(1<<(CypherParserSTATUS-150))|(1<<(CypherParserACTIVE-150))|(1<<(CypherParserSUSPENDED-150))|(1<<(CypherParserALTER-150))|(1<<(CypherParserCURRENT-150))|(1<<(CypherParserTO-150))|(1<<(CypherParserPRIVILEGES-150))|(1<<(CypherParserGRANT-150))|(1<<(CypherParserDENY-150))|(1<<(CypherParserREVOKE-150))|(1<<(CypherParserRELATIONSHIPS-150))|(1<<(CypherParserNODES-150))|(1<<(CypherParserELEMENT-150))|(1<<(CypherParserELEMENTS-150))|(1<<(CypherParserCOPY-150))|(1<<(CypherParserOF-150))|(1<<(CypherParserTRAVERSE-150))|(1<<(CypherParserREAD-150))|(1<<(CypherParserWRITE-150))|(1<<(CypherParserACCESS-150))|(1<<(CypherParserINDEXES-150))|(1<<(CypherParserMANAGEMENT-150))|(1<<(CypherParserNEW-150))|(1<<(CypherParserLABEL-150))|(1<<(CypherParserLABELS-150))|(1<<(CypherParserNAME-150))|(1<<(CypherParserNAMES-150))|(1<<(CypherParserTYPE-150))|(1<<(CypherParserTYPES-150))|(1<<(CypherParserPROPERTY-150))|(1<<(CypherParserCONSTRAINTS-150)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(CypherParserASSIGN-182))|(1<<(CypherParserBTREE-182))|(1<<(CypherParserEXIST-182))|(1<<(CypherParserFOR-182))|(1<<(CypherParserOPTIONS-182))|(1<<(CypherParserEXECUTE-182))|(1<<(CypherParserDEFINED-182))|(1<<(CypherParserFUNCTION-182))|(1<<(CypherParserFUNCTIONS-182))|(1<<(CypherParserBOOSTED-182))|(1<<(CypherParserPROCEDURE-182))|(1<<(CypherParserPROCEDURES-182))|(1<<(CypherParserADMIN-182))|(1<<(CypherParserADMINISTRATOR-182))|(1<<(CypherParserBRIEF-182))|(1<<(CypherParserVERBOSE-182))|(1<<(CypherParserOUTPUT-182))|(1<<(CypherParserBUILT-182))|(1<<(CypherParserEACH-182))|(1<<(CypherParserEXECUTABLE-182))|(1<<(CypherParserEXISTENCE-182))|(1<<(CypherParserFULLTEXT-182))|(1<<(CypherParserHOME-182))|(1<<(CypherParserLOOKUP-182))|(1<<(CypherParserHexLetter-182)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(2426)
			p.Variable()
		}
		p.SetState(2428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2427)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(2436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__1 {
		{
			p.SetState(2432)
			p.NodeLabels()
		}
		p.SetState(2434)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2433)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__13 || _la == CypherParserT__33 {
		{
			p.SetState(2438)
			p.Properties()
		}
		p.SetState(2440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2439)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(2444)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IPatternElementChainContext is an interface to support dynamic dispatch.
type IPatternElementChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternElementChainContext differentiates from other interfaces.
	IsPatternElementChainContext()
}

type PatternElementChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElementChainContext() *PatternElementChainContext {
	var p = new(PatternElementChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternElementChain
	return p
}

func (*PatternElementChainContext) IsPatternElementChainContext() {}

func NewPatternElementChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElementChainContext {
	var p = new(PatternElementChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElementChain

	return p
}

func (s *PatternElementChainContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElementChainContext) RelationshipPattern() IRelationshipPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipPatternContext)
}

func (s *PatternElementChainContext) NodePattern() INodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElementChainContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PatternElementChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElementChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElementChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternElementChain(s)
	}
}

func (s *PatternElementChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternElementChain(s)
	}
}

func (p *CypherParser) PatternElementChain() (localctx IPatternElementChainContext) {
	this := p
	_ = this

	localctx = NewPatternElementChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, CypherParserRULE_patternElementChain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2446)
		p.RelationshipPattern()
	}
	p.SetState(2448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2447)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2450)
		p.NodePattern()
	}

	return localctx
}

// IRelationshipPatternContext is an interface to support dynamic dispatch.
type IRelationshipPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipPatternContext differentiates from other interfaces.
	IsRelationshipPatternContext()
}

type RelationshipPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPatternContext() *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPattern
	return p
}

func (*RelationshipPatternContext) IsRelationshipPatternContext() {}

func NewRelationshipPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPattern

	return p
}

func (s *RelationshipPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPatternContext) RelationshipPatternStart() IRelationshipPatternStartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipPatternStartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipPatternStartContext)
}

func (s *RelationshipPatternContext) RelationshipPatternEnd() IRelationshipPatternEndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipPatternEndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipPatternEndContext)
}

func (s *RelationshipPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipPatternContext) RelationshipDetail() IRelationshipDetailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipDetailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipDetailContext)
}

func (s *RelationshipPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipPattern(s)
	}
}

func (s *RelationshipPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipPattern(s)
	}
}

func (p *CypherParser) RelationshipPattern() (localctx IRelationshipPatternContext) {
	this := p
	_ = this

	localctx = NewRelationshipPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, CypherParserRULE_relationshipPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2452)
		p.RelationshipPatternStart()
	}
	p.SetState(2454)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2453)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__16 {
		{
			p.SetState(2456)
			p.RelationshipDetail()
		}

	}
	p.SetState(2460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2459)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2462)
		p.RelationshipPatternEnd()
	}

	return localctx
}

// IRelationshipPatternStartContext is an interface to support dynamic dispatch.
type IRelationshipPatternStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipPatternStartContext differentiates from other interfaces.
	IsRelationshipPatternStartContext()
}

type RelationshipPatternStartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPatternStartContext() *RelationshipPatternStartContext {
	var p = new(RelationshipPatternStartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPatternStart
	return p
}

func (*RelationshipPatternStartContext) IsRelationshipPatternStartContext() {}

func NewRelationshipPatternStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPatternStartContext {
	var p = new(RelationshipPatternStartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPatternStart

	return p
}

func (s *RelationshipPatternStartContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPatternStartContext) LeftArrowHead() ILeftArrowHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftArrowHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftArrowHeadContext)
}

func (s *RelationshipPatternStartContext) Dash() IDashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDashContext)
}

func (s *RelationshipPatternStartContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *RelationshipPatternStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPatternStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPatternStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipPatternStart(s)
	}
}

func (s *RelationshipPatternStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipPatternStart(s)
	}
}

func (p *CypherParser) RelationshipPatternStart() (localctx IRelationshipPatternStartContext) {
	this := p
	_ = this

	localctx = NewRelationshipPatternStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, CypherParserRULE_relationshipPatternStart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2471)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__29, CypherParserT__34, CypherParserT__35, CypherParserT__36, CypherParserT__37:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2464)
			p.LeftArrowHead()
		}
		p.SetState(2466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2465)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2468)
			p.Dash()
		}

	case CypherParserT__2, CypherParserT__42, CypherParserT__43, CypherParserT__44, CypherParserT__45, CypherParserT__46, CypherParserT__47, CypherParserT__48, CypherParserT__49, CypherParserT__50, CypherParserT__51, CypherParserT__52:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2470)
			p.Dash()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRelationshipPatternEndContext is an interface to support dynamic dispatch.
type IRelationshipPatternEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipPatternEndContext differentiates from other interfaces.
	IsRelationshipPatternEndContext()
}

type RelationshipPatternEndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPatternEndContext() *RelationshipPatternEndContext {
	var p = new(RelationshipPatternEndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPatternEnd
	return p
}

func (*RelationshipPatternEndContext) IsRelationshipPatternEndContext() {}

func NewRelationshipPatternEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPatternEndContext {
	var p = new(RelationshipPatternEndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPatternEnd

	return p
}

func (s *RelationshipPatternEndContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPatternEndContext) Dash() IDashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDashContext)
}

func (s *RelationshipPatternEndContext) RightArrowHead() IRightArrowHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRightArrowHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRightArrowHeadContext)
}

func (s *RelationshipPatternEndContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *RelationshipPatternEndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPatternEndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPatternEndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipPatternEnd(s)
	}
}

func (s *RelationshipPatternEndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipPatternEnd(s)
	}
}

func (p *CypherParser) RelationshipPatternEnd() (localctx IRelationshipPatternEndContext) {
	this := p
	_ = this

	localctx = NewRelationshipPatternEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, CypherParserRULE_relationshipPatternEnd)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2480)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2473)
			p.Dash()
		}
		p.SetState(2475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2474)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2477)
			p.RightArrowHead()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2479)
			p.Dash()
		}

	}

	return localctx
}

// IRelationshipDetailContext is an interface to support dynamic dispatch.
type IRelationshipDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipDetailContext differentiates from other interfaces.
	IsRelationshipDetailContext()
}

type RelationshipDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipDetailContext() *RelationshipDetailContext {
	var p = new(RelationshipDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipDetail
	return p
}

func (*RelationshipDetailContext) IsRelationshipDetailContext() {}

func NewRelationshipDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipDetailContext {
	var p = new(RelationshipDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipDetail

	return p
}

func (s *RelationshipDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipDetailContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipDetailContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipDetailContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RelationshipDetailContext) RelationshipTypes() IRelationshipTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipTypesContext)
}

func (s *RelationshipDetailContext) RangeLiteral() IRangeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeLiteralContext)
}

func (s *RelationshipDetailContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RelationshipDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipDetail(s)
	}
}

func (s *RelationshipDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipDetail(s)
	}
}

func (p *CypherParser) RelationshipDetail() (localctx IRelationshipDetailContext) {
	this := p
	_ = this

	localctx = NewRelationshipDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, CypherParserRULE_relationshipDetail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2482)
		p.Match(CypherParserT__16)
	}
	p.SetState(2484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2483)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2490)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(CypherParserCYPHER-54))|(1<<(CypherParserEXPLAIN-54))|(1<<(CypherParserPROFILE-54))|(1<<(CypherParserUSING-54))|(1<<(CypherParserPERIODIC-54))|(1<<(CypherParserCOMMIT-54))|(1<<(CypherParserUNION-54))|(1<<(CypherParserALL-54))|(1<<(CypherParserCREATE-54))|(1<<(CypherParserDROP-54))|(1<<(CypherParserINDEX-54))|(1<<(CypherParserON-54))|(1<<(CypherParserCONSTRAINT-54))|(1<<(CypherParserASSERT-54))|(1<<(CypherParserIS-54))|(1<<(CypherParserUNIQUE-54))|(1<<(CypherParserEXISTS-54))|(1<<(CypherParserLOAD-54))|(1<<(CypherParserCSV-54))|(1<<(CypherParserWITH-54))|(1<<(CypherParserHEADERS-54))|(1<<(CypherParserFROM-54))|(1<<(CypherParserAS-54))|(1<<(CypherParserFIELDTERMINATOR-54))|(1<<(CypherParserOPTIONAL-54))|(1<<(CypherParserMATCH-54))|(1<<(CypherParserUNWIND-54))|(1<<(CypherParserMERGE-54))|(1<<(CypherParserSET-54))|(1<<(CypherParserDETACH-54))|(1<<(CypherParserDELETE-54))|(1<<(CypherParserREMOVE-54)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(CypherParserFOREACH-86))|(1<<(CypherParserIN-86))|(1<<(CypherParserDISTINCT-86))|(1<<(CypherParserRETURN-86))|(1<<(CypherParserORDER-86))|(1<<(CypherParserBY-86))|(1<<(CypherParserL_SKIP-86))|(1<<(CypherParserLIMIT-86))|(1<<(CypherParserASCENDING-86))|(1<<(CypherParserASC-86))|(1<<(CypherParserDESCENDING-86))|(1<<(CypherParserDESC-86))|(1<<(CypherParserJOIN-86))|(1<<(CypherParserSCAN-86))|(1<<(CypherParserSTART-86))|(1<<(CypherParserNODE-86))|(1<<(CypherParserRELATIONSHIP-86))|(1<<(CypherParserREL-86))|(1<<(CypherParserWHERE-86))|(1<<(CypherParserSHORTESTPATH-86))|(1<<(CypherParserALLSHORTESTPATHS-86))|(1<<(CypherParserOR-86))|(1<<(CypherParserXOR-86))|(1<<(CypherParserAND-86))|(1<<(CypherParserNOT-86))|(1<<(CypherParserSTARTS-86))|(1<<(CypherParserENDS-86))|(1<<(CypherParserCONTAINS-86))|(1<<(CypherParserNULL-86))|(1<<(CypherParserCOUNT-86))|(1<<(CypherParserFILTER-86))|(1<<(CypherParserEXTRACT-86)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(CypherParserANY-118))|(1<<(CypherParserNONE-118))|(1<<(CypherParserSINGLE-118))|(1<<(CypherParserTRUE-118))|(1<<(CypherParserFALSE-118))|(1<<(CypherParserREDUCE-118))|(1<<(CypherParserCASE-118))|(1<<(CypherParserELSE-118))|(1<<(CypherParserEND-118))|(1<<(CypherParserWHEN-118))|(1<<(CypherParserTHEN-118))|(1<<(CypherParserCALL-118))|(1<<(CypherParserYIELD-118))|(1<<(CypherParserKEY-118))|(1<<(CypherParserCATALOG-118))|(1<<(CypherParserSHOW-118))|(1<<(CypherParserDEFAULT-118))|(1<<(CypherParserDBMS-118))|(1<<(CypherParserDATABASE-118))|(1<<(CypherParserDATABASES-118))|(1<<(CypherParserGRAPH-118))|(1<<(CypherParserGRAPHS-118))|(1<<(CypherParserREPLACE-118))|(1<<(CypherParserIF-118))|(1<<(CypherParserSTOP-118))|(1<<(CypherParserROLE-118))|(1<<(CypherParserROLES-118))|(1<<(CypherParserUSER-118))|(1<<(CypherParserUSERS-118))|(1<<(CypherParserPOPULATED-118))|(1<<(CypherParserPASSWORD-118))|(1<<(CypherParserCHANGE-118)))) != 0) || (((_la-150)&-(0x1f+1)) == 0 && ((1<<uint((_la-150)))&((1<<(CypherParserREQUIRED-150))|(1<<(CypherParserSTATUS-150))|(1<<(CypherParserACTIVE-150))|(1<<(CypherParserSUSPENDED-150))|(1<<(CypherParserALTER-150))|(1<<(CypherParserCURRENT-150))|(1<<(CypherParserTO-150))|(1<<(CypherParserPRIVILEGES-150))|(1<<(CypherParserGRANT-150))|(1<<(CypherParserDENY-150))|(1<<(CypherParserREVOKE-150))|(1<<(CypherParserRELATIONSHIPS-150))|(1<<(CypherParserNODES-150))|(1<<(CypherParserELEMENT-150))|(1<<(CypherParserELEMENTS-150))|(1<<(CypherParserCOPY-150))|(1<<(CypherParserOF-150))|(1<<(CypherParserTRAVERSE-150))|(1<<(CypherParserREAD-150))|(1<<(CypherParserWRITE-150))|(1<<(CypherParserACCESS-150))|(1<<(CypherParserINDEXES-150))|(1<<(CypherParserMANAGEMENT-150))|(1<<(CypherParserNEW-150))|(1<<(CypherParserLABEL-150))|(1<<(CypherParserLABELS-150))|(1<<(CypherParserNAME-150))|(1<<(CypherParserNAMES-150))|(1<<(CypherParserTYPE-150))|(1<<(CypherParserTYPES-150))|(1<<(CypherParserPROPERTY-150))|(1<<(CypherParserCONSTRAINTS-150)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(CypherParserASSIGN-182))|(1<<(CypherParserBTREE-182))|(1<<(CypherParserEXIST-182))|(1<<(CypherParserFOR-182))|(1<<(CypherParserOPTIONS-182))|(1<<(CypherParserEXECUTE-182))|(1<<(CypherParserDEFINED-182))|(1<<(CypherParserFUNCTION-182))|(1<<(CypherParserFUNCTIONS-182))|(1<<(CypherParserBOOSTED-182))|(1<<(CypherParserPROCEDURE-182))|(1<<(CypherParserPROCEDURES-182))|(1<<(CypherParserADMIN-182))|(1<<(CypherParserADMINISTRATOR-182))|(1<<(CypherParserBRIEF-182))|(1<<(CypherParserVERBOSE-182))|(1<<(CypherParserOUTPUT-182))|(1<<(CypherParserBUILT-182))|(1<<(CypherParserEACH-182))|(1<<(CypherParserEXECUTABLE-182))|(1<<(CypherParserEXISTENCE-182))|(1<<(CypherParserFULLTEXT-182))|(1<<(CypherParserHOME-182))|(1<<(CypherParserLOOKUP-182))|(1<<(CypherParserHexLetter-182)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(2486)
			p.Variable()
		}
		p.SetState(2488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2487)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(2496)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__1 {
		{
			p.SetState(2492)
			p.RelationshipTypes()
		}
		p.SetState(2494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2493)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(2499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__18 {
		{
			p.SetState(2498)
			p.RangeLiteral()
		}

	}
	p.SetState(2505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__13 || _la == CypherParserT__33 {
		{
			p.SetState(2501)
			p.Properties()
		}
		p.SetState(2503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2502)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(2507)
		p.Match(CypherParserT__17)
	}

	return localctx
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_properties
	return p
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *PropertiesContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (p *CypherParser) Properties() (localctx IPropertiesContext) {
	this := p
	_ = this

	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, CypherParserRULE_properties)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2511)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 312, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2509)
			p.MapLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2510)
			p.Parameter()
		}

	}

	return localctx
}

// IRelTypeContext is an interface to support dynamic dispatch.
type IRelTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelTypeContext differentiates from other interfaces.
	IsRelTypeContext()
}

type RelTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelTypeContext() *RelTypeContext {
	var p = new(RelTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relType
	return p
}

func (*RelTypeContext) IsRelTypeContext() {}

func NewRelTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelTypeContext {
	var p = new(RelTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relType

	return p
}

func (s *RelTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RelTypeContext) RelTypeName() IRelTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelTypeNameContext)
}

func (s *RelTypeContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *RelTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelType(s)
	}
}

func (s *RelTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelType(s)
	}
}

func (p *CypherParser) RelType() (localctx IRelTypeContext) {
	this := p
	_ = this

	localctx = NewRelTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, CypherParserRULE_relType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2513)
		p.Match(CypherParserT__1)
	}
	p.SetState(2515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2514)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2517)
		p.RelTypeName()
	}

	return localctx
}

// IRelationshipTypesContext is an interface to support dynamic dispatch.
type IRelationshipTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipTypesContext differentiates from other interfaces.
	IsRelationshipTypesContext()
}

type RelationshipTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipTypesContext() *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipTypes
	return p
}

func (*RelationshipTypesContext) IsRelationshipTypesContext() {}

func NewRelationshipTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipTypes

	return p
}

func (s *RelationshipTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipTypesContext) RelationshipType() IRelationshipTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipTypeContext)
}

func (s *RelationshipTypesContext) AllRelationshipTypeOptionalColon() []IRelationshipTypeOptionalColonContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationshipTypeOptionalColonContext); ok {
			len++
		}
	}

	tst := make([]IRelationshipTypeOptionalColonContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationshipTypeOptionalColonContext); ok {
			tst[i] = t.(IRelationshipTypeOptionalColonContext)
			i++
		}
	}

	return tst
}

func (s *RelationshipTypesContext) RelationshipTypeOptionalColon(i int) IRelationshipTypeOptionalColonContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipTypeOptionalColonContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipTypeOptionalColonContext)
}

func (s *RelationshipTypesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipTypesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipTypes(s)
	}
}

func (s *RelationshipTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipTypes(s)
	}
}

func (p *CypherParser) RelationshipTypes() (localctx IRelationshipTypesContext) {
	this := p
	_ = this

	localctx = NewRelationshipTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, CypherParserRULE_relationshipTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2519)
		p.RelationshipType()
	}
	p.SetState(2527)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2521)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2520)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2523)
				p.Match(CypherParserT__22)
			}
			{
				p.SetState(2524)
				p.RelationshipTypeOptionalColon()
			}

		}
		p.SetState(2529)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext())
	}

	return localctx
}

// IRelationshipTypeContext is an interface to support dynamic dispatch.
type IRelationshipTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipTypeContext differentiates from other interfaces.
	IsRelationshipTypeContext()
}

type RelationshipTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipTypeContext() *RelationshipTypeContext {
	var p = new(RelationshipTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipType
	return p
}

func (*RelationshipTypeContext) IsRelationshipTypeContext() {}

func NewRelationshipTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipTypeContext {
	var p = new(RelationshipTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipType

	return p
}

func (s *RelationshipTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipTypeContext) RelTypeName() IRelTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelTypeNameContext)
}

func (s *RelationshipTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipType(s)
	}
}

func (s *RelationshipTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipType(s)
	}
}

func (p *CypherParser) RelationshipType() (localctx IRelationshipTypeContext) {
	this := p
	_ = this

	localctx = NewRelationshipTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, CypherParserRULE_relationshipType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2530)
		p.Match(CypherParserT__1)
	}
	{
		p.SetState(2531)
		p.RelTypeName()
	}

	return localctx
}

// IRelationshipTypeOptionalColonContext is an interface to support dynamic dispatch.
type IRelationshipTypeOptionalColonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipTypeOptionalColonContext differentiates from other interfaces.
	IsRelationshipTypeOptionalColonContext()
}

type RelationshipTypeOptionalColonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipTypeOptionalColonContext() *RelationshipTypeOptionalColonContext {
	var p = new(RelationshipTypeOptionalColonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipTypeOptionalColon
	return p
}

func (*RelationshipTypeOptionalColonContext) IsRelationshipTypeOptionalColonContext() {}

func NewRelationshipTypeOptionalColonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipTypeOptionalColonContext {
	var p = new(RelationshipTypeOptionalColonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipTypeOptionalColon

	return p
}

func (s *RelationshipTypeOptionalColonContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipTypeOptionalColonContext) RelTypeName() IRelTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelTypeNameContext)
}

func (s *RelationshipTypeOptionalColonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipTypeOptionalColonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipTypeOptionalColonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipTypeOptionalColon(s)
	}
}

func (s *RelationshipTypeOptionalColonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipTypeOptionalColon(s)
	}
}

func (p *CypherParser) RelationshipTypeOptionalColon() (localctx IRelationshipTypeOptionalColonContext) {
	this := p
	_ = this

	localctx = NewRelationshipTypeOptionalColonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, CypherParserRULE_relationshipTypeOptionalColon)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__1 {
		{
			p.SetState(2533)
			p.Match(CypherParserT__1)
		}

	}
	{
		p.SetState(2536)
		p.RelTypeName()
	}

	return localctx
}

// INodeLabelsContext is an interface to support dynamic dispatch.
type INodeLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeLabelsContext differentiates from other interfaces.
	IsNodeLabelsContext()
}

type NodeLabelsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLabelsContext() *NodeLabelsContext {
	var p = new(NodeLabelsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabels
	return p
}

func (*NodeLabelsContext) IsNodeLabelsContext() {}

func NewNodeLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLabelsContext {
	var p = new(NodeLabelsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLabels

	return p
}

func (s *NodeLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLabelsContext) AllNodeLabel() []INodeLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INodeLabelContext); ok {
			len++
		}
	}

	tst := make([]INodeLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INodeLabelContext); ok {
			tst[i] = t.(INodeLabelContext)
			i++
		}
	}

	return tst
}

func (s *NodeLabelsContext) NodeLabel(i int) INodeLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *NodeLabelsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodeLabelsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodeLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodeLabels(s)
	}
}

func (s *NodeLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodeLabels(s)
	}
}

func (p *CypherParser) NodeLabels() (localctx INodeLabelsContext) {
	this := p
	_ = this

	localctx = NewNodeLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, CypherParserRULE_nodeLabels)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2538)
		p.NodeLabel()
	}
	p.SetState(2545)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2540)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2539)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2542)
				p.NodeLabel()
			}

		}
		p.SetState(2547)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())
	}

	return localctx
}

// INodeLabelContext is an interface to support dynamic dispatch.
type INodeLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeLabelContext differentiates from other interfaces.
	IsNodeLabelContext()
}

type NodeLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLabelContext() *NodeLabelContext {
	var p = new(NodeLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabel
	return p
}

func (*NodeLabelContext) IsNodeLabelContext() {}

func NewNodeLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLabelContext {
	var p = new(NodeLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLabel

	return p
}

func (s *NodeLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLabelContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *NodeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodeLabel(s)
	}
}

func (s *NodeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodeLabel(s)
	}
}

func (p *CypherParser) NodeLabel() (localctx INodeLabelContext) {
	this := p
	_ = this

	localctx = NewNodeLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, CypherParserRULE_nodeLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2548)
		p.Match(CypherParserT__1)
	}
	{
		p.SetState(2549)
		p.LabelName()
	}

	return localctx
}

// IRangeLiteralContext is an interface to support dynamic dispatch.
type IRangeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeLiteralContext differentiates from other interfaces.
	IsRangeLiteralContext()
}

type RangeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeLiteralContext() *RangeLiteralContext {
	var p = new(RangeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_rangeLiteral
	return p
}

func (*RangeLiteralContext) IsRangeLiteralContext() {}

func NewRangeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeLiteralContext {
	var p = new(RangeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_rangeLiteral

	return p
}

func (s *RangeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RangeLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RangeLiteralContext) AllIntegerLiteral() []IIntegerLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			len++
		}
	}

	tst := make([]IIntegerLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntegerLiteralContext); ok {
			tst[i] = t.(IIntegerLiteralContext)
			i++
		}
	}

	return tst
}

func (s *RangeLiteralContext) IntegerLiteral(i int) IIntegerLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RangeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRangeLiteral(s)
	}
}

func (s *RangeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRangeLiteral(s)
	}
}

func (p *CypherParser) RangeLiteral() (localctx IRangeLiteralContext) {
	this := p
	_ = this

	localctx = NewRangeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, CypherParserRULE_rangeLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2551)
		p.Match(CypherParserT__18)
	}
	p.SetState(2553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2552)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(2559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-210)&-(0x1f+1)) == 0 && ((1<<uint((_la-210)))&((1<<(CypherParserHexInteger-210))|(1<<(CypherParserDecimalInteger-210))|(1<<(CypherParserOctalInteger-210)))) != 0 {
		{
			p.SetState(2555)
			p.IntegerLiteral()
		}
		p.SetState(2557)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2556)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(2571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__23 {
		{
			p.SetState(2561)
			p.Match(CypherParserT__23)
		}
		p.SetState(2563)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2562)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(2569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-210)&-(0x1f+1)) == 0 && ((1<<uint((_la-210)))&((1<<(CypherParserHexInteger-210))|(1<<(CypherParserDecimalInteger-210))|(1<<(CypherParserOctalInteger-210)))) != 0 {
			{
				p.SetState(2565)
				p.IntegerLiteral()
			}
			p.SetState(2567)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2566)
					p.Match(CypherParserSP)
				}

			}

		}

	}

	return localctx
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_labelName
	return p
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (p *CypherParser) LabelName() (localctx ILabelNameContext) {
	this := p
	_ = this

	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, CypherParserRULE_labelName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2573)
		p.SymbolicName()
	}

	return localctx
}

// IRelTypeNameContext is an interface to support dynamic dispatch.
type IRelTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelTypeNameContext differentiates from other interfaces.
	IsRelTypeNameContext()
}

type RelTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelTypeNameContext() *RelTypeNameContext {
	var p = new(RelTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relTypeName
	return p
}

func (*RelTypeNameContext) IsRelTypeNameContext() {}

func NewRelTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelTypeNameContext {
	var p = new(RelTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relTypeName

	return p
}

func (s *RelTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RelTypeNameContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *RelTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelTypeName(s)
	}
}

func (s *RelTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelTypeName(s)
	}
}

func (p *CypherParser) RelTypeName() (localctx IRelTypeNameContext) {
	this := p
	_ = this

	localctx = NewRelTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, CypherParserRULE_relTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2575)
		p.SymbolicName()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) OrExpression() IOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *CypherParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, CypherParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2577)
		p.OrExpression()
	}

	return localctx
}

// IOrExpressionContext is an interface to support dynamic dispatch.
type IOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrExpressionContext differentiates from other interfaces.
	IsOrExpressionContext()
}

type OrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExpressionContext() *OrExpressionContext {
	var p = new(OrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_orExpression
	return p
}

func (*OrExpressionContext) IsOrExpressionContext() {}

func NewOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExpressionContext {
	var p = new(OrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_orExpression

	return p
}

func (s *OrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExpressionContext) AllXorExpression() []IXorExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXorExpressionContext); ok {
			len++
		}
	}

	tst := make([]IXorExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXorExpressionContext); ok {
			tst[i] = t.(IXorExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrExpressionContext) XorExpression(i int) IXorExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXorExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXorExpressionContext)
}

func (s *OrExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OrExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OrExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserOR)
}

func (s *OrExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserOR, i)
}

func (s *OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOrExpression(s)
	}
}

func (s *OrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOrExpression(s)
	}
}

func (p *CypherParser) OrExpression() (localctx IOrExpressionContext) {
	this := p
	_ = this

	localctx = NewOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, CypherParserRULE_orExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2579)
		p.XorExpression()
	}
	p.SetState(2586)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2580)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(2581)
				p.Match(CypherParserOR)
			}
			{
				p.SetState(2582)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(2583)
				p.XorExpression()
			}

		}
		p.SetState(2588)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())
	}

	return localctx
}

// IXorExpressionContext is an interface to support dynamic dispatch.
type IXorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXorExpressionContext differentiates from other interfaces.
	IsXorExpressionContext()
}

type XorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXorExpressionContext() *XorExpressionContext {
	var p = new(XorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_xorExpression
	return p
}

func (*XorExpressionContext) IsXorExpressionContext() {}

func NewXorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XorExpressionContext {
	var p = new(XorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_xorExpression

	return p
}

func (s *XorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *XorExpressionContext) AllAndExpression() []IAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAndExpressionContext); ok {
			tst[i] = t.(IAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *XorExpressionContext) AndExpression(i int) IAndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *XorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *XorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *XorExpressionContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserXOR)
}

func (s *XorExpressionContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, i)
}

func (s *XorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterXorExpression(s)
	}
}

func (s *XorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitXorExpression(s)
	}
}

func (p *CypherParser) XorExpression() (localctx IXorExpressionContext) {
	this := p
	_ = this

	localctx = NewXorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, CypherParserRULE_xorExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2589)
		p.AndExpression()
	}
	p.SetState(2596)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2590)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(2591)
				p.Match(CypherParserXOR)
			}
			{
				p.SetState(2592)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(2593)
				p.AndExpression()
			}

		}
		p.SetState(2598)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())
	}

	return localctx
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_andExpression
	return p
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) AllNotExpression() []INotExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INotExpressionContext); ok {
			len++
		}
	}

	tst := make([]INotExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INotExpressionContext); ok {
			tst[i] = t.(INotExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExpressionContext) NotExpression(i int) INotExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotExpressionContext)
}

func (s *AndExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AndExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(CypherParserAND)
}

func (s *AndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserAND, i)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (p *CypherParser) AndExpression() (localctx IAndExpressionContext) {
	this := p
	_ = this

	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, CypherParserRULE_andExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2599)
		p.NotExpression()
	}
	p.SetState(2606)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 328, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2600)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(2601)
				p.Match(CypherParserAND)
			}
			{
				p.SetState(2602)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(2603)
				p.NotExpression()
			}

		}
		p.SetState(2608)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 328, p.GetParserRuleContext())
	}

	return localctx
}

// INotExpressionContext is an interface to support dynamic dispatch.
type INotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotExpressionContext differentiates from other interfaces.
	IsNotExpressionContext()
}

type NotExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotExpressionContext() *NotExpressionContext {
	var p = new(NotExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_notExpression
	return p
}

func (*NotExpressionContext) IsNotExpressionContext() {}

func NewNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_notExpression

	return p
}

func (s *NotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NotExpressionContext) ComparisonExpression() IComparisonExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExpressionContext)
}

func (s *NotExpressionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNOT)
}

func (s *NotExpressionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, i)
}

func (s *NotExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NotExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (p *CypherParser) NotExpression() (localctx INotExpressionContext) {
	this := p
	_ = this

	localctx = NewNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, CypherParserRULE_notExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2615)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2609)
				p.Match(CypherParserNOT)
			}
			p.SetState(2611)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2610)
					p.Match(CypherParserSP)
				}

			}

		}
		p.SetState(2617)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())
	}
	{
		p.SetState(2618)
		p.ComparisonExpression()
	}

	return localctx
}

// IComparisonExpressionContext is an interface to support dynamic dispatch.
type IComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonExpressionContext differentiates from other interfaces.
	IsComparisonExpressionContext()
}

type ComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExpressionContext() *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_comparisonExpression
	return p
}

func (*ComparisonExpressionContext) IsComparisonExpressionContext() {}

func NewComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_comparisonExpression

	return p
}

func (s *ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExpressionContext) AddOrSubtractExpression() IAddOrSubtractExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddOrSubtractExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddOrSubtractExpressionContext)
}

func (s *ComparisonExpressionContext) AllPartialComparisonExpression() []IPartialComparisonExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartialComparisonExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPartialComparisonExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartialComparisonExpressionContext); ok {
			tst[i] = t.(IPartialComparisonExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) PartialComparisonExpression(i int) IPartialComparisonExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartialComparisonExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartialComparisonExpressionContext)
}

func (s *ComparisonExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ComparisonExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (p *CypherParser) ComparisonExpression() (localctx IComparisonExpressionContext) {
	this := p
	_ = this

	localctx = NewComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, CypherParserRULE_comparisonExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2620)
		p.AddOrSubtractExpression()
	}
	p.SetState(2627)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2622)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2621)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2624)
				p.PartialComparisonExpression()
			}

		}
		p.SetState(2629)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())
	}

	return localctx
}

// IAddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IAddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddOrSubtractExpressionContext differentiates from other interfaces.
	IsAddOrSubtractExpressionContext()
}

type AddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOrSubtractExpressionContext() *AddOrSubtractExpressionContext {
	var p = new(AddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_addOrSubtractExpression
	return p
}

func (*AddOrSubtractExpressionContext) IsAddOrSubtractExpressionContext() {}

func NewAddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOrSubtractExpressionContext {
	var p = new(AddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_addOrSubtractExpression

	return p
}

func (s *AddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AddOrSubtractExpressionContext) AllMultiplyDivideModuloExpression() []IMultiplyDivideModuloExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplyDivideModuloExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplyDivideModuloExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplyDivideModuloExpressionContext); ok {
			tst[i] = t.(IMultiplyDivideModuloExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AddOrSubtractExpressionContext) MultiplyDivideModuloExpression(i int) IMultiplyDivideModuloExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyDivideModuloExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyDivideModuloExpressionContext)
}

func (s *AddOrSubtractExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AddOrSubtractExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAddOrSubtractExpression(s)
	}
}

func (s *AddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAddOrSubtractExpression(s)
	}
}

func (p *CypherParser) AddOrSubtractExpression() (localctx IAddOrSubtractExpressionContext) {
	this := p
	_ = this

	localctx = NewAddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, CypherParserRULE_addOrSubtractExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2630)
		p.MultiplyDivideModuloExpression()
	}
	p.SetState(2649)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 338, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2647)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 337, p.GetParserRuleContext()) {
			case 1:
				p.SetState(2632)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2631)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2634)
					p.Match(CypherParserT__12)
				}
				p.SetState(2636)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2635)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2638)
					p.MultiplyDivideModuloExpression()
				}

			case 2:
				p.SetState(2640)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2639)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2642)
					p.Match(CypherParserT__2)
				}
				p.SetState(2644)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2643)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2646)
					p.MultiplyDivideModuloExpression()
				}

			}

		}
		p.SetState(2651)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 338, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplyDivideModuloExpressionContext is an interface to support dynamic dispatch.
type IMultiplyDivideModuloExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyDivideModuloExpressionContext differentiates from other interfaces.
	IsMultiplyDivideModuloExpressionContext()
}

type MultiplyDivideModuloExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyDivideModuloExpressionContext() *MultiplyDivideModuloExpressionContext {
	var p = new(MultiplyDivideModuloExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_multiplyDivideModuloExpression
	return p
}

func (*MultiplyDivideModuloExpressionContext) IsMultiplyDivideModuloExpressionContext() {}

func NewMultiplyDivideModuloExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyDivideModuloExpressionContext {
	var p = new(MultiplyDivideModuloExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multiplyDivideModuloExpression

	return p
}

func (s *MultiplyDivideModuloExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyDivideModuloExpressionContext) AllPowerOfExpression() []IPowerOfExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPowerOfExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPowerOfExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPowerOfExpressionContext); ok {
			tst[i] = t.(IPowerOfExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyDivideModuloExpressionContext) PowerOfExpression(i int) IPowerOfExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowerOfExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowerOfExpressionContext)
}

func (s *MultiplyDivideModuloExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MultiplyDivideModuloExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MultiplyDivideModuloExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyDivideModuloExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyDivideModuloExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMultiplyDivideModuloExpression(s)
	}
}

func (s *MultiplyDivideModuloExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMultiplyDivideModuloExpression(s)
	}
}

func (p *CypherParser) MultiplyDivideModuloExpression() (localctx IMultiplyDivideModuloExpressionContext) {
	this := p
	_ = this

	localctx = NewMultiplyDivideModuloExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, CypherParserRULE_multiplyDivideModuloExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2652)
		p.PowerOfExpression()
	}
	p.SetState(2679)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2677)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 345, p.GetParserRuleContext()) {
			case 1:
				p.SetState(2654)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2653)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2656)
					p.Match(CypherParserT__18)
				}
				p.SetState(2658)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2657)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2660)
					p.PowerOfExpression()
				}

			case 2:
				p.SetState(2662)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2661)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2664)
					p.Match(CypherParserT__5)
				}
				p.SetState(2666)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2665)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2668)
					p.PowerOfExpression()
				}

			case 3:
				p.SetState(2670)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2669)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2672)
					p.Match(CypherParserT__24)
				}
				p.SetState(2674)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2673)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2676)
					p.PowerOfExpression()
				}

			}

		}
		p.SetState(2681)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerOfExpressionContext is an interface to support dynamic dispatch.
type IPowerOfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerOfExpressionContext differentiates from other interfaces.
	IsPowerOfExpressionContext()
}

type PowerOfExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerOfExpressionContext() *PowerOfExpressionContext {
	var p = new(PowerOfExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_powerOfExpression
	return p
}

func (*PowerOfExpressionContext) IsPowerOfExpressionContext() {}

func NewPowerOfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerOfExpressionContext {
	var p = new(PowerOfExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_powerOfExpression

	return p
}

func (s *PowerOfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerOfExpressionContext) AllUnaryAddOrSubtractExpression() []IUnaryAddOrSubtractExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryAddOrSubtractExpressionContext); ok {
			len++
		}
	}

	tst := make([]IUnaryAddOrSubtractExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryAddOrSubtractExpressionContext); ok {
			tst[i] = t.(IUnaryAddOrSubtractExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerOfExpressionContext) UnaryAddOrSubtractExpression(i int) IUnaryAddOrSubtractExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryAddOrSubtractExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryAddOrSubtractExpressionContext)
}

func (s *PowerOfExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PowerOfExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PowerOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerOfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerOfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPowerOfExpression(s)
	}
}

func (s *PowerOfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPowerOfExpression(s)
	}
}

func (p *CypherParser) PowerOfExpression() (localctx IPowerOfExpressionContext) {
	this := p
	_ = this

	localctx = NewPowerOfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, CypherParserRULE_powerOfExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2682)
		p.UnaryAddOrSubtractExpression()
	}
	p.SetState(2693)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 349, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2684)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2683)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2686)
				p.Match(CypherParserT__25)
			}
			p.SetState(2688)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2687)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(2690)
				p.UnaryAddOrSubtractExpression()
			}

		}
		p.SetState(2695)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 349, p.GetParserRuleContext())
	}

	return localctx
}

// IUnaryAddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IUnaryAddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryAddOrSubtractExpressionContext differentiates from other interfaces.
	IsUnaryAddOrSubtractExpressionContext()
}

type UnaryAddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryAddOrSubtractExpressionContext() *UnaryAddOrSubtractExpressionContext {
	var p = new(UnaryAddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_unaryAddOrSubtractExpression
	return p
}

func (*UnaryAddOrSubtractExpressionContext) IsUnaryAddOrSubtractExpressionContext() {}

func NewUnaryAddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryAddOrSubtractExpressionContext {
	var p = new(UnaryAddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unaryAddOrSubtractExpression

	return p
}

func (s *UnaryAddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryAddOrSubtractExpressionContext) StringListNullOperatorExpression() IStringListNullOperatorExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListNullOperatorExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListNullOperatorExpressionContext)
}

func (s *UnaryAddOrSubtractExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnaryAddOrSubtractExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnaryAddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryAddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUnaryAddOrSubtractExpression(s)
	}
}

func (s *UnaryAddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUnaryAddOrSubtractExpression(s)
	}
}

func (p *CypherParser) UnaryAddOrSubtractExpression() (localctx IUnaryAddOrSubtractExpressionContext) {
	this := p
	_ = this

	localctx = NewUnaryAddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, CypherParserRULE_unaryAddOrSubtractExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2702)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__2 || _la == CypherParserT__12 {
		{
			p.SetState(2696)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CypherParserT__2 || _la == CypherParserT__12) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2698)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2697)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(2704)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2705)
		p.StringListNullOperatorExpression()
	}

	return localctx
}

// IStringListNullOperatorExpressionContext is an interface to support dynamic dispatch.
type IStringListNullOperatorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringListNullOperatorExpressionContext differentiates from other interfaces.
	IsStringListNullOperatorExpressionContext()
}

type StringListNullOperatorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListNullOperatorExpressionContext() *StringListNullOperatorExpressionContext {
	var p = new(StringListNullOperatorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_stringListNullOperatorExpression
	return p
}

func (*StringListNullOperatorExpressionContext) IsStringListNullOperatorExpressionContext() {}

func NewStringListNullOperatorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListNullOperatorExpressionContext {
	var p = new(StringListNullOperatorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringListNullOperatorExpression

	return p
}

func (s *StringListNullOperatorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListNullOperatorExpressionContext) AllPropertyOrLabelsExpression() []IPropertyOrLabelsExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyOrLabelsExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPropertyOrLabelsExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyOrLabelsExpressionContext); ok {
			tst[i] = t.(IPropertyOrLabelsExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StringListNullOperatorExpressionContext) PropertyOrLabelsExpression(i int) IPropertyOrLabelsExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyOrLabelsExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelsExpressionContext)
}

func (s *StringListNullOperatorExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StringListNullOperatorExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StringListNullOperatorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StringListNullOperatorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StringListNullOperatorExpressionContext) AllIS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserIS)
}

func (s *StringListNullOperatorExpressionContext) IS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserIS, i)
}

func (s *StringListNullOperatorExpressionContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNULL)
}

func (s *StringListNullOperatorExpressionContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, i)
}

func (s *StringListNullOperatorExpressionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNOT)
}

func (s *StringListNullOperatorExpressionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, i)
}

func (s *StringListNullOperatorExpressionContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(CypherParserIN)
}

func (s *StringListNullOperatorExpressionContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserIN, i)
}

func (s *StringListNullOperatorExpressionContext) AllSTARTS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSTARTS)
}

func (s *StringListNullOperatorExpressionContext) STARTS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, i)
}

func (s *StringListNullOperatorExpressionContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(CypherParserWITH)
}

func (s *StringListNullOperatorExpressionContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, i)
}

func (s *StringListNullOperatorExpressionContext) AllENDS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserENDS)
}

func (s *StringListNullOperatorExpressionContext) ENDS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, i)
}

func (s *StringListNullOperatorExpressionContext) AllCONTAINS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCONTAINS)
}

func (s *StringListNullOperatorExpressionContext) CONTAINS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, i)
}

func (s *StringListNullOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListNullOperatorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListNullOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStringListNullOperatorExpression(s)
	}
}

func (s *StringListNullOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStringListNullOperatorExpression(s)
	}
}

func (p *CypherParser) StringListNullOperatorExpression() (localctx IStringListNullOperatorExpressionContext) {
	this := p
	_ = this

	localctx = NewStringListNullOperatorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, CypherParserRULE_stringListNullOperatorExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2707)
		p.PropertyOrLabelsExpression()
	}
	p.SetState(2761)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2759)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext()) {
			case 1:
				p.SetState(2709)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2708)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2711)
					p.Match(CypherParserT__16)
				}
				{
					p.SetState(2712)
					p.Expression()
				}
				{
					p.SetState(2713)
					p.Match(CypherParserT__17)
				}

			case 2:
				p.SetState(2716)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2715)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2718)
					p.Match(CypherParserT__16)
				}
				p.SetState(2720)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__2)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__16)|(1<<CypherParserT__19))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(CypherParserT__33-34))|(1<<(CypherParserCYPHER-34))|(1<<(CypherParserEXPLAIN-34))|(1<<(CypherParserPROFILE-34))|(1<<(CypherParserUSING-34))|(1<<(CypherParserPERIODIC-34))|(1<<(CypherParserCOMMIT-34))|(1<<(CypherParserUNION-34))|(1<<(CypherParserALL-34))|(1<<(CypherParserCREATE-34))|(1<<(CypherParserDROP-34))|(1<<(CypherParserINDEX-34))|(1<<(CypherParserON-34)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(CypherParserCONSTRAINT-66))|(1<<(CypherParserASSERT-66))|(1<<(CypherParserIS-66))|(1<<(CypherParserUNIQUE-66))|(1<<(CypherParserEXISTS-66))|(1<<(CypherParserLOAD-66))|(1<<(CypherParserCSV-66))|(1<<(CypherParserWITH-66))|(1<<(CypherParserHEADERS-66))|(1<<(CypherParserFROM-66))|(1<<(CypherParserAS-66))|(1<<(CypherParserFIELDTERMINATOR-66))|(1<<(CypherParserOPTIONAL-66))|(1<<(CypherParserMATCH-66))|(1<<(CypherParserUNWIND-66))|(1<<(CypherParserMERGE-66))|(1<<(CypherParserSET-66))|(1<<(CypherParserDETACH-66))|(1<<(CypherParserDELETE-66))|(1<<(CypherParserREMOVE-66))|(1<<(CypherParserFOREACH-66))|(1<<(CypherParserIN-66))|(1<<(CypherParserDISTINCT-66))|(1<<(CypherParserRETURN-66))|(1<<(CypherParserORDER-66))|(1<<(CypherParserBY-66))|(1<<(CypherParserL_SKIP-66))|(1<<(CypherParserLIMIT-66))|(1<<(CypherParserASCENDING-66))|(1<<(CypherParserASC-66))|(1<<(CypherParserDESCENDING-66))|(1<<(CypherParserDESC-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(CypherParserJOIN-98))|(1<<(CypherParserSCAN-98))|(1<<(CypherParserSTART-98))|(1<<(CypherParserNODE-98))|(1<<(CypherParserRELATIONSHIP-98))|(1<<(CypherParserREL-98))|(1<<(CypherParserWHERE-98))|(1<<(CypherParserSHORTESTPATH-98))|(1<<(CypherParserALLSHORTESTPATHS-98))|(1<<(CypherParserOR-98))|(1<<(CypherParserXOR-98))|(1<<(CypherParserAND-98))|(1<<(CypherParserNOT-98))|(1<<(CypherParserSTARTS-98))|(1<<(CypherParserENDS-98))|(1<<(CypherParserCONTAINS-98))|(1<<(CypherParserNULL-98))|(1<<(CypherParserCOUNT-98))|(1<<(CypherParserFILTER-98))|(1<<(CypherParserEXTRACT-98))|(1<<(CypherParserANY-98))|(1<<(CypherParserNONE-98))|(1<<(CypherParserSINGLE-98))|(1<<(CypherParserTRUE-98))|(1<<(CypherParserFALSE-98))|(1<<(CypherParserREDUCE-98))|(1<<(CypherParserCASE-98))|(1<<(CypherParserELSE-98))|(1<<(CypherParserEND-98))|(1<<(CypherParserWHEN-98))|(1<<(CypherParserTHEN-98))|(1<<(CypherParserCALL-98)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(CypherParserYIELD-130))|(1<<(CypherParserKEY-130))|(1<<(CypherParserCATALOG-130))|(1<<(CypherParserSHOW-130))|(1<<(CypherParserDEFAULT-130))|(1<<(CypherParserDBMS-130))|(1<<(CypherParserDATABASE-130))|(1<<(CypherParserDATABASES-130))|(1<<(CypherParserGRAPH-130))|(1<<(CypherParserGRAPHS-130))|(1<<(CypherParserREPLACE-130))|(1<<(CypherParserIF-130))|(1<<(CypherParserSTOP-130))|(1<<(CypherParserROLE-130))|(1<<(CypherParserROLES-130))|(1<<(CypherParserUSER-130))|(1<<(CypherParserUSERS-130))|(1<<(CypherParserPOPULATED-130))|(1<<(CypherParserPASSWORD-130))|(1<<(CypherParserCHANGE-130))|(1<<(CypherParserREQUIRED-130))|(1<<(CypherParserSTATUS-130))|(1<<(CypherParserACTIVE-130))|(1<<(CypherParserSUSPENDED-130))|(1<<(CypherParserALTER-130))|(1<<(CypherParserCURRENT-130))|(1<<(CypherParserTO-130))|(1<<(CypherParserPRIVILEGES-130))|(1<<(CypherParserGRANT-130))|(1<<(CypherParserDENY-130))|(1<<(CypherParserREVOKE-130))|(1<<(CypherParserRELATIONSHIPS-130)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(CypherParserNODES-162))|(1<<(CypherParserELEMENT-162))|(1<<(CypherParserELEMENTS-162))|(1<<(CypherParserCOPY-162))|(1<<(CypherParserOF-162))|(1<<(CypherParserTRAVERSE-162))|(1<<(CypherParserREAD-162))|(1<<(CypherParserWRITE-162))|(1<<(CypherParserACCESS-162))|(1<<(CypherParserINDEXES-162))|(1<<(CypherParserMANAGEMENT-162))|(1<<(CypherParserNEW-162))|(1<<(CypherParserLABEL-162))|(1<<(CypherParserLABELS-162))|(1<<(CypherParserNAME-162))|(1<<(CypherParserNAMES-162))|(1<<(CypherParserTYPE-162))|(1<<(CypherParserTYPES-162))|(1<<(CypherParserPROPERTY-162))|(1<<(CypherParserCONSTRAINTS-162))|(1<<(CypherParserASSIGN-162))|(1<<(CypherParserBTREE-162))|(1<<(CypherParserEXIST-162))|(1<<(CypherParserFOR-162))|(1<<(CypherParserOPTIONS-162))|(1<<(CypherParserEXECUTE-162))|(1<<(CypherParserDEFINED-162))|(1<<(CypherParserFUNCTION-162))|(1<<(CypherParserFUNCTIONS-162))|(1<<(CypherParserBOOSTED-162))|(1<<(CypherParserPROCEDURE-162))|(1<<(CypherParserPROCEDURES-162)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(CypherParserADMIN-194))|(1<<(CypherParserADMINISTRATOR-194))|(1<<(CypherParserBRIEF-194))|(1<<(CypherParserVERBOSE-194))|(1<<(CypherParserOUTPUT-194))|(1<<(CypherParserBUILT-194))|(1<<(CypherParserEACH-194))|(1<<(CypherParserEXECUTABLE-194))|(1<<(CypherParserEXISTENCE-194))|(1<<(CypherParserFULLTEXT-194))|(1<<(CypherParserHOME-194))|(1<<(CypherParserLOOKUP-194))|(1<<(CypherParserStringLiteral-194))|(1<<(CypherParserHexInteger-194))|(1<<(CypherParserDecimalInteger-194))|(1<<(CypherParserOctalInteger-194))|(1<<(CypherParserHexLetter-194))|(1<<(CypherParserExponentDecimalReal-194))|(1<<(CypherParserRegularDecimalReal-194))|(1<<(CypherParserUnescapedSymbolicName-194))|(1<<(CypherParserEscapedSymbolicName-194)))) != 0) {
					{
						p.SetState(2719)
						p.Expression()
					}

				}
				{
					p.SetState(2722)
					p.Match(CypherParserT__23)
				}
				p.SetState(2724)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__2)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__16)|(1<<CypherParserT__19))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(CypherParserT__33-34))|(1<<(CypherParserCYPHER-34))|(1<<(CypherParserEXPLAIN-34))|(1<<(CypherParserPROFILE-34))|(1<<(CypherParserUSING-34))|(1<<(CypherParserPERIODIC-34))|(1<<(CypherParserCOMMIT-34))|(1<<(CypherParserUNION-34))|(1<<(CypherParserALL-34))|(1<<(CypherParserCREATE-34))|(1<<(CypherParserDROP-34))|(1<<(CypherParserINDEX-34))|(1<<(CypherParserON-34)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(CypherParserCONSTRAINT-66))|(1<<(CypherParserASSERT-66))|(1<<(CypherParserIS-66))|(1<<(CypherParserUNIQUE-66))|(1<<(CypherParserEXISTS-66))|(1<<(CypherParserLOAD-66))|(1<<(CypherParserCSV-66))|(1<<(CypherParserWITH-66))|(1<<(CypherParserHEADERS-66))|(1<<(CypherParserFROM-66))|(1<<(CypherParserAS-66))|(1<<(CypherParserFIELDTERMINATOR-66))|(1<<(CypherParserOPTIONAL-66))|(1<<(CypherParserMATCH-66))|(1<<(CypherParserUNWIND-66))|(1<<(CypherParserMERGE-66))|(1<<(CypherParserSET-66))|(1<<(CypherParserDETACH-66))|(1<<(CypherParserDELETE-66))|(1<<(CypherParserREMOVE-66))|(1<<(CypherParserFOREACH-66))|(1<<(CypherParserIN-66))|(1<<(CypherParserDISTINCT-66))|(1<<(CypherParserRETURN-66))|(1<<(CypherParserORDER-66))|(1<<(CypherParserBY-66))|(1<<(CypherParserL_SKIP-66))|(1<<(CypherParserLIMIT-66))|(1<<(CypherParserASCENDING-66))|(1<<(CypherParserASC-66))|(1<<(CypherParserDESCENDING-66))|(1<<(CypherParserDESC-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(CypherParserJOIN-98))|(1<<(CypherParserSCAN-98))|(1<<(CypherParserSTART-98))|(1<<(CypherParserNODE-98))|(1<<(CypherParserRELATIONSHIP-98))|(1<<(CypherParserREL-98))|(1<<(CypherParserWHERE-98))|(1<<(CypherParserSHORTESTPATH-98))|(1<<(CypherParserALLSHORTESTPATHS-98))|(1<<(CypherParserOR-98))|(1<<(CypherParserXOR-98))|(1<<(CypherParserAND-98))|(1<<(CypherParserNOT-98))|(1<<(CypherParserSTARTS-98))|(1<<(CypherParserENDS-98))|(1<<(CypherParserCONTAINS-98))|(1<<(CypherParserNULL-98))|(1<<(CypherParserCOUNT-98))|(1<<(CypherParserFILTER-98))|(1<<(CypherParserEXTRACT-98))|(1<<(CypherParserANY-98))|(1<<(CypherParserNONE-98))|(1<<(CypherParserSINGLE-98))|(1<<(CypherParserTRUE-98))|(1<<(CypherParserFALSE-98))|(1<<(CypherParserREDUCE-98))|(1<<(CypherParserCASE-98))|(1<<(CypherParserELSE-98))|(1<<(CypherParserEND-98))|(1<<(CypherParserWHEN-98))|(1<<(CypherParserTHEN-98))|(1<<(CypherParserCALL-98)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(CypherParserYIELD-130))|(1<<(CypherParserKEY-130))|(1<<(CypherParserCATALOG-130))|(1<<(CypherParserSHOW-130))|(1<<(CypherParserDEFAULT-130))|(1<<(CypherParserDBMS-130))|(1<<(CypherParserDATABASE-130))|(1<<(CypherParserDATABASES-130))|(1<<(CypherParserGRAPH-130))|(1<<(CypherParserGRAPHS-130))|(1<<(CypherParserREPLACE-130))|(1<<(CypherParserIF-130))|(1<<(CypherParserSTOP-130))|(1<<(CypherParserROLE-130))|(1<<(CypherParserROLES-130))|(1<<(CypherParserUSER-130))|(1<<(CypherParserUSERS-130))|(1<<(CypherParserPOPULATED-130))|(1<<(CypherParserPASSWORD-130))|(1<<(CypherParserCHANGE-130))|(1<<(CypherParserREQUIRED-130))|(1<<(CypherParserSTATUS-130))|(1<<(CypherParserACTIVE-130))|(1<<(CypherParserSUSPENDED-130))|(1<<(CypherParserALTER-130))|(1<<(CypherParserCURRENT-130))|(1<<(CypherParserTO-130))|(1<<(CypherParserPRIVILEGES-130))|(1<<(CypherParserGRANT-130))|(1<<(CypherParserDENY-130))|(1<<(CypherParserREVOKE-130))|(1<<(CypherParserRELATIONSHIPS-130)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(CypherParserNODES-162))|(1<<(CypherParserELEMENT-162))|(1<<(CypherParserELEMENTS-162))|(1<<(CypherParserCOPY-162))|(1<<(CypherParserOF-162))|(1<<(CypherParserTRAVERSE-162))|(1<<(CypherParserREAD-162))|(1<<(CypherParserWRITE-162))|(1<<(CypherParserACCESS-162))|(1<<(CypherParserINDEXES-162))|(1<<(CypherParserMANAGEMENT-162))|(1<<(CypherParserNEW-162))|(1<<(CypherParserLABEL-162))|(1<<(CypherParserLABELS-162))|(1<<(CypherParserNAME-162))|(1<<(CypherParserNAMES-162))|(1<<(CypherParserTYPE-162))|(1<<(CypherParserTYPES-162))|(1<<(CypherParserPROPERTY-162))|(1<<(CypherParserCONSTRAINTS-162))|(1<<(CypherParserASSIGN-162))|(1<<(CypherParserBTREE-162))|(1<<(CypherParserEXIST-162))|(1<<(CypherParserFOR-162))|(1<<(CypherParserOPTIONS-162))|(1<<(CypherParserEXECUTE-162))|(1<<(CypherParserDEFINED-162))|(1<<(CypherParserFUNCTION-162))|(1<<(CypherParserFUNCTIONS-162))|(1<<(CypherParserBOOSTED-162))|(1<<(CypherParserPROCEDURE-162))|(1<<(CypherParserPROCEDURES-162)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(CypherParserADMIN-194))|(1<<(CypherParserADMINISTRATOR-194))|(1<<(CypherParserBRIEF-194))|(1<<(CypherParserVERBOSE-194))|(1<<(CypherParserOUTPUT-194))|(1<<(CypherParserBUILT-194))|(1<<(CypherParserEACH-194))|(1<<(CypherParserEXECUTABLE-194))|(1<<(CypherParserEXISTENCE-194))|(1<<(CypherParserFULLTEXT-194))|(1<<(CypherParserHOME-194))|(1<<(CypherParserLOOKUP-194))|(1<<(CypherParserStringLiteral-194))|(1<<(CypherParserHexInteger-194))|(1<<(CypherParserDecimalInteger-194))|(1<<(CypherParserOctalInteger-194))|(1<<(CypherParserHexLetter-194))|(1<<(CypherParserExponentDecimalReal-194))|(1<<(CypherParserRegularDecimalReal-194))|(1<<(CypherParserUnescapedSymbolicName-194))|(1<<(CypherParserEscapedSymbolicName-194)))) != 0) {
					{
						p.SetState(2723)
						p.Expression()
					}

				}
				{
					p.SetState(2726)
					p.Match(CypherParserT__17)
				}

			case 3:
				p.SetState(2743)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 357, p.GetParserRuleContext()) {
				case 1:
					p.SetState(2728)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == CypherParserSP {
						{
							p.SetState(2727)
							p.Match(CypherParserSP)
						}

					}
					{
						p.SetState(2730)
						p.Match(CypherParserT__26)
					}

				case 2:
					{
						p.SetState(2731)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(2732)
						p.Match(CypherParserIN)
					}

				case 3:
					{
						p.SetState(2733)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(2734)
						p.Match(CypherParserSTARTS)
					}
					{
						p.SetState(2735)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(2736)
						p.Match(CypherParserWITH)
					}

				case 4:
					{
						p.SetState(2737)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(2738)
						p.Match(CypherParserENDS)
					}
					{
						p.SetState(2739)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(2740)
						p.Match(CypherParserWITH)
					}

				case 5:
					{
						p.SetState(2741)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(2742)
						p.Match(CypherParserCONTAINS)
					}

				}
				p.SetState(2746)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(2745)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(2748)
					p.PropertyOrLabelsExpression()
				}

			case 4:
				{
					p.SetState(2749)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(2750)
					p.Match(CypherParserIS)
				}
				{
					p.SetState(2751)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(2752)
					p.Match(CypherParserNULL)
				}

			case 5:
				{
					p.SetState(2753)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(2754)
					p.Match(CypherParserIS)
				}
				{
					p.SetState(2755)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(2756)
					p.Match(CypherParserNOT)
				}
				{
					p.SetState(2757)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(2758)
					p.Match(CypherParserNULL)
				}

			}

		}
		p.SetState(2763)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext())
	}

	return localctx
}

// IPropertyOrLabelsExpressionContext is an interface to support dynamic dispatch.
type IPropertyOrLabelsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyOrLabelsExpressionContext differentiates from other interfaces.
	IsPropertyOrLabelsExpressionContext()
}

type PropertyOrLabelsExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyOrLabelsExpressionContext() *PropertyOrLabelsExpressionContext {
	var p = new(PropertyOrLabelsExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyOrLabelsExpression
	return p
}

func (*PropertyOrLabelsExpressionContext) IsPropertyOrLabelsExpressionContext() {}

func NewPropertyOrLabelsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyOrLabelsExpressionContext {
	var p = new(PropertyOrLabelsExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyOrLabelsExpression

	return p
}

func (s *PropertyOrLabelsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyOrLabelsExpressionContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PropertyOrLabelsExpressionContext) AllPropertyLookup() []IPropertyLookupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyLookupContext); ok {
			len++
		}
	}

	tst := make([]IPropertyLookupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyLookupContext); ok {
			tst[i] = t.(IPropertyLookupContext)
			i++
		}
	}

	return tst
}

func (s *PropertyOrLabelsExpressionContext) PropertyLookup(i int) IPropertyLookupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyLookupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyLookupContext)
}

func (s *PropertyOrLabelsExpressionContext) AllNodeLabels() []INodeLabelsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INodeLabelsContext); ok {
			len++
		}
	}

	tst := make([]INodeLabelsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INodeLabelsContext); ok {
			tst[i] = t.(INodeLabelsContext)
			i++
		}
	}

	return tst
}

func (s *PropertyOrLabelsExpressionContext) NodeLabels(i int) INodeLabelsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeLabelsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *PropertyOrLabelsExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyOrLabelsExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyOrLabelsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyOrLabelsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyOrLabelsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyOrLabelsExpression(s)
	}
}

func (s *PropertyOrLabelsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyOrLabelsExpression(s)
	}
}

func (p *CypherParser) PropertyOrLabelsExpression() (localctx IPropertyOrLabelsExpressionContext) {
	this := p
	_ = this

	localctx = NewPropertyOrLabelsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, CypherParserRULE_propertyOrLabelsExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2764)
		p.Atom()
	}
	p.SetState(2774)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 363, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2766)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(2765)
					p.Match(CypherParserSP)
				}

			}
			p.SetState(2770)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case CypherParserT__6:
				{
					p.SetState(2768)
					p.PropertyLookup()
				}

			case CypherParserT__1:
				{
					p.SetState(2769)
					p.NodeLabels()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(2776)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 363, p.GetParserRuleContext())
	}

	return localctx
}

// IFilterFunctionContext is an interface to support dynamic dispatch.
type IFilterFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterFunctionContext differentiates from other interfaces.
	IsFilterFunctionContext()
}

type FilterFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterFunctionContext() *FilterFunctionContext {
	var p = new(FilterFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_filterFunction
	return p
}

func (*FilterFunctionContext) IsFilterFunctionContext() {}

func NewFilterFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterFunctionContext {
	var p = new(FilterFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_filterFunction

	return p
}

func (s *FilterFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterFunctionContext) FilterFunctionName() IFilterFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterFunctionNameContext)
}

func (s *FilterFunctionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *FilterFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *FilterFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *FilterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFilterFunction(s)
	}
}

func (s *FilterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFilterFunction(s)
	}
}

func (p *CypherParser) FilterFunction() (localctx IFilterFunctionContext) {
	this := p
	_ = this

	localctx = NewFilterFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, CypherParserRULE_filterFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2777)
		p.FilterFunctionName()
	}
	p.SetState(2779)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2778)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2781)
		p.Match(CypherParserT__19)
	}
	p.SetState(2783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2782)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2785)
		p.FilterExpression()
	}
	p.SetState(2787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2786)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2789)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IFilterFunctionNameContext is an interface to support dynamic dispatch.
type IFilterFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterFunctionNameContext differentiates from other interfaces.
	IsFilterFunctionNameContext()
}

type FilterFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterFunctionNameContext() *FilterFunctionNameContext {
	var p = new(FilterFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_filterFunctionName
	return p
}

func (*FilterFunctionNameContext) IsFilterFunctionNameContext() {}

func NewFilterFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterFunctionNameContext {
	var p = new(FilterFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_filterFunctionName

	return p
}

func (s *FilterFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterFunctionNameContext) FILTER() antlr.TerminalNode {
	return s.GetToken(CypherParserFILTER, 0)
}

func (s *FilterFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFilterFunctionName(s)
	}
}

func (s *FilterFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFilterFunctionName(s)
	}
}

func (p *CypherParser) FilterFunctionName() (localctx IFilterFunctionNameContext) {
	this := p
	_ = this

	localctx = NewFilterFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, CypherParserRULE_filterFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2791)
		p.Match(CypherParserFILTER)
	}

	return localctx
}

// IExistsFunctionContext is an interface to support dynamic dispatch.
type IExistsFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExistsFunctionContext differentiates from other interfaces.
	IsExistsFunctionContext()
}

type ExistsFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExistsFunctionContext() *ExistsFunctionContext {
	var p = new(ExistsFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_existsFunction
	return p
}

func (*ExistsFunctionContext) IsExistsFunctionContext() {}

func NewExistsFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExistsFunctionContext {
	var p = new(ExistsFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_existsFunction

	return p
}

func (s *ExistsFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExistsFunctionContext) ExistsFunctionName() IExistsFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExistsFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExistsFunctionNameContext)
}

func (s *ExistsFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExistsFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ExistsFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ExistsFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExistsFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExistsFunction(s)
	}
}

func (s *ExistsFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExistsFunction(s)
	}
}

func (p *CypherParser) ExistsFunction() (localctx IExistsFunctionContext) {
	this := p
	_ = this

	localctx = NewExistsFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, CypherParserRULE_existsFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2793)
		p.ExistsFunctionName()
	}
	p.SetState(2795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2794)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2797)
		p.Match(CypherParserT__19)
	}
	p.SetState(2799)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2798)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2801)
		p.Expression()
	}
	p.SetState(2803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2802)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2805)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IExistsFunctionNameContext is an interface to support dynamic dispatch.
type IExistsFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExistsFunctionNameContext differentiates from other interfaces.
	IsExistsFunctionNameContext()
}

type ExistsFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExistsFunctionNameContext() *ExistsFunctionNameContext {
	var p = new(ExistsFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_existsFunctionName
	return p
}

func (*ExistsFunctionNameContext) IsExistsFunctionNameContext() {}

func NewExistsFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExistsFunctionNameContext {
	var p = new(ExistsFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_existsFunctionName

	return p
}

func (s *ExistsFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExistsFunctionNameContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *ExistsFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExistsFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExistsFunctionName(s)
	}
}

func (s *ExistsFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExistsFunctionName(s)
	}
}

func (p *CypherParser) ExistsFunctionName() (localctx IExistsFunctionNameContext) {
	this := p
	_ = this

	localctx = NewExistsFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, CypherParserRULE_existsFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2807)
		p.Match(CypherParserEXISTS)
	}

	return localctx
}

// IAllFunctionContext is an interface to support dynamic dispatch.
type IAllFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAllFunctionContext differentiates from other interfaces.
	IsAllFunctionContext()
}

type AllFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllFunctionContext() *AllFunctionContext {
	var p = new(AllFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_allFunction
	return p
}

func (*AllFunctionContext) IsAllFunctionContext() {}

func NewAllFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllFunctionContext {
	var p = new(AllFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_allFunction

	return p
}

func (s *AllFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AllFunctionContext) AllFunctionName() IAllFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllFunctionNameContext)
}

func (s *AllFunctionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *AllFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AllFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AllFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAllFunction(s)
	}
}

func (s *AllFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAllFunction(s)
	}
}

func (p *CypherParser) AllFunction() (localctx IAllFunctionContext) {
	this := p
	_ = this

	localctx = NewAllFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, CypherParserRULE_allFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2809)
		p.AllFunctionName()
	}
	p.SetState(2811)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2810)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2813)
		p.Match(CypherParserT__19)
	}
	p.SetState(2815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2814)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2817)
		p.FilterExpression()
	}
	p.SetState(2819)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2818)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2821)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IAllFunctionNameContext is an interface to support dynamic dispatch.
type IAllFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAllFunctionNameContext differentiates from other interfaces.
	IsAllFunctionNameContext()
}

type AllFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllFunctionNameContext() *AllFunctionNameContext {
	var p = new(AllFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_allFunctionName
	return p
}

func (*AllFunctionNameContext) IsAllFunctionNameContext() {}

func NewAllFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllFunctionNameContext {
	var p = new(AllFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_allFunctionName

	return p
}

func (s *AllFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AllFunctionNameContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *AllFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAllFunctionName(s)
	}
}

func (s *AllFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAllFunctionName(s)
	}
}

func (p *CypherParser) AllFunctionName() (localctx IAllFunctionNameContext) {
	this := p
	_ = this

	localctx = NewAllFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, CypherParserRULE_allFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2823)
		p.Match(CypherParserALL)
	}

	return localctx
}

// IAnyFunctionContext is an interface to support dynamic dispatch.
type IAnyFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnyFunctionContext differentiates from other interfaces.
	IsAnyFunctionContext()
}

type AnyFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyFunctionContext() *AnyFunctionContext {
	var p = new(AnyFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_anyFunction
	return p
}

func (*AnyFunctionContext) IsAnyFunctionContext() {}

func NewAnyFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyFunctionContext {
	var p = new(AnyFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_anyFunction

	return p
}

func (s *AnyFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyFunctionContext) AnyFunctionName() IAnyFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyFunctionNameContext)
}

func (s *AnyFunctionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *AnyFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AnyFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AnyFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAnyFunction(s)
	}
}

func (s *AnyFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAnyFunction(s)
	}
}

func (p *CypherParser) AnyFunction() (localctx IAnyFunctionContext) {
	this := p
	_ = this

	localctx = NewAnyFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, CypherParserRULE_anyFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2825)
		p.AnyFunctionName()
	}
	p.SetState(2827)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2826)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2829)
		p.Match(CypherParserT__19)
	}
	p.SetState(2831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2830)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2833)
		p.FilterExpression()
	}
	p.SetState(2835)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2834)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2837)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IAnyFunctionNameContext is an interface to support dynamic dispatch.
type IAnyFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnyFunctionNameContext differentiates from other interfaces.
	IsAnyFunctionNameContext()
}

type AnyFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyFunctionNameContext() *AnyFunctionNameContext {
	var p = new(AnyFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_anyFunctionName
	return p
}

func (*AnyFunctionNameContext) IsAnyFunctionNameContext() {}

func NewAnyFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyFunctionNameContext {
	var p = new(AnyFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_anyFunctionName

	return p
}

func (s *AnyFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyFunctionNameContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *AnyFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAnyFunctionName(s)
	}
}

func (s *AnyFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAnyFunctionName(s)
	}
}

func (p *CypherParser) AnyFunctionName() (localctx IAnyFunctionNameContext) {
	this := p
	_ = this

	localctx = NewAnyFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, CypherParserRULE_anyFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2839)
		p.Match(CypherParserANY)
	}

	return localctx
}

// INoneFunctionContext is an interface to support dynamic dispatch.
type INoneFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNoneFunctionContext differentiates from other interfaces.
	IsNoneFunctionContext()
}

type NoneFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoneFunctionContext() *NoneFunctionContext {
	var p = new(NoneFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_noneFunction
	return p
}

func (*NoneFunctionContext) IsNoneFunctionContext() {}

func NewNoneFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoneFunctionContext {
	var p = new(NoneFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_noneFunction

	return p
}

func (s *NoneFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *NoneFunctionContext) NoneFunctionName() INoneFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoneFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoneFunctionNameContext)
}

func (s *NoneFunctionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *NoneFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NoneFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NoneFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoneFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoneFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNoneFunction(s)
	}
}

func (s *NoneFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNoneFunction(s)
	}
}

func (p *CypherParser) NoneFunction() (localctx INoneFunctionContext) {
	this := p
	_ = this

	localctx = NewNoneFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, CypherParserRULE_noneFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2841)
		p.NoneFunctionName()
	}
	p.SetState(2843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2842)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2845)
		p.Match(CypherParserT__19)
	}
	p.SetState(2847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2846)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2849)
		p.FilterExpression()
	}
	p.SetState(2851)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2850)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2853)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// INoneFunctionNameContext is an interface to support dynamic dispatch.
type INoneFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNoneFunctionNameContext differentiates from other interfaces.
	IsNoneFunctionNameContext()
}

type NoneFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoneFunctionNameContext() *NoneFunctionNameContext {
	var p = new(NoneFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_noneFunctionName
	return p
}

func (*NoneFunctionNameContext) IsNoneFunctionNameContext() {}

func NewNoneFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoneFunctionNameContext {
	var p = new(NoneFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_noneFunctionName

	return p
}

func (s *NoneFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NoneFunctionNameContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *NoneFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoneFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoneFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNoneFunctionName(s)
	}
}

func (s *NoneFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNoneFunctionName(s)
	}
}

func (p *CypherParser) NoneFunctionName() (localctx INoneFunctionNameContext) {
	this := p
	_ = this

	localctx = NewNoneFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, CypherParserRULE_noneFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2855)
		p.Match(CypherParserNONE)
	}

	return localctx
}

// ISingleFunctionContext is an interface to support dynamic dispatch.
type ISingleFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleFunctionContext differentiates from other interfaces.
	IsSingleFunctionContext()
}

type SingleFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleFunctionContext() *SingleFunctionContext {
	var p = new(SingleFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_singleFunction
	return p
}

func (*SingleFunctionContext) IsSingleFunctionContext() {}

func NewSingleFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleFunctionContext {
	var p = new(SingleFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singleFunction

	return p
}

func (s *SingleFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleFunctionContext) SingleFunctionName() ISingleFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleFunctionNameContext)
}

func (s *SingleFunctionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *SingleFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SingleFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SingleFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSingleFunction(s)
	}
}

func (s *SingleFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSingleFunction(s)
	}
}

func (p *CypherParser) SingleFunction() (localctx ISingleFunctionContext) {
	this := p
	_ = this

	localctx = NewSingleFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, CypherParserRULE_singleFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2857)
		p.SingleFunctionName()
	}
	p.SetState(2859)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2858)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2861)
		p.Match(CypherParserT__19)
	}
	p.SetState(2863)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2862)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2865)
		p.FilterExpression()
	}
	p.SetState(2867)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2866)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2869)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// ISingleFunctionNameContext is an interface to support dynamic dispatch.
type ISingleFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleFunctionNameContext differentiates from other interfaces.
	IsSingleFunctionNameContext()
}

type SingleFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleFunctionNameContext() *SingleFunctionNameContext {
	var p = new(SingleFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_singleFunctionName
	return p
}

func (*SingleFunctionNameContext) IsSingleFunctionNameContext() {}

func NewSingleFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleFunctionNameContext {
	var p = new(SingleFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singleFunctionName

	return p
}

func (s *SingleFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleFunctionNameContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *SingleFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSingleFunctionName(s)
	}
}

func (s *SingleFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSingleFunctionName(s)
	}
}

func (p *CypherParser) SingleFunctionName() (localctx ISingleFunctionNameContext) {
	this := p
	_ = this

	localctx = NewSingleFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, CypherParserRULE_singleFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2871)
		p.Match(CypherParserSINGLE)
	}

	return localctx
}

// IExtractFunctionContext is an interface to support dynamic dispatch.
type IExtractFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtractFunctionContext differentiates from other interfaces.
	IsExtractFunctionContext()
}

type ExtractFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtractFunctionContext() *ExtractFunctionContext {
	var p = new(ExtractFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_extractFunction
	return p
}

func (*ExtractFunctionContext) IsExtractFunctionContext() {}

func NewExtractFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtractFunctionContext {
	var p = new(ExtractFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_extractFunction

	return p
}

func (s *ExtractFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtractFunctionContext) ExtractFunctionName() IExtractFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtractFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtractFunctionNameContext)
}

func (s *ExtractFunctionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *ExtractFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ExtractFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ExtractFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtractFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtractFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExtractFunction(s)
	}
}

func (s *ExtractFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExtractFunction(s)
	}
}

func (p *CypherParser) ExtractFunction() (localctx IExtractFunctionContext) {
	this := p
	_ = this

	localctx = NewExtractFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, CypherParserRULE_extractFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2873)
		p.ExtractFunctionName()
	}
	p.SetState(2875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2874)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2877)
		p.Match(CypherParserT__19)
	}
	p.SetState(2879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2878)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2881)
		p.FilterExpression()
	}
	p.SetState(2890)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 386, p.GetParserRuleContext()) == 1 {
		p.SetState(2883)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2882)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2885)
			p.Match(CypherParserT__22)
		}
		p.SetState(2887)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2886)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2889)
			p.Expression()
		}

	}
	p.SetState(2893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2892)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2895)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IExtractFunctionNameContext is an interface to support dynamic dispatch.
type IExtractFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtractFunctionNameContext differentiates from other interfaces.
	IsExtractFunctionNameContext()
}

type ExtractFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtractFunctionNameContext() *ExtractFunctionNameContext {
	var p = new(ExtractFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_extractFunctionName
	return p
}

func (*ExtractFunctionNameContext) IsExtractFunctionNameContext() {}

func NewExtractFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtractFunctionNameContext {
	var p = new(ExtractFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_extractFunctionName

	return p
}

func (s *ExtractFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtractFunctionNameContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(CypherParserEXTRACT, 0)
}

func (s *ExtractFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtractFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExtractFunctionName(s)
	}
}

func (s *ExtractFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExtractFunctionName(s)
	}
}

func (p *CypherParser) ExtractFunctionName() (localctx IExtractFunctionNameContext) {
	this := p
	_ = this

	localctx = NewExtractFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, CypherParserRULE_extractFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2897)
		p.Match(CypherParserEXTRACT)
	}

	return localctx
}

// IReduceFunctionContext is an interface to support dynamic dispatch.
type IReduceFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReduceFunctionContext differentiates from other interfaces.
	IsReduceFunctionContext()
}

type ReduceFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReduceFunctionContext() *ReduceFunctionContext {
	var p = new(ReduceFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_reduceFunction
	return p
}

func (*ReduceFunctionContext) IsReduceFunctionContext() {}

func NewReduceFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReduceFunctionContext {
	var p = new(ReduceFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_reduceFunction

	return p
}

func (s *ReduceFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReduceFunctionContext) ReduceFunctionName() IReduceFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReduceFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReduceFunctionNameContext)
}

func (s *ReduceFunctionContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ReduceFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ReduceFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReduceFunctionContext) IdInColl() IIdInCollContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdInCollContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdInCollContext)
}

func (s *ReduceFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReduceFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReduceFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReduceFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReduceFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReduceFunction(s)
	}
}

func (s *ReduceFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReduceFunction(s)
	}
}

func (p *CypherParser) ReduceFunction() (localctx IReduceFunctionContext) {
	this := p
	_ = this

	localctx = NewReduceFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, CypherParserRULE_reduceFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2899)
		p.ReduceFunctionName()
	}
	p.SetState(2901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2900)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2903)
		p.Match(CypherParserT__19)
	}
	p.SetState(2905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2904)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2907)
		p.Variable()
	}
	p.SetState(2909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2908)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2911)
		p.Match(CypherParserT__11)
	}
	p.SetState(2913)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2912)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2915)
		p.Expression()
	}
	p.SetState(2917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2916)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2919)
		p.Match(CypherParserT__14)
	}
	p.SetState(2921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2920)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2923)
		p.IdInColl()
	}
	p.SetState(2925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2924)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2927)
		p.Match(CypherParserT__22)
	}
	p.SetState(2929)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2928)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2931)
		p.Expression()
	}
	p.SetState(2933)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(2932)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(2935)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IReduceFunctionNameContext is an interface to support dynamic dispatch.
type IReduceFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReduceFunctionNameContext differentiates from other interfaces.
	IsReduceFunctionNameContext()
}

type ReduceFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReduceFunctionNameContext() *ReduceFunctionNameContext {
	var p = new(ReduceFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_reduceFunctionName
	return p
}

func (*ReduceFunctionNameContext) IsReduceFunctionNameContext() {}

func NewReduceFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReduceFunctionNameContext {
	var p = new(ReduceFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_reduceFunctionName

	return p
}

func (s *ReduceFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ReduceFunctionNameContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(CypherParserREDUCE, 0)
}

func (s *ReduceFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReduceFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReduceFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReduceFunctionName(s)
	}
}

func (s *ReduceFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReduceFunctionName(s)
	}
}

func (p *CypherParser) ReduceFunctionName() (localctx IReduceFunctionNameContext) {
	this := p
	_ = this

	localctx = NewReduceFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, CypherParserRULE_reduceFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2937)
		p.Match(CypherParserREDUCE)
	}

	return localctx
}

// IShortestPathPatternFunctionContext is an interface to support dynamic dispatch.
type IShortestPathPatternFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShortestPathPatternFunctionContext differentiates from other interfaces.
	IsShortestPathPatternFunctionContext()
}

type ShortestPathPatternFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortestPathPatternFunctionContext() *ShortestPathPatternFunctionContext {
	var p = new(ShortestPathPatternFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_shortestPathPatternFunction
	return p
}

func (*ShortestPathPatternFunctionContext) IsShortestPathPatternFunctionContext() {}

func NewShortestPathPatternFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortestPathPatternFunctionContext {
	var p = new(ShortestPathPatternFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_shortestPathPatternFunction

	return p
}

func (s *ShortestPathPatternFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortestPathPatternFunctionContext) ShortestPathFunctionName() IShortestPathFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShortestPathFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShortestPathFunctionNameContext)
}

func (s *ShortestPathPatternFunctionContext) PatternElement() IPatternElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElementContext)
}

func (s *ShortestPathPatternFunctionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ShortestPathPatternFunctionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ShortestPathPatternFunctionContext) AllShortestPathFunctionName() IAllShortestPathFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllShortestPathFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllShortestPathFunctionNameContext)
}

func (s *ShortestPathPatternFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortestPathPatternFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortestPathPatternFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterShortestPathPatternFunction(s)
	}
}

func (s *ShortestPathPatternFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitShortestPathPatternFunction(s)
	}
}

func (p *CypherParser) ShortestPathPatternFunction() (localctx IShortestPathPatternFunctionContext) {
	this := p
	_ = this

	localctx = NewShortestPathPatternFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, CypherParserRULE_shortestPathPatternFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2967)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserSHORTESTPATH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2939)
			p.ShortestPathFunctionName()
		}
		p.SetState(2941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2940)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2943)
			p.Match(CypherParserT__19)
		}
		p.SetState(2945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2944)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2947)
			p.PatternElement()
		}
		p.SetState(2949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2948)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2951)
			p.Match(CypherParserT__20)
		}

	case CypherParserALLSHORTESTPATHS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2953)
			p.AllShortestPathFunctionName()
		}
		p.SetState(2955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2954)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2957)
			p.Match(CypherParserT__19)
		}
		p.SetState(2959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2958)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2961)
			p.PatternElement()
		}
		p.SetState(2963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2962)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2965)
			p.Match(CypherParserT__20)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShortestPathFunctionNameContext is an interface to support dynamic dispatch.
type IShortestPathFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShortestPathFunctionNameContext differentiates from other interfaces.
	IsShortestPathFunctionNameContext()
}

type ShortestPathFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortestPathFunctionNameContext() *ShortestPathFunctionNameContext {
	var p = new(ShortestPathFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_shortestPathFunctionName
	return p
}

func (*ShortestPathFunctionNameContext) IsShortestPathFunctionNameContext() {}

func NewShortestPathFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortestPathFunctionNameContext {
	var p = new(ShortestPathFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_shortestPathFunctionName

	return p
}

func (s *ShortestPathFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortestPathFunctionNameContext) SHORTESTPATH() antlr.TerminalNode {
	return s.GetToken(CypherParserSHORTESTPATH, 0)
}

func (s *ShortestPathFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortestPathFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortestPathFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterShortestPathFunctionName(s)
	}
}

func (s *ShortestPathFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitShortestPathFunctionName(s)
	}
}

func (p *CypherParser) ShortestPathFunctionName() (localctx IShortestPathFunctionNameContext) {
	this := p
	_ = this

	localctx = NewShortestPathFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, CypherParserRULE_shortestPathFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2969)
		p.Match(CypherParserSHORTESTPATH)
	}

	return localctx
}

// IAllShortestPathFunctionNameContext is an interface to support dynamic dispatch.
type IAllShortestPathFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAllShortestPathFunctionNameContext differentiates from other interfaces.
	IsAllShortestPathFunctionNameContext()
}

type AllShortestPathFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllShortestPathFunctionNameContext() *AllShortestPathFunctionNameContext {
	var p = new(AllShortestPathFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_allShortestPathFunctionName
	return p
}

func (*AllShortestPathFunctionNameContext) IsAllShortestPathFunctionNameContext() {}

func NewAllShortestPathFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllShortestPathFunctionNameContext {
	var p = new(AllShortestPathFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_allShortestPathFunctionName

	return p
}

func (s *AllShortestPathFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AllShortestPathFunctionNameContext) ALLSHORTESTPATHS() antlr.TerminalNode {
	return s.GetToken(CypherParserALLSHORTESTPATHS, 0)
}

func (s *AllShortestPathFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllShortestPathFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllShortestPathFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAllShortestPathFunctionName(s)
	}
}

func (s *AllShortestPathFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAllShortestPathFunctionName(s)
	}
}

func (p *CypherParser) AllShortestPathFunctionName() (localctx IAllShortestPathFunctionNameContext) {
	this := p
	_ = this

	localctx = NewAllShortestPathFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, CypherParserRULE_allShortestPathFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2971)
		p.Match(CypherParserALLSHORTESTPATHS)
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *AtomContext) CaseExpression() ICaseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *AtomContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *AtomContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AtomContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AtomContext) ListComprehension() IListComprehensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListComprehensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListComprehensionContext)
}

func (s *AtomContext) PatternComprehension() IPatternComprehensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternComprehensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternComprehensionContext)
}

func (s *AtomContext) FilterFunction() IFilterFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterFunctionContext)
}

func (s *AtomContext) ExtractFunction() IExtractFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtractFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtractFunctionContext)
}

func (s *AtomContext) ReduceFunction() IReduceFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReduceFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReduceFunctionContext)
}

func (s *AtomContext) AllFunction() IAllFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllFunctionContext)
}

func (s *AtomContext) AnyFunction() IAnyFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyFunctionContext)
}

func (s *AtomContext) NoneFunction() INoneFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoneFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoneFunctionContext)
}

func (s *AtomContext) SingleFunction() ISingleFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleFunctionContext)
}

func (s *AtomContext) ExistsFunction() IExistsFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExistsFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExistsFunctionContext)
}

func (s *AtomContext) ShortestPathPatternFunction() IShortestPathPatternFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShortestPathPatternFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShortestPathPatternFunctionContext)
}

func (s *AtomContext) RelationshipsPattern() IRelationshipsPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipsPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipsPatternContext)
}

func (s *AtomContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *AtomContext) FunctionInvocation() IFunctionInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionInvocationContext)
}

func (s *AtomContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *CypherParser) Atom() (localctx IAtomContext) {
	this := p
	_ = this

	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, CypherParserRULE_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3004)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 407, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2973)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2974)
			p.Parameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2975)
			p.CaseExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2976)
			p.Match(CypherParserCOUNT)
		}
		p.SetState(2978)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2977)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2980)
			p.Match(CypherParserT__19)
		}
		p.SetState(2982)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2981)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2984)
			p.Match(CypherParserT__18)
		}
		p.SetState(2986)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(2985)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(2988)
			p.Match(CypherParserT__20)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2989)
			p.ListComprehension()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2990)
			p.PatternComprehension()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2991)
			p.FilterFunction()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2992)
			p.ExtractFunction()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2993)
			p.ReduceFunction()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2994)
			p.AllFunction()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2995)
			p.AnyFunction()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2996)
			p.NoneFunction()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2997)
			p.SingleFunction()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2998)
			p.ExistsFunction()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2999)
			p.ShortestPathPatternFunction()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3000)
			p.RelationshipsPattern()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3001)
			p.ParenthesizedExpression()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3002)
			p.FunctionInvocation()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3003)
			p.Variable()
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *LiteralContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LiteralContext) ListLiteral() IListLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *LiteralContext) MapProjection() IMapProjectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapProjectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapProjectionContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *CypherParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, CypherParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3013)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3006)
			p.NumberLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3007)
			p.StringLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3008)
			p.BooleanLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3009)
			p.Match(CypherParserNULL)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3010)
			p.MapLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3011)
			p.ListLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3012)
			p.MapProjection()
		}

	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *CypherParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, CypherParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3015)
		p.Match(CypherParserStringLiteral)
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *CypherParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, CypherParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3017)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserTRUE || _la == CypherParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IListLiteralContext is an interface to support dynamic dispatch.
type IListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListLiteralContext differentiates from other interfaces.
	IsListLiteralContext()
}

type ListLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListLiteralContext() *ListLiteralContext {
	var p = new(ListLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_listLiteral
	return p
}

func (*ListLiteralContext) IsListLiteralContext() {}

func NewListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLiteralContext {
	var p = new(ListLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listLiteral

	return p
}

func (s *ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ListLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ListLiteralContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ListLiteralContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterListLiteral(s)
	}
}

func (s *ListLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitListLiteral(s)
	}
}

func (p *CypherParser) ListLiteral() (localctx IListLiteralContext) {
	this := p
	_ = this

	localctx = NewListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, CypherParserRULE_listLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3019)
		p.Match(CypherParserT__16)
	}
	p.SetState(3021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3020)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(3040)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__2)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__16)|(1<<CypherParserT__19))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(CypherParserT__33-34))|(1<<(CypherParserCYPHER-34))|(1<<(CypherParserEXPLAIN-34))|(1<<(CypherParserPROFILE-34))|(1<<(CypherParserUSING-34))|(1<<(CypherParserPERIODIC-34))|(1<<(CypherParserCOMMIT-34))|(1<<(CypherParserUNION-34))|(1<<(CypherParserALL-34))|(1<<(CypherParserCREATE-34))|(1<<(CypherParserDROP-34))|(1<<(CypherParserINDEX-34))|(1<<(CypherParserON-34)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(CypherParserCONSTRAINT-66))|(1<<(CypherParserASSERT-66))|(1<<(CypherParserIS-66))|(1<<(CypherParserUNIQUE-66))|(1<<(CypherParserEXISTS-66))|(1<<(CypherParserLOAD-66))|(1<<(CypherParserCSV-66))|(1<<(CypherParserWITH-66))|(1<<(CypherParserHEADERS-66))|(1<<(CypherParserFROM-66))|(1<<(CypherParserAS-66))|(1<<(CypherParserFIELDTERMINATOR-66))|(1<<(CypherParserOPTIONAL-66))|(1<<(CypherParserMATCH-66))|(1<<(CypherParserUNWIND-66))|(1<<(CypherParserMERGE-66))|(1<<(CypherParserSET-66))|(1<<(CypherParserDETACH-66))|(1<<(CypherParserDELETE-66))|(1<<(CypherParserREMOVE-66))|(1<<(CypherParserFOREACH-66))|(1<<(CypherParserIN-66))|(1<<(CypherParserDISTINCT-66))|(1<<(CypherParserRETURN-66))|(1<<(CypherParserORDER-66))|(1<<(CypherParserBY-66))|(1<<(CypherParserL_SKIP-66))|(1<<(CypherParserLIMIT-66))|(1<<(CypherParserASCENDING-66))|(1<<(CypherParserASC-66))|(1<<(CypherParserDESCENDING-66))|(1<<(CypherParserDESC-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(CypherParserJOIN-98))|(1<<(CypherParserSCAN-98))|(1<<(CypherParserSTART-98))|(1<<(CypherParserNODE-98))|(1<<(CypherParserRELATIONSHIP-98))|(1<<(CypherParserREL-98))|(1<<(CypherParserWHERE-98))|(1<<(CypherParserSHORTESTPATH-98))|(1<<(CypherParserALLSHORTESTPATHS-98))|(1<<(CypherParserOR-98))|(1<<(CypherParserXOR-98))|(1<<(CypherParserAND-98))|(1<<(CypherParserNOT-98))|(1<<(CypherParserSTARTS-98))|(1<<(CypherParserENDS-98))|(1<<(CypherParserCONTAINS-98))|(1<<(CypherParserNULL-98))|(1<<(CypherParserCOUNT-98))|(1<<(CypherParserFILTER-98))|(1<<(CypherParserEXTRACT-98))|(1<<(CypherParserANY-98))|(1<<(CypherParserNONE-98))|(1<<(CypherParserSINGLE-98))|(1<<(CypherParserTRUE-98))|(1<<(CypherParserFALSE-98))|(1<<(CypherParserREDUCE-98))|(1<<(CypherParserCASE-98))|(1<<(CypherParserELSE-98))|(1<<(CypherParserEND-98))|(1<<(CypherParserWHEN-98))|(1<<(CypherParserTHEN-98))|(1<<(CypherParserCALL-98)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(CypherParserYIELD-130))|(1<<(CypherParserKEY-130))|(1<<(CypherParserCATALOG-130))|(1<<(CypherParserSHOW-130))|(1<<(CypherParserDEFAULT-130))|(1<<(CypherParserDBMS-130))|(1<<(CypherParserDATABASE-130))|(1<<(CypherParserDATABASES-130))|(1<<(CypherParserGRAPH-130))|(1<<(CypherParserGRAPHS-130))|(1<<(CypherParserREPLACE-130))|(1<<(CypherParserIF-130))|(1<<(CypherParserSTOP-130))|(1<<(CypherParserROLE-130))|(1<<(CypherParserROLES-130))|(1<<(CypherParserUSER-130))|(1<<(CypherParserUSERS-130))|(1<<(CypherParserPOPULATED-130))|(1<<(CypherParserPASSWORD-130))|(1<<(CypherParserCHANGE-130))|(1<<(CypherParserREQUIRED-130))|(1<<(CypherParserSTATUS-130))|(1<<(CypherParserACTIVE-130))|(1<<(CypherParserSUSPENDED-130))|(1<<(CypherParserALTER-130))|(1<<(CypherParserCURRENT-130))|(1<<(CypherParserTO-130))|(1<<(CypherParserPRIVILEGES-130))|(1<<(CypherParserGRANT-130))|(1<<(CypherParserDENY-130))|(1<<(CypherParserREVOKE-130))|(1<<(CypherParserRELATIONSHIPS-130)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(CypherParserNODES-162))|(1<<(CypherParserELEMENT-162))|(1<<(CypherParserELEMENTS-162))|(1<<(CypherParserCOPY-162))|(1<<(CypherParserOF-162))|(1<<(CypherParserTRAVERSE-162))|(1<<(CypherParserREAD-162))|(1<<(CypherParserWRITE-162))|(1<<(CypherParserACCESS-162))|(1<<(CypherParserINDEXES-162))|(1<<(CypherParserMANAGEMENT-162))|(1<<(CypherParserNEW-162))|(1<<(CypherParserLABEL-162))|(1<<(CypherParserLABELS-162))|(1<<(CypherParserNAME-162))|(1<<(CypherParserNAMES-162))|(1<<(CypherParserTYPE-162))|(1<<(CypherParserTYPES-162))|(1<<(CypherParserPROPERTY-162))|(1<<(CypherParserCONSTRAINTS-162))|(1<<(CypherParserASSIGN-162))|(1<<(CypherParserBTREE-162))|(1<<(CypherParserEXIST-162))|(1<<(CypherParserFOR-162))|(1<<(CypherParserOPTIONS-162))|(1<<(CypherParserEXECUTE-162))|(1<<(CypherParserDEFINED-162))|(1<<(CypherParserFUNCTION-162))|(1<<(CypherParserFUNCTIONS-162))|(1<<(CypherParserBOOSTED-162))|(1<<(CypherParserPROCEDURE-162))|(1<<(CypherParserPROCEDURES-162)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(CypherParserADMIN-194))|(1<<(CypherParserADMINISTRATOR-194))|(1<<(CypherParserBRIEF-194))|(1<<(CypherParserVERBOSE-194))|(1<<(CypherParserOUTPUT-194))|(1<<(CypherParserBUILT-194))|(1<<(CypherParserEACH-194))|(1<<(CypherParserEXECUTABLE-194))|(1<<(CypherParserEXISTENCE-194))|(1<<(CypherParserFULLTEXT-194))|(1<<(CypherParserHOME-194))|(1<<(CypherParserLOOKUP-194))|(1<<(CypherParserStringLiteral-194))|(1<<(CypherParserHexInteger-194))|(1<<(CypherParserDecimalInteger-194))|(1<<(CypherParserOctalInteger-194))|(1<<(CypherParserHexLetter-194))|(1<<(CypherParserExponentDecimalReal-194))|(1<<(CypherParserRegularDecimalReal-194))|(1<<(CypherParserUnescapedSymbolicName-194))|(1<<(CypherParserEscapedSymbolicName-194)))) != 0) {
		{
			p.SetState(3023)
			p.Expression()
		}
		p.SetState(3025)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3024)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(3037)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__14 {
			{
				p.SetState(3027)
				p.Match(CypherParserT__14)
			}
			p.SetState(3029)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3028)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3031)
				p.Expression()
			}
			p.SetState(3033)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3032)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(3039)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3042)
		p.Match(CypherParserT__17)
	}

	return localctx
}

// IPartialComparisonExpressionContext is an interface to support dynamic dispatch.
type IPartialComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialComparisonExpressionContext differentiates from other interfaces.
	IsPartialComparisonExpressionContext()
}

type PartialComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialComparisonExpressionContext() *PartialComparisonExpressionContext {
	var p = new(PartialComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_partialComparisonExpression
	return p
}

func (*PartialComparisonExpressionContext) IsPartialComparisonExpressionContext() {}

func NewPartialComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialComparisonExpressionContext {
	var p = new(PartialComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_partialComparisonExpression

	return p
}

func (s *PartialComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialComparisonExpressionContext) AddOrSubtractExpression() IAddOrSubtractExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddOrSubtractExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddOrSubtractExpressionContext)
}

func (s *PartialComparisonExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PartialComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPartialComparisonExpression(s)
	}
}

func (s *PartialComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPartialComparisonExpression(s)
	}
}

func (p *CypherParser) PartialComparisonExpression() (localctx IPartialComparisonExpressionContext) {
	this := p
	_ = this

	localctx = NewPartialComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, CypherParserRULE_partialComparisonExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3079)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__11:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3044)
			p.Match(CypherParserT__11)
		}
		p.SetState(3046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3045)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3048)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__27:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3049)
			p.Match(CypherParserT__27)
		}
		p.SetState(3051)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3050)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3053)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__28:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3054)
			p.Match(CypherParserT__28)
		}
		p.SetState(3056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3055)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3058)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__29:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3059)
			p.Match(CypherParserT__29)
		}
		p.SetState(3061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3060)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3063)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__30:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3064)
			p.Match(CypherParserT__30)
		}
		p.SetState(3066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3065)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3068)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__31:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3069)
			p.Match(CypherParserT__31)
		}
		p.SetState(3071)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3070)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3073)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__32:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3074)
			p.Match(CypherParserT__32)
		}
		p.SetState(3076)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3075)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3078)
			p.AddOrSubtractExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_parenthesizedExpression
	return p
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ParenthesizedExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (p *CypherParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	this := p
	_ = this

	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, CypherParserRULE_parenthesizedExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3081)
		p.Match(CypherParserT__19)
	}
	p.SetState(3083)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3082)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3085)
		p.Expression()
	}
	p.SetState(3087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3086)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3089)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IRelationshipsPatternContext is an interface to support dynamic dispatch.
type IRelationshipsPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipsPatternContext differentiates from other interfaces.
	IsRelationshipsPatternContext()
}

type RelationshipsPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipsPatternContext() *RelationshipsPatternContext {
	var p = new(RelationshipsPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipsPattern
	return p
}

func (*RelationshipsPatternContext) IsRelationshipsPatternContext() {}

func NewRelationshipsPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipsPatternContext {
	var p = new(RelationshipsPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipsPattern

	return p
}

func (s *RelationshipsPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipsPatternContext) NodePattern() INodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *RelationshipsPatternContext) AllPatternElementChain() []IPatternElementChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternElementChainContext); ok {
			len++
		}
	}

	tst := make([]IPatternElementChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternElementChainContext); ok {
			tst[i] = t.(IPatternElementChainContext)
			i++
		}
	}

	return tst
}

func (s *RelationshipsPatternContext) PatternElementChain(i int) IPatternElementChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternElementChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternElementChainContext)
}

func (s *RelationshipsPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipsPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipsPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipsPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipsPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipsPattern(s)
	}
}

func (s *RelationshipsPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipsPattern(s)
	}
}

func (p *CypherParser) RelationshipsPattern() (localctx IRelationshipsPatternContext) {
	this := p
	_ = this

	localctx = NewRelationshipsPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, CypherParserRULE_relationshipsPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3091)
		p.NodePattern()
	}
	p.SetState(3096)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3093)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3092)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3095)
				p.PatternElementChain()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3098)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 426, p.GetParserRuleContext())
	}

	return localctx
}

// IFilterExpressionContext is an interface to support dynamic dispatch.
type IFilterExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterExpressionContext differentiates from other interfaces.
	IsFilterExpressionContext()
}

type FilterExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterExpressionContext() *FilterExpressionContext {
	var p = new(FilterExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_filterExpression
	return p
}

func (*FilterExpressionContext) IsFilterExpressionContext() {}

func NewFilterExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterExpressionContext {
	var p = new(FilterExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_filterExpression

	return p
}

func (s *FilterExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterExpressionContext) IdInColl() IIdInCollContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdInCollContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdInCollContext)
}

func (s *FilterExpressionContext) Where() IWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *FilterExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *FilterExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFilterExpression(s)
	}
}

func (s *FilterExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFilterExpression(s)
	}
}

func (p *CypherParser) FilterExpression() (localctx IFilterExpressionContext) {
	this := p
	_ = this

	localctx = NewFilterExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, CypherParserRULE_filterExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3100)
		p.IdInColl()
	}
	p.SetState(3105)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 428, p.GetParserRuleContext()) == 1 {
		p.SetState(3102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3101)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3104)
			p.Where()
		}

	}

	return localctx
}

// IIdInCollContext is an interface to support dynamic dispatch.
type IIdInCollContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdInCollContext differentiates from other interfaces.
	IsIdInCollContext()
}

type IdInCollContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdInCollContext() *IdInCollContext {
	var p = new(IdInCollContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_idInColl
	return p
}

func (*IdInCollContext) IsIdInCollContext() {}

func NewIdInCollContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdInCollContext {
	var p = new(IdInCollContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_idInColl

	return p
}

func (s *IdInCollContext) GetParser() antlr.Parser { return s.parser }

func (s *IdInCollContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *IdInCollContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *IdInCollContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *IdInCollContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *IdInCollContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IdInCollContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdInCollContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdInCollContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIdInColl(s)
	}
}

func (s *IdInCollContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIdInColl(s)
	}
}

func (p *CypherParser) IdInColl() (localctx IIdInCollContext) {
	this := p
	_ = this

	localctx = NewIdInCollContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, CypherParserRULE_idInColl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3107)
		p.Variable()
	}
	{
		p.SetState(3108)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(3109)
		p.Match(CypherParserIN)
	}
	{
		p.SetState(3110)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(3111)
		p.Expression()
	}

	return localctx
}

// IFunctionInvocationContext is an interface to support dynamic dispatch.
type IFunctionInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionInvocationContext differentiates from other interfaces.
	IsFunctionInvocationContext()
}

type FunctionInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionInvocationContext() *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_functionInvocation
	return p
}

func (*FunctionInvocationContext) IsFunctionInvocationContext() {}

func NewFunctionInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionInvocation

	return p
}

func (s *FunctionInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionInvocationContext) FunctionInvocationBody() IFunctionInvocationBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionInvocationBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionInvocationBodyContext)
}

func (s *FunctionInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *FunctionInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *FunctionInvocationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *FunctionInvocationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionInvocationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFunctionInvocation(s)
	}
}

func (s *FunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFunctionInvocation(s)
	}
}

func (p *CypherParser) FunctionInvocation() (localctx IFunctionInvocationContext) {
	this := p
	_ = this

	localctx = NewFunctionInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, CypherParserRULE_functionInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3113)
		p.FunctionInvocationBody()
	}
	p.SetState(3115)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3114)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3117)
		p.Match(CypherParserT__19)
	}
	p.SetState(3119)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3118)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(3125)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3121)
			p.Match(CypherParserDISTINCT)
		}
		p.SetState(3123)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3122)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(3144)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__2)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__16)|(1<<CypherParserT__19))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(CypherParserT__33-34))|(1<<(CypherParserCYPHER-34))|(1<<(CypherParserEXPLAIN-34))|(1<<(CypherParserPROFILE-34))|(1<<(CypherParserUSING-34))|(1<<(CypherParserPERIODIC-34))|(1<<(CypherParserCOMMIT-34))|(1<<(CypherParserUNION-34))|(1<<(CypherParserALL-34))|(1<<(CypherParserCREATE-34))|(1<<(CypherParserDROP-34))|(1<<(CypherParserINDEX-34))|(1<<(CypherParserON-34)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(CypherParserCONSTRAINT-66))|(1<<(CypherParserASSERT-66))|(1<<(CypherParserIS-66))|(1<<(CypherParserUNIQUE-66))|(1<<(CypherParserEXISTS-66))|(1<<(CypherParserLOAD-66))|(1<<(CypherParserCSV-66))|(1<<(CypherParserWITH-66))|(1<<(CypherParserHEADERS-66))|(1<<(CypherParserFROM-66))|(1<<(CypherParserAS-66))|(1<<(CypherParserFIELDTERMINATOR-66))|(1<<(CypherParserOPTIONAL-66))|(1<<(CypherParserMATCH-66))|(1<<(CypherParserUNWIND-66))|(1<<(CypherParserMERGE-66))|(1<<(CypherParserSET-66))|(1<<(CypherParserDETACH-66))|(1<<(CypherParserDELETE-66))|(1<<(CypherParserREMOVE-66))|(1<<(CypherParserFOREACH-66))|(1<<(CypherParserIN-66))|(1<<(CypherParserDISTINCT-66))|(1<<(CypherParserRETURN-66))|(1<<(CypherParserORDER-66))|(1<<(CypherParserBY-66))|(1<<(CypherParserL_SKIP-66))|(1<<(CypherParserLIMIT-66))|(1<<(CypherParserASCENDING-66))|(1<<(CypherParserASC-66))|(1<<(CypherParserDESCENDING-66))|(1<<(CypherParserDESC-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(CypherParserJOIN-98))|(1<<(CypherParserSCAN-98))|(1<<(CypherParserSTART-98))|(1<<(CypherParserNODE-98))|(1<<(CypherParserRELATIONSHIP-98))|(1<<(CypherParserREL-98))|(1<<(CypherParserWHERE-98))|(1<<(CypherParserSHORTESTPATH-98))|(1<<(CypherParserALLSHORTESTPATHS-98))|(1<<(CypherParserOR-98))|(1<<(CypherParserXOR-98))|(1<<(CypherParserAND-98))|(1<<(CypherParserNOT-98))|(1<<(CypherParserSTARTS-98))|(1<<(CypherParserENDS-98))|(1<<(CypherParserCONTAINS-98))|(1<<(CypherParserNULL-98))|(1<<(CypherParserCOUNT-98))|(1<<(CypherParserFILTER-98))|(1<<(CypherParserEXTRACT-98))|(1<<(CypherParserANY-98))|(1<<(CypherParserNONE-98))|(1<<(CypherParserSINGLE-98))|(1<<(CypherParserTRUE-98))|(1<<(CypherParserFALSE-98))|(1<<(CypherParserREDUCE-98))|(1<<(CypherParserCASE-98))|(1<<(CypherParserELSE-98))|(1<<(CypherParserEND-98))|(1<<(CypherParserWHEN-98))|(1<<(CypherParserTHEN-98))|(1<<(CypherParserCALL-98)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(CypherParserYIELD-130))|(1<<(CypherParserKEY-130))|(1<<(CypherParserCATALOG-130))|(1<<(CypherParserSHOW-130))|(1<<(CypherParserDEFAULT-130))|(1<<(CypherParserDBMS-130))|(1<<(CypherParserDATABASE-130))|(1<<(CypherParserDATABASES-130))|(1<<(CypherParserGRAPH-130))|(1<<(CypherParserGRAPHS-130))|(1<<(CypherParserREPLACE-130))|(1<<(CypherParserIF-130))|(1<<(CypherParserSTOP-130))|(1<<(CypherParserROLE-130))|(1<<(CypherParserROLES-130))|(1<<(CypherParserUSER-130))|(1<<(CypherParserUSERS-130))|(1<<(CypherParserPOPULATED-130))|(1<<(CypherParserPASSWORD-130))|(1<<(CypherParserCHANGE-130))|(1<<(CypherParserREQUIRED-130))|(1<<(CypherParserSTATUS-130))|(1<<(CypherParserACTIVE-130))|(1<<(CypherParserSUSPENDED-130))|(1<<(CypherParserALTER-130))|(1<<(CypherParserCURRENT-130))|(1<<(CypherParserTO-130))|(1<<(CypherParserPRIVILEGES-130))|(1<<(CypherParserGRANT-130))|(1<<(CypherParserDENY-130))|(1<<(CypherParserREVOKE-130))|(1<<(CypherParserRELATIONSHIPS-130)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(CypherParserNODES-162))|(1<<(CypherParserELEMENT-162))|(1<<(CypherParserELEMENTS-162))|(1<<(CypherParserCOPY-162))|(1<<(CypherParserOF-162))|(1<<(CypherParserTRAVERSE-162))|(1<<(CypherParserREAD-162))|(1<<(CypherParserWRITE-162))|(1<<(CypherParserACCESS-162))|(1<<(CypherParserINDEXES-162))|(1<<(CypherParserMANAGEMENT-162))|(1<<(CypherParserNEW-162))|(1<<(CypherParserLABEL-162))|(1<<(CypherParserLABELS-162))|(1<<(CypherParserNAME-162))|(1<<(CypherParserNAMES-162))|(1<<(CypherParserTYPE-162))|(1<<(CypherParserTYPES-162))|(1<<(CypherParserPROPERTY-162))|(1<<(CypherParserCONSTRAINTS-162))|(1<<(CypherParserASSIGN-162))|(1<<(CypherParserBTREE-162))|(1<<(CypherParserEXIST-162))|(1<<(CypherParserFOR-162))|(1<<(CypherParserOPTIONS-162))|(1<<(CypherParserEXECUTE-162))|(1<<(CypherParserDEFINED-162))|(1<<(CypherParserFUNCTION-162))|(1<<(CypherParserFUNCTIONS-162))|(1<<(CypherParserBOOSTED-162))|(1<<(CypherParserPROCEDURE-162))|(1<<(CypherParserPROCEDURES-162)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(CypherParserADMIN-194))|(1<<(CypherParserADMINISTRATOR-194))|(1<<(CypherParserBRIEF-194))|(1<<(CypherParserVERBOSE-194))|(1<<(CypherParserOUTPUT-194))|(1<<(CypherParserBUILT-194))|(1<<(CypherParserEACH-194))|(1<<(CypherParserEXECUTABLE-194))|(1<<(CypherParserEXISTENCE-194))|(1<<(CypherParserFULLTEXT-194))|(1<<(CypherParserHOME-194))|(1<<(CypherParserLOOKUP-194))|(1<<(CypherParserStringLiteral-194))|(1<<(CypherParserHexInteger-194))|(1<<(CypherParserDecimalInteger-194))|(1<<(CypherParserOctalInteger-194))|(1<<(CypherParserHexLetter-194))|(1<<(CypherParserExponentDecimalReal-194))|(1<<(CypherParserRegularDecimalReal-194))|(1<<(CypherParserUnescapedSymbolicName-194))|(1<<(CypherParserEscapedSymbolicName-194)))) != 0) {
		{
			p.SetState(3127)
			p.Expression()
		}
		p.SetState(3129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3128)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(3141)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__14 {
			{
				p.SetState(3131)
				p.Match(CypherParserT__14)
			}
			p.SetState(3133)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3132)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3135)
				p.Expression()
			}
			p.SetState(3137)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3136)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(3143)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3146)
		p.Match(CypherParserT__20)
	}

	return localctx
}

// IFunctionInvocationBodyContext is an interface to support dynamic dispatch.
type IFunctionInvocationBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionInvocationBodyContext differentiates from other interfaces.
	IsFunctionInvocationBodyContext()
}

type FunctionInvocationBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionInvocationBodyContext() *FunctionInvocationBodyContext {
	var p = new(FunctionInvocationBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_functionInvocationBody
	return p
}

func (*FunctionInvocationBodyContext) IsFunctionInvocationBodyContext() {}

func NewFunctionInvocationBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionInvocationBodyContext {
	var p = new(FunctionInvocationBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionInvocationBody

	return p
}

func (s *FunctionInvocationBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionInvocationBodyContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *FunctionInvocationBodyContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionInvocationBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionInvocationBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionInvocationBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFunctionInvocationBody(s)
	}
}

func (s *FunctionInvocationBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFunctionInvocationBody(s)
	}
}

func (p *CypherParser) FunctionInvocationBody() (localctx IFunctionInvocationBodyContext) {
	this := p
	_ = this

	localctx = NewFunctionInvocationBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, CypherParserRULE_functionInvocationBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3148)
		p.Namespace()
	}
	{
		p.SetState(3149)
		p.FunctionName()
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) UnescapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserUnescapedSymbolicName, 0)
}

func (s *FunctionNameContext) EscapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserEscapedSymbolicName, 0)
}

func (s *FunctionNameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (p *CypherParser) FunctionName() (localctx IFunctionNameContext) {
	this := p
	_ = this

	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, CypherParserRULE_functionName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3151)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserCOUNT || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (p *CypherParser) ProcedureName() (localctx IProcedureNameContext) {
	this := p
	_ = this

	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, CypherParserRULE_procedureName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		p.SymbolicName()
	}

	return localctx
}

// IListComprehensionContext is an interface to support dynamic dispatch.
type IListComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListComprehensionContext differentiates from other interfaces.
	IsListComprehensionContext()
}

type ListComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListComprehensionContext() *ListComprehensionContext {
	var p = new(ListComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_listComprehension
	return p
}

func (*ListComprehensionContext) IsListComprehensionContext() {}

func NewListComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListComprehensionContext {
	var p = new(ListComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listComprehension

	return p
}

func (s *ListComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListComprehensionContext) FilterExpression() IFilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *ListComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ListComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ListComprehensionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterListComprehension(s)
	}
}

func (s *ListComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitListComprehension(s)
	}
}

func (p *CypherParser) ListComprehension() (localctx IListComprehensionContext) {
	this := p
	_ = this

	localctx = NewListComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, CypherParserRULE_listComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Match(CypherParserT__16)
	}
	p.SetState(3157)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3156)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3159)
		p.FilterExpression()
	}
	p.SetState(3168)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 441, p.GetParserRuleContext()) == 1 {
		p.SetState(3161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3160)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3163)
			p.Match(CypherParserT__22)
		}
		p.SetState(3165)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3164)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3167)
			p.Expression()
		}

	}
	p.SetState(3171)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3170)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3173)
		p.Match(CypherParserT__17)
	}

	return localctx
}

// IPatternComprehensionContext is an interface to support dynamic dispatch.
type IPatternComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternComprehensionContext differentiates from other interfaces.
	IsPatternComprehensionContext()
}

type PatternComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternComprehensionContext() *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternComprehension
	return p
}

func (*PatternComprehensionContext) IsPatternComprehensionContext() {}

func NewPatternComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternComprehension

	return p
}

func (s *PatternComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternComprehensionContext) RelationshipsPattern() IRelationshipsPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationshipsPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationshipsPatternContext)
}

func (s *PatternComprehensionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PatternComprehensionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PatternComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternComprehensionContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PatternComprehensionContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *PatternComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternComprehension(s)
	}
}

func (s *PatternComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternComprehension(s)
	}
}

func (p *CypherParser) PatternComprehension() (localctx IPatternComprehensionContext) {
	this := p
	_ = this

	localctx = NewPatternComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, CypherParserRULE_patternComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3175)
		p.Match(CypherParserT__16)
	}
	p.SetState(3177)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3176)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(3187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(CypherParserCYPHER-54))|(1<<(CypherParserEXPLAIN-54))|(1<<(CypherParserPROFILE-54))|(1<<(CypherParserUSING-54))|(1<<(CypherParserPERIODIC-54))|(1<<(CypherParserCOMMIT-54))|(1<<(CypherParserUNION-54))|(1<<(CypherParserALL-54))|(1<<(CypherParserCREATE-54))|(1<<(CypherParserDROP-54))|(1<<(CypherParserINDEX-54))|(1<<(CypherParserON-54))|(1<<(CypherParserCONSTRAINT-54))|(1<<(CypherParserASSERT-54))|(1<<(CypherParserIS-54))|(1<<(CypherParserUNIQUE-54))|(1<<(CypherParserEXISTS-54))|(1<<(CypherParserLOAD-54))|(1<<(CypherParserCSV-54))|(1<<(CypherParserWITH-54))|(1<<(CypherParserHEADERS-54))|(1<<(CypherParserFROM-54))|(1<<(CypherParserAS-54))|(1<<(CypherParserFIELDTERMINATOR-54))|(1<<(CypherParserOPTIONAL-54))|(1<<(CypherParserMATCH-54))|(1<<(CypherParserUNWIND-54))|(1<<(CypherParserMERGE-54))|(1<<(CypherParserSET-54))|(1<<(CypherParserDETACH-54))|(1<<(CypherParserDELETE-54))|(1<<(CypherParserREMOVE-54)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(CypherParserFOREACH-86))|(1<<(CypherParserIN-86))|(1<<(CypherParserDISTINCT-86))|(1<<(CypherParserRETURN-86))|(1<<(CypherParserORDER-86))|(1<<(CypherParserBY-86))|(1<<(CypherParserL_SKIP-86))|(1<<(CypherParserLIMIT-86))|(1<<(CypherParserASCENDING-86))|(1<<(CypherParserASC-86))|(1<<(CypherParserDESCENDING-86))|(1<<(CypherParserDESC-86))|(1<<(CypherParserJOIN-86))|(1<<(CypherParserSCAN-86))|(1<<(CypherParserSTART-86))|(1<<(CypherParserNODE-86))|(1<<(CypherParserRELATIONSHIP-86))|(1<<(CypherParserREL-86))|(1<<(CypherParserWHERE-86))|(1<<(CypherParserSHORTESTPATH-86))|(1<<(CypherParserALLSHORTESTPATHS-86))|(1<<(CypherParserOR-86))|(1<<(CypherParserXOR-86))|(1<<(CypherParserAND-86))|(1<<(CypherParserNOT-86))|(1<<(CypherParserSTARTS-86))|(1<<(CypherParserENDS-86))|(1<<(CypherParserCONTAINS-86))|(1<<(CypherParserNULL-86))|(1<<(CypherParserCOUNT-86))|(1<<(CypherParserFILTER-86))|(1<<(CypherParserEXTRACT-86)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(CypherParserANY-118))|(1<<(CypherParserNONE-118))|(1<<(CypherParserSINGLE-118))|(1<<(CypherParserTRUE-118))|(1<<(CypherParserFALSE-118))|(1<<(CypherParserREDUCE-118))|(1<<(CypherParserCASE-118))|(1<<(CypherParserELSE-118))|(1<<(CypherParserEND-118))|(1<<(CypherParserWHEN-118))|(1<<(CypherParserTHEN-118))|(1<<(CypherParserCALL-118))|(1<<(CypherParserYIELD-118))|(1<<(CypherParserKEY-118))|(1<<(CypherParserCATALOG-118))|(1<<(CypherParserSHOW-118))|(1<<(CypherParserDEFAULT-118))|(1<<(CypherParserDBMS-118))|(1<<(CypherParserDATABASE-118))|(1<<(CypherParserDATABASES-118))|(1<<(CypherParserGRAPH-118))|(1<<(CypherParserGRAPHS-118))|(1<<(CypherParserREPLACE-118))|(1<<(CypherParserIF-118))|(1<<(CypherParserSTOP-118))|(1<<(CypherParserROLE-118))|(1<<(CypherParserROLES-118))|(1<<(CypherParserUSER-118))|(1<<(CypherParserUSERS-118))|(1<<(CypherParserPOPULATED-118))|(1<<(CypherParserPASSWORD-118))|(1<<(CypherParserCHANGE-118)))) != 0) || (((_la-150)&-(0x1f+1)) == 0 && ((1<<uint((_la-150)))&((1<<(CypherParserREQUIRED-150))|(1<<(CypherParserSTATUS-150))|(1<<(CypherParserACTIVE-150))|(1<<(CypherParserSUSPENDED-150))|(1<<(CypherParserALTER-150))|(1<<(CypherParserCURRENT-150))|(1<<(CypherParserTO-150))|(1<<(CypherParserPRIVILEGES-150))|(1<<(CypherParserGRANT-150))|(1<<(CypherParserDENY-150))|(1<<(CypherParserREVOKE-150))|(1<<(CypherParserRELATIONSHIPS-150))|(1<<(CypherParserNODES-150))|(1<<(CypherParserELEMENT-150))|(1<<(CypherParserELEMENTS-150))|(1<<(CypherParserCOPY-150))|(1<<(CypherParserOF-150))|(1<<(CypherParserTRAVERSE-150))|(1<<(CypherParserREAD-150))|(1<<(CypherParserWRITE-150))|(1<<(CypherParserACCESS-150))|(1<<(CypherParserINDEXES-150))|(1<<(CypherParserMANAGEMENT-150))|(1<<(CypherParserNEW-150))|(1<<(CypherParserLABEL-150))|(1<<(CypherParserLABELS-150))|(1<<(CypherParserNAME-150))|(1<<(CypherParserNAMES-150))|(1<<(CypherParserTYPE-150))|(1<<(CypherParserTYPES-150))|(1<<(CypherParserPROPERTY-150))|(1<<(CypherParserCONSTRAINTS-150)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(CypherParserASSIGN-182))|(1<<(CypherParserBTREE-182))|(1<<(CypherParserEXIST-182))|(1<<(CypherParserFOR-182))|(1<<(CypherParserOPTIONS-182))|(1<<(CypherParserEXECUTE-182))|(1<<(CypherParserDEFINED-182))|(1<<(CypherParserFUNCTION-182))|(1<<(CypherParserFUNCTIONS-182))|(1<<(CypherParserBOOSTED-182))|(1<<(CypherParserPROCEDURE-182))|(1<<(CypherParserPROCEDURES-182))|(1<<(CypherParserADMIN-182))|(1<<(CypherParserADMINISTRATOR-182))|(1<<(CypherParserBRIEF-182))|(1<<(CypherParserVERBOSE-182))|(1<<(CypherParserOUTPUT-182))|(1<<(CypherParserBUILT-182))|(1<<(CypherParserEACH-182))|(1<<(CypherParserEXECUTABLE-182))|(1<<(CypherParserEXISTENCE-182))|(1<<(CypherParserFULLTEXT-182))|(1<<(CypherParserHOME-182))|(1<<(CypherParserLOOKUP-182))|(1<<(CypherParserHexLetter-182)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(3179)
			p.Variable()
		}
		p.SetState(3181)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3180)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3183)
			p.Match(CypherParserT__11)
		}
		p.SetState(3185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3184)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(3189)
		p.RelationshipsPattern()
	}
	p.SetState(3191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3190)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(3201)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(3193)
			p.Match(CypherParserWHERE)
		}
		p.SetState(3195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3194)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3197)
			p.Expression()
		}
		p.SetState(3199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3198)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(3203)
		p.Match(CypherParserT__22)
	}
	p.SetState(3205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3204)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3207)
		p.Expression()
	}
	p.SetState(3209)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3208)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3211)
		p.Match(CypherParserT__17)
	}

	return localctx
}

// IPropertyLookupContext is an interface to support dynamic dispatch.
type IPropertyLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyLookupContext differentiates from other interfaces.
	IsPropertyLookupContext()
}

type PropertyLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyLookupContext() *PropertyLookupContext {
	var p = new(PropertyLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyLookup
	return p
}

func (*PropertyLookupContext) IsPropertyLookupContext() {}

func NewPropertyLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyLookupContext {
	var p = new(PropertyLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyLookup

	return p
}

func (s *PropertyLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyLookupContext) PropertyKeyName() IPropertyKeyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyNameContext)
}

func (s *PropertyLookupContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PropertyLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyLookup(s)
	}
}

func (s *PropertyLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyLookup(s)
	}
}

func (p *CypherParser) PropertyLookup() (localctx IPropertyLookupContext) {
	this := p
	_ = this

	localctx = NewPropertyLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, CypherParserRULE_propertyLookup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3213)
		p.Match(CypherParserT__6)
	}
	p.SetState(3215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3214)
			p.Match(CypherParserSP)
		}

	}

	{
		p.SetState(3217)
		p.PropertyKeyName()
	}

	return localctx
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_caseExpression
	return p
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *CaseExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *CaseExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CaseExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *CaseExpressionContext) AllCaseAlternatives() []ICaseAlternativesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseAlternativesContext); ok {
			len++
		}
	}

	tst := make([]ICaseAlternativesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseAlternativesContext); ok {
			tst[i] = t.(ICaseAlternativesContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionContext) CaseAlternatives(i int) ICaseAlternativesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseAlternativesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseAlternativesContext)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (p *CypherParser) CaseExpression() (localctx ICaseExpressionContext) {
	this := p
	_ = this

	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, CypherParserRULE_caseExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3241)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 459, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3219)
			p.Match(CypherParserCASE)
		}
		p.SetState(3224)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(3221)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(3220)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(3223)
					p.CaseAlternatives()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3226)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 455, p.GetParserRuleContext())
		}

	case 2:
		{
			p.SetState(3228)
			p.Match(CypherParserCASE)
		}
		p.SetState(3230)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3229)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3232)
			p.Expression()
		}
		p.SetState(3237)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(3234)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(3233)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(3236)
					p.CaseAlternatives()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3239)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 458, p.GetParserRuleContext())
		}

	}
	p.SetState(3251)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 462, p.GetParserRuleContext()) == 1 {
		p.SetState(3244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3243)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3246)
			p.Match(CypherParserELSE)
		}
		p.SetState(3248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3247)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(3250)
			p.Expression()
		}

	}
	p.SetState(3254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3253)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3256)
		p.Match(CypherParserEND)
	}

	return localctx
}

// ICaseAlternativesContext is an interface to support dynamic dispatch.
type ICaseAlternativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseAlternativesContext differentiates from other interfaces.
	IsCaseAlternativesContext()
}

type CaseAlternativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAlternativesContext() *CaseAlternativesContext {
	var p = new(CaseAlternativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_caseAlternatives
	return p
}

func (*CaseAlternativesContext) IsCaseAlternativesContext() {}

func NewCaseAlternativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAlternativesContext {
	var p = new(CaseAlternativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_caseAlternatives

	return p
}

func (s *CaseAlternativesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAlternativesContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *CaseAlternativesContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseAlternativesContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseAlternativesContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *CaseAlternativesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CaseAlternativesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CaseAlternativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAlternativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseAlternativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCaseAlternatives(s)
	}
}

func (s *CaseAlternativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCaseAlternatives(s)
	}
}

func (p *CypherParser) CaseAlternatives() (localctx ICaseAlternativesContext) {
	this := p
	_ = this

	localctx = NewCaseAlternativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, CypherParserRULE_caseAlternatives)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3258)
		p.Match(CypherParserWHEN)
	}
	p.SetState(3260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3259)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3262)
		p.Expression()
	}
	p.SetState(3264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3263)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3266)
		p.Match(CypherParserTHEN)
	}
	p.SetState(3268)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3267)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3270)
		p.Expression()
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (p *CypherParser) Variable() (localctx IVariableContext) {
	this := p
	_ = this

	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, CypherParserRULE_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3272)
		p.SymbolicName()
	}

	return localctx
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_numberLiteral
	return p
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) DoubleLiteral() IDoubleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleLiteralContext)
}

func (s *NumberLiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *CypherParser) NumberLiteral() (localctx INumberLiteralContext) {
	this := p
	_ = this

	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, CypherParserRULE_numberLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3276)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3274)
			p.DoubleLiteral()
		}

	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3275)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mapLiteral
	return p
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MapLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MapLiteralContext) AllLiteralEntry() []ILiteralEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralEntryContext); ok {
			len++
		}
	}

	tst := make([]ILiteralEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralEntryContext); ok {
			tst[i] = t.(ILiteralEntryContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) LiteralEntry(i int) ILiteralEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralEntryContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

func (p *CypherParser) MapLiteral() (localctx IMapLiteralContext) {
	this := p
	_ = this

	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, CypherParserRULE_mapLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3278)
		p.Match(CypherParserT__13)
	}
	p.SetState(3280)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3279)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(3299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(CypherParserCYPHER-54))|(1<<(CypherParserEXPLAIN-54))|(1<<(CypherParserPROFILE-54))|(1<<(CypherParserUSING-54))|(1<<(CypherParserPERIODIC-54))|(1<<(CypherParserCOMMIT-54))|(1<<(CypherParserUNION-54))|(1<<(CypherParserALL-54))|(1<<(CypherParserCREATE-54))|(1<<(CypherParserDROP-54))|(1<<(CypherParserINDEX-54))|(1<<(CypherParserON-54))|(1<<(CypherParserCONSTRAINT-54))|(1<<(CypherParserASSERT-54))|(1<<(CypherParserIS-54))|(1<<(CypherParserUNIQUE-54))|(1<<(CypherParserEXISTS-54))|(1<<(CypherParserLOAD-54))|(1<<(CypherParserCSV-54))|(1<<(CypherParserWITH-54))|(1<<(CypherParserHEADERS-54))|(1<<(CypherParserFROM-54))|(1<<(CypherParserAS-54))|(1<<(CypherParserFIELDTERMINATOR-54))|(1<<(CypherParserOPTIONAL-54))|(1<<(CypherParserMATCH-54))|(1<<(CypherParserUNWIND-54))|(1<<(CypherParserMERGE-54))|(1<<(CypherParserSET-54))|(1<<(CypherParserDETACH-54))|(1<<(CypherParserDELETE-54))|(1<<(CypherParserREMOVE-54)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(CypherParserFOREACH-86))|(1<<(CypherParserIN-86))|(1<<(CypherParserDISTINCT-86))|(1<<(CypherParserRETURN-86))|(1<<(CypherParserORDER-86))|(1<<(CypherParserBY-86))|(1<<(CypherParserL_SKIP-86))|(1<<(CypherParserLIMIT-86))|(1<<(CypherParserASCENDING-86))|(1<<(CypherParserASC-86))|(1<<(CypherParserDESCENDING-86))|(1<<(CypherParserDESC-86))|(1<<(CypherParserJOIN-86))|(1<<(CypherParserSCAN-86))|(1<<(CypherParserSTART-86))|(1<<(CypherParserNODE-86))|(1<<(CypherParserRELATIONSHIP-86))|(1<<(CypherParserREL-86))|(1<<(CypherParserWHERE-86))|(1<<(CypherParserSHORTESTPATH-86))|(1<<(CypherParserALLSHORTESTPATHS-86))|(1<<(CypherParserOR-86))|(1<<(CypherParserXOR-86))|(1<<(CypherParserAND-86))|(1<<(CypherParserNOT-86))|(1<<(CypherParserSTARTS-86))|(1<<(CypherParserENDS-86))|(1<<(CypherParserCONTAINS-86))|(1<<(CypherParserNULL-86))|(1<<(CypherParserCOUNT-86))|(1<<(CypherParserFILTER-86))|(1<<(CypherParserEXTRACT-86)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(CypherParserANY-118))|(1<<(CypherParserNONE-118))|(1<<(CypherParserSINGLE-118))|(1<<(CypherParserTRUE-118))|(1<<(CypherParserFALSE-118))|(1<<(CypherParserREDUCE-118))|(1<<(CypherParserCASE-118))|(1<<(CypherParserELSE-118))|(1<<(CypherParserEND-118))|(1<<(CypherParserWHEN-118))|(1<<(CypherParserTHEN-118))|(1<<(CypherParserCALL-118))|(1<<(CypherParserYIELD-118))|(1<<(CypherParserKEY-118))|(1<<(CypherParserCATALOG-118))|(1<<(CypherParserSHOW-118))|(1<<(CypherParserDEFAULT-118))|(1<<(CypherParserDBMS-118))|(1<<(CypherParserDATABASE-118))|(1<<(CypherParserDATABASES-118))|(1<<(CypherParserGRAPH-118))|(1<<(CypherParserGRAPHS-118))|(1<<(CypherParserREPLACE-118))|(1<<(CypherParserIF-118))|(1<<(CypherParserSTOP-118))|(1<<(CypherParserROLE-118))|(1<<(CypherParserROLES-118))|(1<<(CypherParserUSER-118))|(1<<(CypherParserUSERS-118))|(1<<(CypherParserPOPULATED-118))|(1<<(CypherParserPASSWORD-118))|(1<<(CypherParserCHANGE-118)))) != 0) || (((_la-150)&-(0x1f+1)) == 0 && ((1<<uint((_la-150)))&((1<<(CypherParserREQUIRED-150))|(1<<(CypherParserSTATUS-150))|(1<<(CypherParserACTIVE-150))|(1<<(CypherParserSUSPENDED-150))|(1<<(CypherParserALTER-150))|(1<<(CypherParserCURRENT-150))|(1<<(CypherParserTO-150))|(1<<(CypherParserPRIVILEGES-150))|(1<<(CypherParserGRANT-150))|(1<<(CypherParserDENY-150))|(1<<(CypherParserREVOKE-150))|(1<<(CypherParserRELATIONSHIPS-150))|(1<<(CypherParserNODES-150))|(1<<(CypherParserELEMENT-150))|(1<<(CypherParserELEMENTS-150))|(1<<(CypherParserCOPY-150))|(1<<(CypherParserOF-150))|(1<<(CypherParserTRAVERSE-150))|(1<<(CypherParserREAD-150))|(1<<(CypherParserWRITE-150))|(1<<(CypherParserACCESS-150))|(1<<(CypherParserINDEXES-150))|(1<<(CypherParserMANAGEMENT-150))|(1<<(CypherParserNEW-150))|(1<<(CypherParserLABEL-150))|(1<<(CypherParserLABELS-150))|(1<<(CypherParserNAME-150))|(1<<(CypherParserNAMES-150))|(1<<(CypherParserTYPE-150))|(1<<(CypherParserTYPES-150))|(1<<(CypherParserPROPERTY-150))|(1<<(CypherParserCONSTRAINTS-150)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(CypherParserASSIGN-182))|(1<<(CypherParserBTREE-182))|(1<<(CypherParserEXIST-182))|(1<<(CypherParserFOR-182))|(1<<(CypherParserOPTIONS-182))|(1<<(CypherParserEXECUTE-182))|(1<<(CypherParserDEFINED-182))|(1<<(CypherParserFUNCTION-182))|(1<<(CypherParserFUNCTIONS-182))|(1<<(CypherParserBOOSTED-182))|(1<<(CypherParserPROCEDURE-182))|(1<<(CypherParserPROCEDURES-182))|(1<<(CypherParserADMIN-182))|(1<<(CypherParserADMINISTRATOR-182))|(1<<(CypherParserBRIEF-182))|(1<<(CypherParserVERBOSE-182))|(1<<(CypherParserOUTPUT-182))|(1<<(CypherParserBUILT-182))|(1<<(CypherParserEACH-182))|(1<<(CypherParserEXECUTABLE-182))|(1<<(CypherParserEXISTENCE-182))|(1<<(CypherParserFULLTEXT-182))|(1<<(CypherParserHOME-182))|(1<<(CypherParserLOOKUP-182))|(1<<(CypherParserHexLetter-182)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(3282)
			p.LiteralEntry()
		}
		p.SetState(3284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(3283)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(3296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__14 {
			{
				p.SetState(3286)
				p.Match(CypherParserT__14)
			}
			p.SetState(3288)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3287)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3290)
				p.LiteralEntry()
			}
			p.SetState(3292)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3291)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(3298)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3301)
		p.Match(CypherParserT__15)
	}

	return localctx
}

// IMapProjectionContext is an interface to support dynamic dispatch.
type IMapProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapProjectionContext differentiates from other interfaces.
	IsMapProjectionContext()
}

type MapProjectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapProjectionContext() *MapProjectionContext {
	var p = new(MapProjectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mapProjection
	return p
}

func (*MapProjectionContext) IsMapProjectionContext() {}

func NewMapProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapProjectionContext {
	var p = new(MapProjectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mapProjection

	return p
}

func (s *MapProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapProjectionContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *MapProjectionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MapProjectionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MapProjectionContext) AllMapProjectionVariants() []IMapProjectionVariantsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapProjectionVariantsContext); ok {
			len++
		}
	}

	tst := make([]IMapProjectionVariantsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapProjectionVariantsContext); ok {
			tst[i] = t.(IMapProjectionVariantsContext)
			i++
		}
	}

	return tst
}

func (s *MapProjectionContext) MapProjectionVariants(i int) IMapProjectionVariantsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapProjectionVariantsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapProjectionVariantsContext)
}

func (s *MapProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMapProjection(s)
	}
}

func (s *MapProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMapProjection(s)
	}
}

func (p *CypherParser) MapProjection() (localctx IMapProjectionContext) {
	this := p
	_ = this

	localctx = NewMapProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, CypherParserRULE_mapProjection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3303)
		p.Variable()
	}
	p.SetState(3305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3304)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3307)
		p.Match(CypherParserT__13)
	}
	p.SetState(3309)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 475, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3308)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(3312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__6 || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(CypherParserCYPHER-54))|(1<<(CypherParserEXPLAIN-54))|(1<<(CypherParserPROFILE-54))|(1<<(CypherParserUSING-54))|(1<<(CypherParserPERIODIC-54))|(1<<(CypherParserCOMMIT-54))|(1<<(CypherParserUNION-54))|(1<<(CypherParserALL-54))|(1<<(CypherParserCREATE-54))|(1<<(CypherParserDROP-54))|(1<<(CypherParserINDEX-54))|(1<<(CypherParserON-54))|(1<<(CypherParserCONSTRAINT-54))|(1<<(CypherParserASSERT-54))|(1<<(CypherParserIS-54))|(1<<(CypherParserUNIQUE-54))|(1<<(CypherParserEXISTS-54))|(1<<(CypherParserLOAD-54))|(1<<(CypherParserCSV-54))|(1<<(CypherParserWITH-54))|(1<<(CypherParserHEADERS-54))|(1<<(CypherParserFROM-54))|(1<<(CypherParserAS-54))|(1<<(CypherParserFIELDTERMINATOR-54))|(1<<(CypherParserOPTIONAL-54))|(1<<(CypherParserMATCH-54))|(1<<(CypherParserUNWIND-54))|(1<<(CypherParserMERGE-54))|(1<<(CypherParserSET-54))|(1<<(CypherParserDETACH-54))|(1<<(CypherParserDELETE-54))|(1<<(CypherParserREMOVE-54)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(CypherParserFOREACH-86))|(1<<(CypherParserIN-86))|(1<<(CypherParserDISTINCT-86))|(1<<(CypherParserRETURN-86))|(1<<(CypherParserORDER-86))|(1<<(CypherParserBY-86))|(1<<(CypherParserL_SKIP-86))|(1<<(CypherParserLIMIT-86))|(1<<(CypherParserASCENDING-86))|(1<<(CypherParserASC-86))|(1<<(CypherParserDESCENDING-86))|(1<<(CypherParserDESC-86))|(1<<(CypherParserJOIN-86))|(1<<(CypherParserSCAN-86))|(1<<(CypherParserSTART-86))|(1<<(CypherParserNODE-86))|(1<<(CypherParserRELATIONSHIP-86))|(1<<(CypherParserREL-86))|(1<<(CypherParserWHERE-86))|(1<<(CypherParserSHORTESTPATH-86))|(1<<(CypherParserALLSHORTESTPATHS-86))|(1<<(CypherParserOR-86))|(1<<(CypherParserXOR-86))|(1<<(CypherParserAND-86))|(1<<(CypherParserNOT-86))|(1<<(CypherParserSTARTS-86))|(1<<(CypherParserENDS-86))|(1<<(CypherParserCONTAINS-86))|(1<<(CypherParserNULL-86))|(1<<(CypherParserCOUNT-86))|(1<<(CypherParserFILTER-86))|(1<<(CypherParserEXTRACT-86)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(CypherParserANY-118))|(1<<(CypherParserNONE-118))|(1<<(CypherParserSINGLE-118))|(1<<(CypherParserTRUE-118))|(1<<(CypherParserFALSE-118))|(1<<(CypherParserREDUCE-118))|(1<<(CypherParserCASE-118))|(1<<(CypherParserELSE-118))|(1<<(CypherParserEND-118))|(1<<(CypherParserWHEN-118))|(1<<(CypherParserTHEN-118))|(1<<(CypherParserCALL-118))|(1<<(CypherParserYIELD-118))|(1<<(CypherParserKEY-118))|(1<<(CypherParserCATALOG-118))|(1<<(CypherParserSHOW-118))|(1<<(CypherParserDEFAULT-118))|(1<<(CypherParserDBMS-118))|(1<<(CypherParserDATABASE-118))|(1<<(CypherParserDATABASES-118))|(1<<(CypherParserGRAPH-118))|(1<<(CypherParserGRAPHS-118))|(1<<(CypherParserREPLACE-118))|(1<<(CypherParserIF-118))|(1<<(CypherParserSTOP-118))|(1<<(CypherParserROLE-118))|(1<<(CypherParserROLES-118))|(1<<(CypherParserUSER-118))|(1<<(CypherParserUSERS-118))|(1<<(CypherParserPOPULATED-118))|(1<<(CypherParserPASSWORD-118))|(1<<(CypherParserCHANGE-118)))) != 0) || (((_la-150)&-(0x1f+1)) == 0 && ((1<<uint((_la-150)))&((1<<(CypherParserREQUIRED-150))|(1<<(CypherParserSTATUS-150))|(1<<(CypherParserACTIVE-150))|(1<<(CypherParserSUSPENDED-150))|(1<<(CypherParserALTER-150))|(1<<(CypherParserCURRENT-150))|(1<<(CypherParserTO-150))|(1<<(CypherParserPRIVILEGES-150))|(1<<(CypherParserGRANT-150))|(1<<(CypherParserDENY-150))|(1<<(CypherParserREVOKE-150))|(1<<(CypherParserRELATIONSHIPS-150))|(1<<(CypherParserNODES-150))|(1<<(CypherParserELEMENT-150))|(1<<(CypherParserELEMENTS-150))|(1<<(CypherParserCOPY-150))|(1<<(CypherParserOF-150))|(1<<(CypherParserTRAVERSE-150))|(1<<(CypherParserREAD-150))|(1<<(CypherParserWRITE-150))|(1<<(CypherParserACCESS-150))|(1<<(CypherParserINDEXES-150))|(1<<(CypherParserMANAGEMENT-150))|(1<<(CypherParserNEW-150))|(1<<(CypherParserLABEL-150))|(1<<(CypherParserLABELS-150))|(1<<(CypherParserNAME-150))|(1<<(CypherParserNAMES-150))|(1<<(CypherParserTYPE-150))|(1<<(CypherParserTYPES-150))|(1<<(CypherParserPROPERTY-150))|(1<<(CypherParserCONSTRAINTS-150)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(CypherParserASSIGN-182))|(1<<(CypherParserBTREE-182))|(1<<(CypherParserEXIST-182))|(1<<(CypherParserFOR-182))|(1<<(CypherParserOPTIONS-182))|(1<<(CypherParserEXECUTE-182))|(1<<(CypherParserDEFINED-182))|(1<<(CypherParserFUNCTION-182))|(1<<(CypherParserFUNCTIONS-182))|(1<<(CypherParserBOOSTED-182))|(1<<(CypherParserPROCEDURE-182))|(1<<(CypherParserPROCEDURES-182))|(1<<(CypherParserADMIN-182))|(1<<(CypherParserADMINISTRATOR-182))|(1<<(CypherParserBRIEF-182))|(1<<(CypherParserVERBOSE-182))|(1<<(CypherParserOUTPUT-182))|(1<<(CypherParserBUILT-182))|(1<<(CypherParserEACH-182))|(1<<(CypherParserEXECUTABLE-182))|(1<<(CypherParserEXISTENCE-182))|(1<<(CypherParserFULLTEXT-182))|(1<<(CypherParserHOME-182))|(1<<(CypherParserLOOKUP-182))|(1<<(CypherParserHexLetter-182)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(3311)
			p.MapProjectionVariants()
		}

	}
	p.SetState(3324)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 479, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3315)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3314)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3317)
				p.Match(CypherParserT__14)
			}
			p.SetState(3319)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3318)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3321)
				p.MapProjectionVariants()
			}

		}
		p.SetState(3326)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 479, p.GetParserRuleContext())
	}
	p.SetState(3328)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3327)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3330)
		p.Match(CypherParserT__15)
	}

	return localctx
}

// IMapProjectionVariantsContext is an interface to support dynamic dispatch.
type IMapProjectionVariantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapProjectionVariantsContext differentiates from other interfaces.
	IsMapProjectionVariantsContext()
}

type MapProjectionVariantsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapProjectionVariantsContext() *MapProjectionVariantsContext {
	var p = new(MapProjectionVariantsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mapProjectionVariants
	return p
}

func (*MapProjectionVariantsContext) IsMapProjectionVariantsContext() {}

func NewMapProjectionVariantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapProjectionVariantsContext {
	var p = new(MapProjectionVariantsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mapProjectionVariants

	return p
}

func (s *MapProjectionVariantsContext) GetParser() antlr.Parser { return s.parser }

func (s *MapProjectionVariantsContext) LiteralEntry() ILiteralEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralEntryContext)
}

func (s *MapProjectionVariantsContext) PropertySelector() IPropertySelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertySelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertySelectorContext)
}

func (s *MapProjectionVariantsContext) VariableSelector() IVariableSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableSelectorContext)
}

func (s *MapProjectionVariantsContext) AllPropertiesSelector() IAllPropertiesSelectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllPropertiesSelectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllPropertiesSelectorContext)
}

func (s *MapProjectionVariantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapProjectionVariantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapProjectionVariantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMapProjectionVariants(s)
	}
}

func (s *MapProjectionVariantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMapProjectionVariants(s)
	}
}

func (p *CypherParser) MapProjectionVariants() (localctx IMapProjectionVariantsContext) {
	this := p
	_ = this

	localctx = NewMapProjectionVariantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, CypherParserRULE_mapProjectionVariants)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3336)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 481, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3332)
			p.LiteralEntry()
		}

	case 2:
		{
			p.SetState(3333)
			p.PropertySelector()
		}

	case 3:
		{
			p.SetState(3334)
			p.VariableSelector()
		}

	case 4:
		{
			p.SetState(3335)
			p.AllPropertiesSelector()
		}

	}

	return localctx
}

// ILiteralEntryContext is an interface to support dynamic dispatch.
type ILiteralEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralEntryContext differentiates from other interfaces.
	IsLiteralEntryContext()
}

type LiteralEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralEntryContext() *LiteralEntryContext {
	var p = new(LiteralEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_literalEntry
	return p
}

func (*LiteralEntryContext) IsLiteralEntryContext() {}

func NewLiteralEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralEntryContext {
	var p = new(LiteralEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_literalEntry

	return p
}

func (s *LiteralEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralEntryContext) PropertyKeyName() IPropertyKeyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyNameContext)
}

func (s *LiteralEntryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LiteralEntryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *LiteralEntryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *LiteralEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLiteralEntry(s)
	}
}

func (s *LiteralEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLiteralEntry(s)
	}
}

func (p *CypherParser) LiteralEntry() (localctx ILiteralEntryContext) {
	this := p
	_ = this

	localctx = NewLiteralEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, CypherParserRULE_literalEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3338)
		p.PropertyKeyName()
	}
	p.SetState(3340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3339)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3342)
		p.Match(CypherParserT__1)
	}
	p.SetState(3344)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3343)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3346)
		p.Expression()
	}

	return localctx
}

// IPropertySelectorContext is an interface to support dynamic dispatch.
type IPropertySelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertySelectorContext differentiates from other interfaces.
	IsPropertySelectorContext()
}

type PropertySelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertySelectorContext() *PropertySelectorContext {
	var p = new(PropertySelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertySelector
	return p
}

func (*PropertySelectorContext) IsPropertySelectorContext() {}

func NewPropertySelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertySelectorContext {
	var p = new(PropertySelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertySelector

	return p
}

func (s *PropertySelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertySelectorContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PropertySelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertySelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertySelector(s)
	}
}

func (s *PropertySelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertySelector(s)
	}
}

func (p *CypherParser) PropertySelector() (localctx IPropertySelectorContext) {
	this := p
	_ = this

	localctx = NewPropertySelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, CypherParserRULE_propertySelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3348)
		p.Match(CypherParserT__6)
	}
	{
		p.SetState(3349)
		p.Variable()
	}

	return localctx
}

// IVariableSelectorContext is an interface to support dynamic dispatch.
type IVariableSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableSelectorContext differentiates from other interfaces.
	IsVariableSelectorContext()
}

type VariableSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableSelectorContext() *VariableSelectorContext {
	var p = new(VariableSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_variableSelector
	return p
}

func (*VariableSelectorContext) IsVariableSelectorContext() {}

func NewVariableSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableSelectorContext {
	var p = new(VariableSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_variableSelector

	return p
}

func (s *VariableSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableSelectorContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *VariableSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterVariableSelector(s)
	}
}

func (s *VariableSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitVariableSelector(s)
	}
}

func (p *CypherParser) VariableSelector() (localctx IVariableSelectorContext) {
	this := p
	_ = this

	localctx = NewVariableSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, CypherParserRULE_variableSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3351)
		p.Variable()
	}

	return localctx
}

// IAllPropertiesSelectorContext is an interface to support dynamic dispatch.
type IAllPropertiesSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAllPropertiesSelectorContext differentiates from other interfaces.
	IsAllPropertiesSelectorContext()
}

type AllPropertiesSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllPropertiesSelectorContext() *AllPropertiesSelectorContext {
	var p = new(AllPropertiesSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_allPropertiesSelector
	return p
}

func (*AllPropertiesSelectorContext) IsAllPropertiesSelectorContext() {}

func NewAllPropertiesSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllPropertiesSelectorContext {
	var p = new(AllPropertiesSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_allPropertiesSelector

	return p
}

func (s *AllPropertiesSelectorContext) GetParser() antlr.Parser { return s.parser }
func (s *AllPropertiesSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllPropertiesSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllPropertiesSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAllPropertiesSelector(s)
	}
}

func (s *AllPropertiesSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAllPropertiesSelector(s)
	}
}

func (p *CypherParser) AllPropertiesSelector() (localctx IAllPropertiesSelectorContext) {
	this := p
	_ = this

	localctx = NewAllPropertiesSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, CypherParserRULE_allPropertiesSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3353)
		p.Match(CypherParserT__6)
	}
	{
		p.SetState(3354)
		p.Match(CypherParserT__18)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) LegacyParameter() ILegacyParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILegacyParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILegacyParameterContext)
}

func (s *ParameterContext) DollarParameter() IDollarParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDollarParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDollarParameterContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *CypherParser) Parameter() (localctx IParameterContext) {
	this := p
	_ = this

	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, CypherParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3358)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__13:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3356)
			p.LegacyParameter()
		}

	case CypherParserT__33:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3357)
			p.DollarParameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILegacyParameterContext is an interface to support dynamic dispatch.
type ILegacyParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLegacyParameterContext differentiates from other interfaces.
	IsLegacyParameterContext()
}

type LegacyParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLegacyParameterContext() *LegacyParameterContext {
	var p = new(LegacyParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_legacyParameter
	return p
}

func (*LegacyParameterContext) IsLegacyParameterContext() {}

func NewLegacyParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LegacyParameterContext {
	var p = new(LegacyParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_legacyParameter

	return p
}

func (s *LegacyParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LegacyParameterContext) ParameterName() IParameterNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterNameContext)
}

func (s *LegacyParameterContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *LegacyParameterContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *LegacyParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LegacyParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLegacyParameter(s)
	}
}

func (s *LegacyParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLegacyParameter(s)
	}
}

func (p *CypherParser) LegacyParameter() (localctx ILegacyParameterContext) {
	this := p
	_ = this

	localctx = NewLegacyParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, CypherParserRULE_legacyParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3360)
		p.Match(CypherParserT__13)
	}
	p.SetState(3362)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3361)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3364)
		p.ParameterName()
	}
	p.SetState(3366)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(3365)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(3368)
		p.Match(CypherParserT__15)
	}

	return localctx
}

// IDollarParameterContext is an interface to support dynamic dispatch.
type IDollarParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDollarParameterContext differentiates from other interfaces.
	IsDollarParameterContext()
}

type DollarParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDollarParameterContext() *DollarParameterContext {
	var p = new(DollarParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dollarParameter
	return p
}

func (*DollarParameterContext) IsDollarParameterContext() {}

func NewDollarParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DollarParameterContext {
	var p = new(DollarParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dollarParameter

	return p
}

func (s *DollarParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *DollarParameterContext) ParameterName() IParameterNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterNameContext)
}

func (s *DollarParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DollarParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DollarParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDollarParameter(s)
	}
}

func (s *DollarParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDollarParameter(s)
	}
}

func (p *CypherParser) DollarParameter() (localctx IDollarParameterContext) {
	this := p
	_ = this

	localctx = NewDollarParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, CypherParserRULE_dollarParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3370)
		p.Match(CypherParserT__33)
	}
	{
		p.SetState(3371)
		p.ParameterName()
	}

	return localctx
}

// IParameterNameContext is an interface to support dynamic dispatch.
type IParameterNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterNameContext differentiates from other interfaces.
	IsParameterNameContext()
}

type ParameterNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterNameContext() *ParameterNameContext {
	var p = new(ParameterNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_parameterName
	return p
}

func (*ParameterNameContext) IsParameterNameContext() {}

func NewParameterNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterNameContext {
	var p = new(ParameterNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parameterName

	return p
}

func (s *ParameterNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterNameContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ParameterNameContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *ParameterNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterParameterName(s)
	}
}

func (s *ParameterNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitParameterName(s)
	}
}

func (p *CypherParser) ParameterName() (localctx IParameterNameContext) {
	this := p
	_ = this

	localctx = NewParameterNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, CypherParserRULE_parameterName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3373)
			p.SymbolicName()
		}

	case CypherParserDecimalInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3374)
			p.Match(CypherParserDecimalInteger)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertyExpressionsContext is an interface to support dynamic dispatch.
type IPropertyExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyExpressionsContext differentiates from other interfaces.
	IsPropertyExpressionsContext()
}

type PropertyExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyExpressionsContext() *PropertyExpressionsContext {
	var p = new(PropertyExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyExpressions
	return p
}

func (*PropertyExpressionsContext) IsPropertyExpressionsContext() {}

func NewPropertyExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyExpressionsContext {
	var p = new(PropertyExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyExpressions

	return p
}

func (s *PropertyExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyExpressionsContext) AllPropertyExpression() []IPropertyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPropertyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyExpressionContext); ok {
			tst[i] = t.(IPropertyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyExpressionsContext) PropertyExpression(i int) IPropertyExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *PropertyExpressionsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyExpressionsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyExpressions(s)
	}
}

func (s *PropertyExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyExpressions(s)
	}
}

func (p *CypherParser) PropertyExpressions() (localctx IPropertyExpressionsContext) {
	this := p
	_ = this

	localctx = NewPropertyExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, CypherParserRULE_propertyExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3377)
		p.PropertyExpression()
	}
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 490, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3378)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3381)
				p.Match(CypherParserT__14)
			}
			p.SetState(3383)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3382)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3385)
				p.PropertyExpression()
			}

		}
		p.SetState(3390)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 490, p.GetParserRuleContext())
	}

	return localctx
}

// IPropertyExpressionContext is an interface to support dynamic dispatch.
type IPropertyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyExpressionContext differentiates from other interfaces.
	IsPropertyExpressionContext()
}

type PropertyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyExpressionContext() *PropertyExpressionContext {
	var p = new(PropertyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyExpression
	return p
}

func (*PropertyExpressionContext) IsPropertyExpressionContext() {}

func NewPropertyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyExpressionContext {
	var p = new(PropertyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyExpression

	return p
}

func (s *PropertyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyExpressionContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PropertyExpressionContext) AllPropertyLookup() []IPropertyLookupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyLookupContext); ok {
			len++
		}
	}

	tst := make([]IPropertyLookupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyLookupContext); ok {
			tst[i] = t.(IPropertyLookupContext)
			i++
		}
	}

	return tst
}

func (s *PropertyExpressionContext) PropertyLookup(i int) IPropertyLookupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyLookupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyLookupContext)
}

func (s *PropertyExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyExpression(s)
	}
}

func (s *PropertyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyExpression(s)
	}
}

func (p *CypherParser) PropertyExpression() (localctx IPropertyExpressionContext) {
	this := p
	_ = this

	localctx = NewPropertyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, CypherParserRULE_propertyExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3391)
		p.Atom()
	}
	p.SetState(3396)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3393)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3392)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3395)
				p.PropertyLookup()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3398)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 492, p.GetParserRuleContext())
	}

	return localctx
}

// IPropertyKeysContext is an interface to support dynamic dispatch.
type IPropertyKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyKeysContext differentiates from other interfaces.
	IsPropertyKeysContext()
}

type PropertyKeysContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeysContext() *PropertyKeysContext {
	var p = new(PropertyKeysContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyKeys
	return p
}

func (*PropertyKeysContext) IsPropertyKeysContext() {}

func NewPropertyKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeysContext {
	var p = new(PropertyKeysContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyKeys

	return p
}

func (s *PropertyKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeysContext) AllPropertyKeyName() []IPropertyKeyNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyKeyNameContext); ok {
			len++
		}
	}

	tst := make([]IPropertyKeyNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyKeyNameContext); ok {
			tst[i] = t.(IPropertyKeyNameContext)
			i++
		}
	}

	return tst
}

func (s *PropertyKeysContext) PropertyKeyName(i int) IPropertyKeyNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyNameContext)
}

func (s *PropertyKeysContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyKeysContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyKeys(s)
	}
}

func (s *PropertyKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyKeys(s)
	}
}

func (p *CypherParser) PropertyKeys() (localctx IPropertyKeysContext) {
	this := p
	_ = this

	localctx = NewPropertyKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, CypherParserRULE_propertyKeys)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3400)
		p.PropertyKeyName()
	}
	p.SetState(3411)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3402)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3401)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3404)
				p.Match(CypherParserT__14)
			}
			p.SetState(3406)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(3405)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(3408)
				p.PropertyKeyName()
			}

		}
		p.SetState(3413)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext())
	}

	return localctx
}

// IPropertyKeyNameContext is an interface to support dynamic dispatch.
type IPropertyKeyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyKeyNameContext differentiates from other interfaces.
	IsPropertyKeyNameContext()
}

type PropertyKeyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyNameContext() *PropertyKeyNameContext {
	var p = new(PropertyKeyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyKeyName
	return p
}

func (*PropertyKeyNameContext) IsPropertyKeyNameContext() {}

func NewPropertyKeyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyNameContext {
	var p = new(PropertyKeyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyKeyName

	return p
}

func (s *PropertyKeyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyNameContext) SymbolicName() ISymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *PropertyKeyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyKeyName(s)
	}
}

func (s *PropertyKeyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyKeyName(s)
	}
}

func (p *CypherParser) PropertyKeyName() (localctx IPropertyKeyNameContext) {
	this := p
	_ = this

	localctx = NewPropertyKeyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, CypherParserRULE_propertyKeyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3414)
		p.SymbolicName()
	}

	return localctx
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_integerLiteral
	return p
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) HexInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserHexInteger, 0)
}

func (s *IntegerLiteralContext) OctalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserOctalInteger, 0)
}

func (s *IntegerLiteralContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *CypherParser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	this := p
	_ = this

	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, CypherParserRULE_integerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3416)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-210)&-(0x1f+1)) == 0 && ((1<<uint((_la-210)))&((1<<(CypherParserHexInteger-210))|(1<<(CypherParserDecimalInteger-210))|(1<<(CypherParserOctalInteger-210)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDoubleLiteralContext is an interface to support dynamic dispatch.
type IDoubleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoubleLiteralContext differentiates from other interfaces.
	IsDoubleLiteralContext()
}

type DoubleLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleLiteralContext() *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_doubleLiteral
	return p
}

func (*DoubleLiteralContext) IsDoubleLiteralContext() {}

func NewDoubleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_doubleLiteral

	return p
}

func (s *DoubleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleLiteralContext) ExponentDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserExponentDecimalReal, 0)
}

func (s *DoubleLiteralContext) RegularDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserRegularDecimalReal, 0)
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

func (p *CypherParser) DoubleLiteral() (localctx IDoubleLiteralContext) {
	this := p
	_ = this

	localctx = NewDoubleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, CypherParserRULE_doubleLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3418)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserExponentDecimalReal || _la == CypherParserRegularDecimalReal) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INamespaceContext is an interface to support dynamic dispatch.
type INamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceContext differentiates from other interfaces.
	IsNamespaceContext()
}

type NamespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceContext() *NamespaceContext {
	var p = new(NamespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_namespace
	return p
}

func (*NamespaceContext) IsNamespaceContext() {}

func NewNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceContext {
	var p = new(NamespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_namespace

	return p
}

func (s *NamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceContext) AllSymbolicName() []ISymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicNameContext); ok {
			tst[i] = t.(ISymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceContext) SymbolicName(i int) ISymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *NamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNamespace(s)
	}
}

func (s *NamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNamespace(s)
	}
}

func (p *CypherParser) Namespace() (localctx INamespaceContext) {
	this := p
	_ = this

	localctx = NewNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, CypherParserRULE_namespace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3425)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 496, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3420)
				p.SymbolicName()
			}
			{
				p.SetState(3421)
				p.Match(CypherParserT__6)
			}

		}
		p.SetState(3427)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 496, p.GetParserRuleContext())
	}

	return localctx
}

// ILeftArrowHeadContext is an interface to support dynamic dispatch.
type ILeftArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftArrowHeadContext differentiates from other interfaces.
	IsLeftArrowHeadContext()
}

type LeftArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftArrowHeadContext() *LeftArrowHeadContext {
	var p = new(LeftArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_leftArrowHead
	return p
}

func (*LeftArrowHeadContext) IsLeftArrowHeadContext() {}

func NewLeftArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftArrowHeadContext {
	var p = new(LeftArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_leftArrowHead

	return p
}

func (s *LeftArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *LeftArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLeftArrowHead(s)
	}
}

func (s *LeftArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLeftArrowHead(s)
	}
}

func (p *CypherParser) LeftArrowHead() (localctx ILeftArrowHeadContext) {
	this := p
	_ = this

	localctx = NewLeftArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, CypherParserRULE_leftArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3428)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-30)&-(0x1f+1)) == 0 && ((1<<uint((_la-30)))&((1<<(CypherParserT__29-30))|(1<<(CypherParserT__34-30))|(1<<(CypherParserT__35-30))|(1<<(CypherParserT__36-30))|(1<<(CypherParserT__37-30)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRightArrowHeadContext is an interface to support dynamic dispatch.
type IRightArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRightArrowHeadContext differentiates from other interfaces.
	IsRightArrowHeadContext()
}

type RightArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRightArrowHeadContext() *RightArrowHeadContext {
	var p = new(RightArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_rightArrowHead
	return p
}

func (*RightArrowHeadContext) IsRightArrowHeadContext() {}

func NewRightArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RightArrowHeadContext {
	var p = new(RightArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_rightArrowHead

	return p
}

func (s *RightArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *RightArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RightArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RightArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRightArrowHead(s)
	}
}

func (s *RightArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRightArrowHead(s)
	}
}

func (p *CypherParser) RightArrowHead() (localctx IRightArrowHeadContext) {
	this := p
	_ = this

	localctx = NewRightArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, CypherParserRULE_rightArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3430)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-31)&-(0x1f+1)) == 0 && ((1<<uint((_la-31)))&((1<<(CypherParserT__30-31))|(1<<(CypherParserT__38-31))|(1<<(CypherParserT__39-31))|(1<<(CypherParserT__40-31))|(1<<(CypherParserT__41-31)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDashContext is an interface to support dynamic dispatch.
type IDashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDashContext differentiates from other interfaces.
	IsDashContext()
}

type DashContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDashContext() *DashContext {
	var p = new(DashContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dash
	return p
}

func (*DashContext) IsDashContext() {}

func NewDashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DashContext {
	var p = new(DashContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dash

	return p
}

func (s *DashContext) GetParser() antlr.Parser { return s.parser }
func (s *DashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDash(s)
	}
}

func (s *DashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDash(s)
	}
}

func (p *CypherParser) Dash() (localctx IDashContext) {
	this := p
	_ = this

	localctx = NewDashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, CypherParserRULE_dash)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3432)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserT__2 || (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(CypherParserT__42-43))|(1<<(CypherParserT__43-43))|(1<<(CypherParserT__44-43))|(1<<(CypherParserT__45-43))|(1<<(CypherParserT__46-43))|(1<<(CypherParserT__47-43))|(1<<(CypherParserT__48-43))|(1<<(CypherParserT__49-43))|(1<<(CypherParserT__50-43))|(1<<(CypherParserT__51-43))|(1<<(CypherParserT__52-43)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISymbolicNameContext is an interface to support dynamic dispatch.
type ISymbolicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicNameContext differentiates from other interfaces.
	IsSymbolicNameContext()
}

type SymbolicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicNameContext() *SymbolicNameContext {
	var p = new(SymbolicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_symbolicName
	return p
}

func (*SymbolicNameContext) IsSymbolicNameContext() {}

func NewSymbolicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicNameContext {
	var p = new(SymbolicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_symbolicName

	return p
}

func (s *SymbolicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicNameContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *SymbolicNameContext) UnescapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserUnescapedSymbolicName, 0)
}

func (s *SymbolicNameContext) EscapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserEscapedSymbolicName, 0)
}

func (s *SymbolicNameContext) HexLetter() antlr.TerminalNode {
	return s.GetToken(CypherParserHexLetter, 0)
}

func (s *SymbolicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSymbolicName(s)
	}
}

func (s *SymbolicNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSymbolicName(s)
	}
}

func (p *CypherParser) SymbolicName() (localctx ISymbolicNameContext) {
	this := p
	_ = this

	localctx = NewSymbolicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, CypherParserRULE_symbolicName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3438)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCYPHER, CypherParserEXPLAIN, CypherParserPROFILE, CypherParserUSING, CypherParserPERIODIC, CypherParserCOMMIT, CypherParserUNION, CypherParserALL, CypherParserCREATE, CypherParserDROP, CypherParserINDEX, CypherParserON, CypherParserCONSTRAINT, CypherParserASSERT, CypherParserIS, CypherParserUNIQUE, CypherParserEXISTS, CypherParserLOAD, CypherParserCSV, CypherParserWITH, CypherParserHEADERS, CypherParserFROM, CypherParserAS, CypherParserFIELDTERMINATOR, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserFOREACH, CypherParserIN, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserJOIN, CypherParserSCAN, CypherParserSTART, CypherParserNODE, CypherParserRELATIONSHIP, CypherParserREL, CypherParserWHERE, CypherParserSHORTESTPATH, CypherParserALLSHORTESTPATHS, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserREDUCE, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCALL, CypherParserYIELD, CypherParserKEY, CypherParserCATALOG, CypherParserSHOW, CypherParserDEFAULT, CypherParserDBMS, CypherParserDATABASE, CypherParserDATABASES, CypherParserGRAPH, CypherParserGRAPHS, CypherParserREPLACE, CypherParserIF, CypherParserSTOP, CypherParserROLE, CypherParserROLES, CypherParserUSER, CypherParserUSERS, CypherParserPOPULATED, CypherParserPASSWORD, CypherParserCHANGE, CypherParserREQUIRED, CypherParserSTATUS, CypherParserACTIVE, CypherParserSUSPENDED, CypherParserALTER, CypherParserCURRENT, CypherParserTO, CypherParserPRIVILEGES, CypherParserGRANT, CypherParserDENY, CypherParserREVOKE, CypherParserRELATIONSHIPS, CypherParserNODES, CypherParserELEMENT, CypherParserELEMENTS, CypherParserCOPY, CypherParserOF, CypherParserTRAVERSE, CypherParserREAD, CypherParserWRITE, CypherParserACCESS, CypherParserINDEXES, CypherParserMANAGEMENT, CypherParserNEW, CypherParserLABEL, CypherParserLABELS, CypherParserNAME, CypherParserNAMES, CypherParserTYPE, CypherParserTYPES, CypherParserPROPERTY, CypherParserCONSTRAINTS, CypherParserASSIGN, CypherParserBTREE, CypherParserEXIST, CypherParserFOR, CypherParserOPTIONS, CypherParserEXECUTE, CypherParserDEFINED, CypherParserFUNCTION, CypherParserFUNCTIONS, CypherParserBOOSTED, CypherParserPROCEDURE, CypherParserPROCEDURES, CypherParserADMIN, CypherParserADMINISTRATOR, CypherParserBRIEF, CypherParserVERBOSE, CypherParserOUTPUT, CypherParserBUILT, CypherParserEACH, CypherParserEXECUTABLE, CypherParserEXISTENCE, CypherParserFULLTEXT, CypherParserHOME, CypherParserLOOKUP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3434)
			p.Keyword()
		}

	case CypherParserUnescapedSymbolicName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3435)
			p.Match(CypherParserUnescapedSymbolicName)
		}

	case CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3436)
			p.Match(CypherParserEscapedSymbolicName)
		}

	case CypherParserHexLetter:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3437)
			p.Match(CypherParserHexLetter)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) CYPHER() antlr.TerminalNode {
	return s.GetToken(CypherParserCYPHER, 0)
}

func (s *KeywordContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(CypherParserEXPLAIN, 0)
}

func (s *KeywordContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(CypherParserPROFILE, 0)
}

func (s *KeywordContext) USING() antlr.TerminalNode {
	return s.GetToken(CypherParserUSING, 0)
}

func (s *KeywordContext) PERIODIC() antlr.TerminalNode {
	return s.GetToken(CypherParserPERIODIC, 0)
}

func (s *KeywordContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOMMIT, 0)
}

func (s *KeywordContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *KeywordContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *KeywordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *KeywordContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *KeywordContext) INDEX() antlr.TerminalNode {
	return s.GetToken(CypherParserINDEX, 0)
}

func (s *KeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *KeywordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *KeywordContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(CypherParserASSERT, 0)
}

func (s *KeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *KeywordContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CypherParserUNIQUE, 0)
}

func (s *KeywordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *KeywordContext) LOAD() antlr.TerminalNode {
	return s.GetToken(CypherParserLOAD, 0)
}

func (s *KeywordContext) CSV() antlr.TerminalNode {
	return s.GetToken(CypherParserCSV, 0)
}

func (s *KeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *KeywordContext) HEADERS() antlr.TerminalNode {
	return s.GetToken(CypherParserHEADERS, 0)
}

func (s *KeywordContext) FROM() antlr.TerminalNode {
	return s.GetToken(CypherParserFROM, 0)
}

func (s *KeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *KeywordContext) FIELDTERMINATOR() antlr.TerminalNode {
	return s.GetToken(CypherParserFIELDTERMINATOR, 0)
}

func (s *KeywordContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *KeywordContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *KeywordContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *KeywordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *KeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *KeywordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *KeywordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *KeywordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *KeywordContext) FOREACH() antlr.TerminalNode {
	return s.GetToken(CypherParserFOREACH, 0)
}

func (s *KeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *KeywordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *KeywordContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *KeywordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *KeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *KeywordContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *KeywordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *KeywordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *KeywordContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *KeywordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *KeywordContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *KeywordContext) JOIN() antlr.TerminalNode {
	return s.GetToken(CypherParserJOIN, 0)
}

func (s *KeywordContext) SCAN() antlr.TerminalNode {
	return s.GetToken(CypherParserSCAN, 0)
}

func (s *KeywordContext) START() antlr.TerminalNode {
	return s.GetToken(CypherParserSTART, 0)
}

func (s *KeywordContext) NODE() antlr.TerminalNode {
	return s.GetToken(CypherParserNODE, 0)
}

func (s *KeywordContext) RELATIONSHIP() antlr.TerminalNode {
	return s.GetToken(CypherParserRELATIONSHIP, 0)
}

func (s *KeywordContext) REL() antlr.TerminalNode {
	return s.GetToken(CypherParserREL, 0)
}

func (s *KeywordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *KeywordContext) SHORTESTPATH() antlr.TerminalNode {
	return s.GetToken(CypherParserSHORTESTPATH, 0)
}

func (s *KeywordContext) ALLSHORTESTPATHS() antlr.TerminalNode {
	return s.GetToken(CypherParserALLSHORTESTPATHS, 0)
}

func (s *KeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(CypherParserOR, 0)
}

func (s *KeywordContext) XOR() antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, 0)
}

func (s *KeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(CypherParserAND, 0)
}

func (s *KeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *KeywordContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *KeywordContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *KeywordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *KeywordContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *KeywordContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *KeywordContext) FILTER() antlr.TerminalNode {
	return s.GetToken(CypherParserFILTER, 0)
}

func (s *KeywordContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(CypherParserEXTRACT, 0)
}

func (s *KeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *KeywordContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *KeywordContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *KeywordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *KeywordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *KeywordContext) REDUCE() antlr.TerminalNode {
	return s.GetToken(CypherParserREDUCE, 0)
}

func (s *KeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *KeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *KeywordContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *KeywordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *KeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *KeywordContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *KeywordContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *KeywordContext) KEY() antlr.TerminalNode {
	return s.GetToken(CypherParserKEY, 0)
}

func (s *KeywordContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(CypherParserCATALOG, 0)
}

func (s *KeywordContext) SHOW() antlr.TerminalNode {
	return s.GetToken(CypherParserSHOW, 0)
}

func (s *KeywordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(CypherParserDEFAULT, 0)
}

func (s *KeywordContext) DBMS() antlr.TerminalNode {
	return s.GetToken(CypherParserDBMS, 0)
}

func (s *KeywordContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASE, 0)
}

func (s *KeywordContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(CypherParserDATABASES, 0)
}

func (s *KeywordContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(CypherParserGRAPH, 0)
}

func (s *KeywordContext) GRAPHS() antlr.TerminalNode {
	return s.GetToken(CypherParserGRAPHS, 0)
}

func (s *KeywordContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(CypherParserREPLACE, 0)
}

func (s *KeywordContext) IF() antlr.TerminalNode {
	return s.GetToken(CypherParserIF, 0)
}

func (s *KeywordContext) STOP() antlr.TerminalNode {
	return s.GetToken(CypherParserSTOP, 0)
}

func (s *KeywordContext) ROLE() antlr.TerminalNode {
	return s.GetToken(CypherParserROLE, 0)
}

func (s *KeywordContext) ROLES() antlr.TerminalNode {
	return s.GetToken(CypherParserROLES, 0)
}

func (s *KeywordContext) USER() antlr.TerminalNode {
	return s.GetToken(CypherParserUSER, 0)
}

func (s *KeywordContext) USERS() antlr.TerminalNode {
	return s.GetToken(CypherParserUSERS, 0)
}

func (s *KeywordContext) POPULATED() antlr.TerminalNode {
	return s.GetToken(CypherParserPOPULATED, 0)
}

func (s *KeywordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(CypherParserPASSWORD, 0)
}

func (s *KeywordContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(CypherParserCHANGE, 0)
}

func (s *KeywordContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(CypherParserREQUIRED, 0)
}

func (s *KeywordContext) STATUS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTATUS, 0)
}

func (s *KeywordContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(CypherParserACTIVE, 0)
}

func (s *KeywordContext) SUSPENDED() antlr.TerminalNode {
	return s.GetToken(CypherParserSUSPENDED, 0)
}

func (s *KeywordContext) ALTER() antlr.TerminalNode {
	return s.GetToken(CypherParserALTER, 0)
}

func (s *KeywordContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(CypherParserCURRENT, 0)
}

func (s *KeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(CypherParserTO, 0)
}

func (s *KeywordContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(CypherParserPRIVILEGES, 0)
}

func (s *KeywordContext) GRANT() antlr.TerminalNode {
	return s.GetToken(CypherParserGRANT, 0)
}

func (s *KeywordContext) DENY() antlr.TerminalNode {
	return s.GetToken(CypherParserDENY, 0)
}

func (s *KeywordContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(CypherParserREVOKE, 0)
}

func (s *KeywordContext) RELATIONSHIPS() antlr.TerminalNode {
	return s.GetToken(CypherParserRELATIONSHIPS, 0)
}

func (s *KeywordContext) NODES() antlr.TerminalNode {
	return s.GetToken(CypherParserNODES, 0)
}

func (s *KeywordContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(CypherParserELEMENT, 0)
}

func (s *KeywordContext) ELEMENTS() antlr.TerminalNode {
	return s.GetToken(CypherParserELEMENTS, 0)
}

func (s *KeywordContext) COPY() antlr.TerminalNode {
	return s.GetToken(CypherParserCOPY, 0)
}

func (s *KeywordContext) OF() antlr.TerminalNode {
	return s.GetToken(CypherParserOF, 0)
}

func (s *KeywordContext) TRAVERSE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRAVERSE, 0)
}

func (s *KeywordContext) READ() antlr.TerminalNode {
	return s.GetToken(CypherParserREAD, 0)
}

func (s *KeywordContext) WRITE() antlr.TerminalNode {
	return s.GetToken(CypherParserWRITE, 0)
}

func (s *KeywordContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(CypherParserACCESS, 0)
}

func (s *KeywordContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(CypherParserINDEXES, 0)
}

func (s *KeywordContext) MANAGEMENT() antlr.TerminalNode {
	return s.GetToken(CypherParserMANAGEMENT, 0)
}

func (s *KeywordContext) NEW() antlr.TerminalNode {
	return s.GetToken(CypherParserNEW, 0)
}

func (s *KeywordContext) LABEL() antlr.TerminalNode {
	return s.GetToken(CypherParserLABEL, 0)
}

func (s *KeywordContext) LABELS() antlr.TerminalNode {
	return s.GetToken(CypherParserLABELS, 0)
}

func (s *KeywordContext) NAME() antlr.TerminalNode {
	return s.GetToken(CypherParserNAME, 0)
}

func (s *KeywordContext) NAMES() antlr.TerminalNode {
	return s.GetToken(CypherParserNAMES, 0)
}

func (s *KeywordContext) TYPE() antlr.TerminalNode {
	return s.GetToken(CypherParserTYPE, 0)
}

func (s *KeywordContext) TYPES() antlr.TerminalNode {
	return s.GetToken(CypherParserTYPES, 0)
}

func (s *KeywordContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(CypherParserPROPERTY, 0)
}

func (s *KeywordContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINTS, 0)
}

func (s *KeywordContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(CypherParserASSIGN, 0)
}

func (s *KeywordContext) BTREE() antlr.TerminalNode {
	return s.GetToken(CypherParserBTREE, 0)
}

func (s *KeywordContext) EXIST() antlr.TerminalNode {
	return s.GetToken(CypherParserEXIST, 0)
}

func (s *KeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(CypherParserFOR, 0)
}

func (s *KeywordContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONS, 0)
}

func (s *KeywordContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(CypherParserEXECUTE, 0)
}

func (s *KeywordContext) DEFINED() antlr.TerminalNode {
	return s.GetToken(CypherParserDEFINED, 0)
}

func (s *KeywordContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(CypherParserFUNCTION, 0)
}

func (s *KeywordContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(CypherParserFUNCTIONS, 0)
}

func (s *KeywordContext) BOOSTED() antlr.TerminalNode {
	return s.GetToken(CypherParserBOOSTED, 0)
}

func (s *KeywordContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(CypherParserPROCEDURE, 0)
}

func (s *KeywordContext) PROCEDURES() antlr.TerminalNode {
	return s.GetToken(CypherParserPROCEDURES, 0)
}

func (s *KeywordContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(CypherParserADMIN, 0)
}

func (s *KeywordContext) ADMINISTRATOR() antlr.TerminalNode {
	return s.GetToken(CypherParserADMINISTRATOR, 0)
}

func (s *KeywordContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(CypherParserBRIEF, 0)
}

func (s *KeywordContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(CypherParserVERBOSE, 0)
}

func (s *KeywordContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(CypherParserOUTPUT, 0)
}

func (s *KeywordContext) BUILT() antlr.TerminalNode {
	return s.GetToken(CypherParserBUILT, 0)
}

func (s *KeywordContext) EACH() antlr.TerminalNode {
	return s.GetToken(CypherParserEACH, 0)
}

func (s *KeywordContext) EXECUTABLE() antlr.TerminalNode {
	return s.GetToken(CypherParserEXECUTABLE, 0)
}

func (s *KeywordContext) EXISTENCE() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTENCE, 0)
}

func (s *KeywordContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(CypherParserFULLTEXT, 0)
}

func (s *KeywordContext) HOME() antlr.TerminalNode {
	return s.GetToken(CypherParserHOME, 0)
}

func (s *KeywordContext) LOOKUP() antlr.TerminalNode {
	return s.GetToken(CypherParserLOOKUP, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (p *CypherParser) Keyword() (localctx IKeywordContext) {
	this := p
	_ = this

	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, CypherParserRULE_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3440)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(CypherParserCYPHER-54))|(1<<(CypherParserEXPLAIN-54))|(1<<(CypherParserPROFILE-54))|(1<<(CypherParserUSING-54))|(1<<(CypherParserPERIODIC-54))|(1<<(CypherParserCOMMIT-54))|(1<<(CypherParserUNION-54))|(1<<(CypherParserALL-54))|(1<<(CypherParserCREATE-54))|(1<<(CypherParserDROP-54))|(1<<(CypherParserINDEX-54))|(1<<(CypherParserON-54))|(1<<(CypherParserCONSTRAINT-54))|(1<<(CypherParserASSERT-54))|(1<<(CypherParserIS-54))|(1<<(CypherParserUNIQUE-54))|(1<<(CypherParserEXISTS-54))|(1<<(CypherParserLOAD-54))|(1<<(CypherParserCSV-54))|(1<<(CypherParserWITH-54))|(1<<(CypherParserHEADERS-54))|(1<<(CypherParserFROM-54))|(1<<(CypherParserAS-54))|(1<<(CypherParserFIELDTERMINATOR-54))|(1<<(CypherParserOPTIONAL-54))|(1<<(CypherParserMATCH-54))|(1<<(CypherParserUNWIND-54))|(1<<(CypherParserMERGE-54))|(1<<(CypherParserSET-54))|(1<<(CypherParserDETACH-54))|(1<<(CypherParserDELETE-54))|(1<<(CypherParserREMOVE-54)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(CypherParserFOREACH-86))|(1<<(CypherParserIN-86))|(1<<(CypherParserDISTINCT-86))|(1<<(CypherParserRETURN-86))|(1<<(CypherParserORDER-86))|(1<<(CypherParserBY-86))|(1<<(CypherParserL_SKIP-86))|(1<<(CypherParserLIMIT-86))|(1<<(CypherParserASCENDING-86))|(1<<(CypherParserASC-86))|(1<<(CypherParserDESCENDING-86))|(1<<(CypherParserDESC-86))|(1<<(CypherParserJOIN-86))|(1<<(CypherParserSCAN-86))|(1<<(CypherParserSTART-86))|(1<<(CypherParserNODE-86))|(1<<(CypherParserRELATIONSHIP-86))|(1<<(CypherParserREL-86))|(1<<(CypherParserWHERE-86))|(1<<(CypherParserSHORTESTPATH-86))|(1<<(CypherParserALLSHORTESTPATHS-86))|(1<<(CypherParserOR-86))|(1<<(CypherParserXOR-86))|(1<<(CypherParserAND-86))|(1<<(CypherParserNOT-86))|(1<<(CypherParserSTARTS-86))|(1<<(CypherParserENDS-86))|(1<<(CypherParserCONTAINS-86))|(1<<(CypherParserNULL-86))|(1<<(CypherParserCOUNT-86))|(1<<(CypherParserFILTER-86))|(1<<(CypherParserEXTRACT-86)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(CypherParserANY-118))|(1<<(CypherParserNONE-118))|(1<<(CypherParserSINGLE-118))|(1<<(CypherParserTRUE-118))|(1<<(CypherParserFALSE-118))|(1<<(CypherParserREDUCE-118))|(1<<(CypherParserCASE-118))|(1<<(CypherParserELSE-118))|(1<<(CypherParserEND-118))|(1<<(CypherParserWHEN-118))|(1<<(CypherParserTHEN-118))|(1<<(CypherParserCALL-118))|(1<<(CypherParserYIELD-118))|(1<<(CypherParserKEY-118))|(1<<(CypherParserCATALOG-118))|(1<<(CypherParserSHOW-118))|(1<<(CypherParserDEFAULT-118))|(1<<(CypherParserDBMS-118))|(1<<(CypherParserDATABASE-118))|(1<<(CypherParserDATABASES-118))|(1<<(CypherParserGRAPH-118))|(1<<(CypherParserGRAPHS-118))|(1<<(CypherParserREPLACE-118))|(1<<(CypherParserIF-118))|(1<<(CypherParserSTOP-118))|(1<<(CypherParserROLE-118))|(1<<(CypherParserROLES-118))|(1<<(CypherParserUSER-118))|(1<<(CypherParserUSERS-118))|(1<<(CypherParserPOPULATED-118))|(1<<(CypherParserPASSWORD-118))|(1<<(CypherParserCHANGE-118)))) != 0) || (((_la-150)&-(0x1f+1)) == 0 && ((1<<uint((_la-150)))&((1<<(CypherParserREQUIRED-150))|(1<<(CypherParserSTATUS-150))|(1<<(CypherParserACTIVE-150))|(1<<(CypherParserSUSPENDED-150))|(1<<(CypherParserALTER-150))|(1<<(CypherParserCURRENT-150))|(1<<(CypherParserTO-150))|(1<<(CypherParserPRIVILEGES-150))|(1<<(CypherParserGRANT-150))|(1<<(CypherParserDENY-150))|(1<<(CypherParserREVOKE-150))|(1<<(CypherParserRELATIONSHIPS-150))|(1<<(CypherParserNODES-150))|(1<<(CypherParserELEMENT-150))|(1<<(CypherParserELEMENTS-150))|(1<<(CypherParserCOPY-150))|(1<<(CypherParserOF-150))|(1<<(CypherParserTRAVERSE-150))|(1<<(CypherParserREAD-150))|(1<<(CypherParserWRITE-150))|(1<<(CypherParserACCESS-150))|(1<<(CypherParserINDEXES-150))|(1<<(CypherParserMANAGEMENT-150))|(1<<(CypherParserNEW-150))|(1<<(CypherParserLABEL-150))|(1<<(CypherParserLABELS-150))|(1<<(CypherParserNAME-150))|(1<<(CypherParserNAMES-150))|(1<<(CypherParserTYPE-150))|(1<<(CypherParserTYPES-150))|(1<<(CypherParserPROPERTY-150))|(1<<(CypherParserCONSTRAINTS-150)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(CypherParserASSIGN-182))|(1<<(CypherParserBTREE-182))|(1<<(CypherParserEXIST-182))|(1<<(CypherParserFOR-182))|(1<<(CypherParserOPTIONS-182))|(1<<(CypherParserEXECUTE-182))|(1<<(CypherParserDEFINED-182))|(1<<(CypherParserFUNCTION-182))|(1<<(CypherParserFUNCTIONS-182))|(1<<(CypherParserBOOSTED-182))|(1<<(CypherParserPROCEDURE-182))|(1<<(CypherParserPROCEDURES-182))|(1<<(CypherParserADMIN-182))|(1<<(CypherParserADMINISTRATOR-182))|(1<<(CypherParserBRIEF-182))|(1<<(CypherParserVERBOSE-182))|(1<<(CypherParserOUTPUT-182))|(1<<(CypherParserBUILT-182))|(1<<(CypherParserEACH-182))|(1<<(CypherParserEXECUTABLE-182))|(1<<(CypherParserEXISTENCE-182))|(1<<(CypherParserFULLTEXT-182))|(1<<(CypherParserHOME-182))|(1<<(CypherParserLOOKUP-182)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
